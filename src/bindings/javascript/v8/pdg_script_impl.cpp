// -----------------------------------------------
// This file automatically generated from:
//
//    pdg/src/bindings/common/pdg_script_impl.cpp
//    pdg/src/bindings/javascript/v8/pdg_script_macros.h
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// -----------------------------------------------



#include "pdg_project.h"

#define PDG_COMPILING_SCRIPT_IMPL

#include "pdg_script_impl.h"
#include "pdg_script_interface.h"

#include "internals.h"
#include "pdg-lib.h"

#include <sstream>
#include <cmath>
#include <cstdlib>

#ifndef PDG_DEBUG_SCRIPTING

#define SCRIPT_DEBUG_ONLY(_expression)
#else
#define SCRIPT_DEBUG_ONLY DEBUG_ONLY
#endif

namespace pdg
{

    bool s_HaveSavedError = false;

    static bool s_MemBlock_InNewFromNative = false;

    v8::Handle<v8::Value> MemBlockWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        MemBlockWrap* objWrapper = new MemBlockWrap(args);
        objWrapper->Wrap(args.This());
        MemBlock* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mMemBlockScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> MemBlockWrap::NewFromNative(MemBlock* nativeObj)
    {
        s_MemBlock_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(obj);

        nativeObj->mMemBlockScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_MemBlock_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> MemBlockWrap::constructorTpl_;

    void MemBlockWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("MemBlock"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetData_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetData_Tpl =
            v8::FunctionTemplate::New(GetData, v8::Handle<v8::Value>(), GetData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getData"), GetData_Tpl);
        v8::Local<v8::Signature> GetDataSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetDataSize_Tpl =
            v8::FunctionTemplate::New(GetDataSize, v8::Handle<v8::Value>(), GetDataSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getDataSize"), GetDataSize_Tpl);
        v8::Local<v8::Signature> GetByte_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetByte_Tpl =
            v8::FunctionTemplate::New(GetByte, v8::Handle<v8::Value>(), GetByte_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getByte"), GetByte_Tpl);
        v8::Local<v8::Signature> GetBytes_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetBytes_Tpl =
            v8::FunctionTemplate::New(GetBytes, v8::Handle<v8::Value>(), GetBytes_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getBytes"), GetBytes_Tpl);
        target->Set(v8::String::NewSymbol("MemBlock"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> MemBlockWrap::GetData(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[string Binary]" " function" "()" " - " "") );
        }
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        v8::Local<v8::Value> resultVal = EncodeBinary(self->ptr, self->bytes);
        return scope.Close( resultVal );
    }

    v8::Handle<v8::Value> MemBlockWrap::GetDataSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        }
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        return scope.Close( v8::Integer::NewFromUnsigned(self->bytes) );
    }

    v8::Handle<v8::Value> MemBlockWrap::GetByte(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([number uint] i)" " - " "") );
        }
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""i"")");
        unsigned long i = args[1 -1]->Uint32Value();
        return scope.Close( v8::Integer::NewFromUnsigned(self->ptr[i]) );
    }

    v8::Handle<v8::Value> MemBlockWrap::GetBytes(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        MemBlockWrap* objWrapper = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args.This());
        MemBlock* self = dynamic_cast<MemBlock*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[string Binary]" " function" "([number uint] start, [number uint] len)" " - " "") );
        }
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""start"")");
        unsigned long start = args[1 -1]->Uint32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""len"")");
        unsigned long len = args[2 -1]->Uint32Value();
        v8::Local<v8::Value> resultVal = EncodeBinary(self->ptr + start, len);
        return scope.Close( resultVal );
    }

    void CleanupMemBlockScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                MemBlockWrap* obj__=jswrap::ObjectWrap::Unwrap<MemBlockWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<MemBlockWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""MemBlock""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""MemBlock""\n";
                }
            }
            else
            {
                MemBlock* obj = dynamic_cast<MemBlock*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""MemBlock"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "MemBlock" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    MemBlock* New_MemBlock(const v8::Arguments& args)
    {
        if (s_MemBlock_InNewFromNative) return 0;
        return new MemBlock(0, 0, false);
    }

    static bool s_ConfigManager_InNewFromNative = false;

    v8::Handle<v8::Value> ConfigManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = new ConfigManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> ConfigManagerWrap::instance_;
    bool ConfigManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> ConfigManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    ConfigManager* ConfigManagerWrap::getSingletonInstance()
    {
        v8::Handle<v8::Object> val =
            GetScriptSingletonInstance()->ToObject();
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(val);
        return dynamic_cast<ConfigManager*>(objWrapper->refPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> ConfigManagerWrap::constructorTpl_;

    void ConfigManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("ConfigManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> UseConfig_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UseConfig_Tpl =
            v8::FunctionTemplate::New(UseConfig, v8::Handle<v8::Value>(), UseConfig_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("useConfig"), UseConfig_Tpl);
        v8::Local<v8::Signature> GetConfigString_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetConfigString_Tpl =
            v8::FunctionTemplate::New(GetConfigString, v8::Handle<v8::Value>(), GetConfigString_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getConfigString"), GetConfigString_Tpl);
        v8::Local<v8::Signature> GetConfigLong_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetConfigLong_Tpl =
            v8::FunctionTemplate::New(GetConfigLong, v8::Handle<v8::Value>(), GetConfigLong_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getConfigLong"), GetConfigLong_Tpl);
        v8::Local<v8::Signature> GetConfigFloat_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetConfigFloat_Tpl =
            v8::FunctionTemplate::New(GetConfigFloat, v8::Handle<v8::Value>(), GetConfigFloat_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getConfigFloat"), GetConfigFloat_Tpl);
        v8::Local<v8::Signature> GetConfigBool_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetConfigBool_Tpl =
            v8::FunctionTemplate::New(GetConfigBool, v8::Handle<v8::Value>(), GetConfigBool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getConfigBool"), GetConfigBool_Tpl);
        v8::Local<v8::Signature> SetConfigString_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetConfigString_Tpl =
            v8::FunctionTemplate::New(SetConfigString, v8::Handle<v8::Value>(), SetConfigString_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setConfigString"), SetConfigString_Tpl);
        v8::Local<v8::Signature> SetConfigLong_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetConfigLong_Tpl =
            v8::FunctionTemplate::New(SetConfigLong, v8::Handle<v8::Value>(), SetConfigLong_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setConfigLong"), SetConfigLong_Tpl);
        v8::Local<v8::Signature> SetConfigFloat_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetConfigFloat_Tpl =
            v8::FunctionTemplate::New(SetConfigFloat, v8::Handle<v8::Value>(), SetConfigFloat_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setConfigFloat"), SetConfigFloat_Tpl);
        v8::Local<v8::Signature> SetConfigBool_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetConfigBool_Tpl =
            v8::FunctionTemplate::New(SetConfigBool, v8::Handle<v8::Value>(), SetConfigBool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setConfigBool"), SetConfigBool_Tpl);
        target->Set(v8::String::NewSymbol("ConfigManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> ConfigManagerWrap::UseConfig(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "(string inConfigName)" " - " "") );
        }
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigName"")");
        v8::String::Utf8Value inConfigName_Str(args[1 -1]->ToString());
        const char* inConfigName = *inConfigName_Str;;
        bool result = self->useConfig(inConfigName);
        return scope.Close( v8::Boolean::New(result) );
    }

    v8::Handle<v8::Value> ConfigManagerWrap::GetConfigString(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "(string inConfigItemName)" " - " "") );
        }
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        std::string outVal;
        bool found = self->getConfigString(inConfigItemName, outVal);
        if (found)
        {
            return scope.Close( v8::String::New(outVal.c_str()) );
        }
        else
        {
            return scope.Close( v8::Undefined() );
        }
    }

    v8::Handle<v8::Value> ConfigManagerWrap::GetConfigLong(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(string inConfigItemName)" " - " "") );
        }
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        long outVal;
        bool found = self->getConfigLong(inConfigItemName, outVal);
        if (found)
        {
            return scope.Close( v8::Integer::New(outVal) );
        }
        else
        {
            return scope.Close( v8::Undefined() );
        }
    }

    v8::Handle<v8::Value> ConfigManagerWrap::GetConfigFloat(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(string inConfigItemName)" " - " "") );
        }
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        float outVal;
        bool found = self->getConfigFloat(inConfigItemName, outVal);
        if (found)
        {
            return scope.Close( v8::Number::New(outVal) );
        }
        else
        {
            return scope.Close( v8::Undefined() );
        }
    }

    v8::Handle<v8::Value> ConfigManagerWrap::GetConfigBool(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "(string inConfigItemName)" " - " "") );
        }
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        bool outVal;
        bool found = self->getConfigBool(inConfigItemName, outVal);
        if (found)
        {
            return scope.Close( v8::Boolean::New(outVal) );
        }
        else
        {
            return scope.Close( v8::Undefined() );
        }
    }

    v8::Handle<v8::Value> ConfigManagerWrap::SetConfigString(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(string inConfigItemName, string inValue)" " - " "") );
        }
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsString())
            return v8_ThrowArgTypeException(2, "a string  (""inValue"")");
        v8::String::Utf8Value inValue_Str(args[2 -1]->ToString());
        const char* inValue = *inValue_Str;;
        std::string theString(inValue);
        self->setConfigString(inConfigItemName, theString);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ConfigManagerWrap::SetConfigLong(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(string inConfigItemName, [number int] inValue)" " - " "") );
        }
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inValue"")");
        long inValue = args[2 -1]->Int32Value();
        self->setConfigLong(inConfigItemName, inValue);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ConfigManagerWrap::SetConfigFloat(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(string inConfigItemName, number inValue)" " - " "") );
        }
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inValue"")");
        double inValue = args[2 -1]->NumberValue();
        self->setConfigFloat(inConfigItemName, inValue);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ConfigManagerWrap::SetConfigBool(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ConfigManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ConfigManagerWrap>(args.This());
        ConfigManager* self = dynamic_cast<ConfigManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(string inConfigItemName, boolean inValue)" " - " "") );
        }
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inConfigItemName"")");
        v8::String::Utf8Value inConfigItemName_Str(args[1 -1]->ToString());
        const char* inConfigItemName = *inConfigItemName_Str;;
        if (!args[2 -1]->IsBoolean())
            return v8_ThrowArgTypeException(2, "a boolean (""inValue"")");
        bool inValue = args[2 -1]->BooleanValue();
        self->setConfigBool(inConfigItemName, inValue);
        return scope.Close( v8::Undefined() );
    }

    ConfigManager* New_ConfigManager(const v8::Arguments& args)
    {
        if (s_ConfigManager_InNewFromNative) return 0;
        return ConfigManager::getSingletonInstance();
    }

    static bool s_LogManager_InNewFromNative = false;

    v8::Handle<v8::Value> LogManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        LogManagerWrap* objWrapper = new LogManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> LogManagerWrap::instance_;
    bool LogManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> LogManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    LogManager* LogManagerWrap::getSingletonInstance()
    {
        v8::Handle<v8::Object> val =
            GetScriptSingletonInstance()->ToObject();
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(val);
        return dynamic_cast<LogManager*>(objWrapper->refPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> LogManagerWrap::constructorTpl_;

    void LogManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("LogManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        t->InstanceTemplate()->Set(v8::String::NewSymbol("init_CreateUniqueNewFile"), v8::Integer::New(pdg::LogManager::init_CreateUniqueNewFile), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewSymbol("init_OverwriteExisting"), v8::Integer::New(pdg::LogManager::init_OverwriteExisting), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewSymbol("init_AppendToExisting"), v8::Integer::New(pdg::LogManager::init_AppendToExisting), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewSymbol("init_StdOut"), v8::Integer::New(pdg::LogManager::init_StdOut), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        t->InstanceTemplate()->Set(v8::String::NewSymbol("init_StdErr"), v8::Integer::New(pdg::LogManager::init_StdErr), static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete));
        v8::Local<v8::Signature> GetLogLevel_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetLogLevel_Tpl =
            v8::FunctionTemplate::New(GetLogLevel, v8::Handle<v8::Value>(), GetLogLevel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""LogLevel"), GetLogLevel_Tpl);
        v8::Local<v8::Signature> SetLogLevel_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetLogLevel_Tpl =
            v8::FunctionTemplate::New(SetLogLevel, v8::Handle<v8::Value>(), SetLogLevel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""LogLevel"), SetLogLevel_Tpl);
        v8::Local<v8::Signature> Initialize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Initialize_Tpl =
            v8::FunctionTemplate::New(Initialize, v8::Handle<v8::Value>(), Initialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("initialize"), Initialize_Tpl);
        v8::Local<v8::Signature> WriteLogEntry_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> WriteLogEntry_Tpl =
            v8::FunctionTemplate::New(WriteLogEntry, v8::Handle<v8::Value>(), WriteLogEntry_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("writeLogEntry"), WriteLogEntry_Tpl);
        v8::Local<v8::Signature> BinaryDump_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BinaryDump_Tpl =
            v8::FunctionTemplate::New(BinaryDump, v8::Handle<v8::Value>(), BinaryDump_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("binaryDump"), BinaryDump_Tpl);
        target->Set(v8::String::NewSymbol("LogManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> LogManagerWrap::GetLogLevel(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int32 theLogLevel = self->getLogLevel();
        return scope.Close( v8::Integer::New(theLogLevel) );
    }

    v8::Handle<v8::Value> LogManagerWrap::SetLogLevel(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("LogManager" " function" "([number int] inLogLevel)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theLogLevel"")");
        long theLogLevel = args[1 -1]->Int32Value();

        self->setLogLevel(theLogLevel);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> LogManagerWrap::Initialize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(string inLogNameBase, [number int] initMode = LogManager.init_StdOut)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inLogNameBase"")");
        v8::String::Utf8Value inLogNameBase_Str(args[1 -1]->ToString());
        const char* inLogNameBase = *inLogNameBase_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""initMode"")");
        long initMode = (args.Length()<2) ? pdg::LogManager::init_StdOut : args[2 -1]->Int32Value();;
        self->initialize(inLogNameBase, initMode);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> LogManagerWrap::WriteLogEntry(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        LogManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<LogManagerWrap>(args.This());
        LogManager* self = dynamic_cast<LogManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] level, string category, string message)" " - " "") );
        };
        if (args.Length() != 3)
            return v8_ThrowArgCountException(args.Length(), 3);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""level"")");
        long level = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsString())
            return v8_ThrowArgTypeException(2, "a string  (""category"")");
        v8::String::Utf8Value category_Str(args[2 -1]->ToString());
        const char* category = *category_Str;;
        if (!args[3 -1]->IsString())
            return v8_ThrowArgTypeException(3, "a string  (""message"")");
        v8::String::Utf8Value message_Str(args[3 -1]->ToString());
        const char* message = *message_Str;;
        self->writeLogEntry(level, category, message);
        return scope.Close( v8::Undefined() );
    }
    v8::Handle<v8::Value> LogManagerWrap::BinaryDump(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "({[string Binary]|[object MemBlock]} inData, [number int] length = 0, [number int] bytesPerLine = 20)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""length"")");
        long length = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""bytesPerLine"")");
        long bytesPerLine = (args.Length()<3) ? 20 : args[3 -1]->Int32Value();;
        int dataSize = 0;
        char* inData = 0;
        if (args[0]->IsString())
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            inData = (char*)ptr;
            dataSize = (length == 0) ? bytes : length;
        }
        else
        {
            REQUIRE_NATIVE_OBJECT_ARG(1, memBlock, MemBlock);
            inData = memBlock->ptr;
            dataSize = (length == 0) ? memBlock->bytes : length;
        }
        int outBufSize = (4 * dataSize) + (6 * dataSize/bytesPerLine) + (4 * bytesPerLine) + 32;
        char* outBuf = new char[outBufSize];
        OS::binaryDump(outBuf, outBufSize, inData, dataSize, bytesPerLine);
        v8::Local<v8::Value> dumpStrVal = v8::String::New(outBuf);
        delete outBuf;
        return scope.Close( dumpStrVal );
    }

    log& main_getDebugLog();

    LogManager* New_LogManager(const v8::Arguments& args)
    {
        if (s_LogManager_InNewFromNative) return 0;
        LogManager *theLogMgr = LogManager::getSingletonInstance();
        pdg::log& debugLog = main_getDebugLog();
        debugLog.setLogManager(theLogMgr);
        return theLogMgr;
    }

    static bool s_IEventHandler_InNewFromNative = false;

    v8::Handle<v8::Value> IEventHandlerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        IEventHandlerWrap* objWrapper = new IEventHandlerWrap(args);
        objWrapper->Wrap(args.This());
        IEventHandler* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mIEventHandlerScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> IEventHandlerWrap::NewFromNative(IEventHandler* nativeObj)
    {
        s_IEventHandler_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        IEventHandlerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj);

        nativeObj->mIEventHandlerScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_IEventHandler_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> IEventHandlerWrap::constructorTpl_;

    void IEventHandlerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("IEventHandler"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        target->Set(v8::String::NewSymbol("IEventHandler"), constructorTpl_->GetFunction());
    }

    void CleanupIEventHandlerScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "IEventHandler" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    static bool s_EventEmitter_InNewFromNative = false;

    v8::Handle<v8::Value> EventEmitterWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventEmitterWrap* objWrapper = new EventEmitterWrap(args);
        objWrapper->Wrap(args.This());
        EventEmitter* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mEventEmitterScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> EventEmitterWrap::NewFromNative(EventEmitter* nativeObj)
    {
        s_EventEmitter_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(obj);

        nativeObj->mEventEmitterScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_EventEmitter_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> EventEmitterWrap::constructorTpl_;

    void EventEmitterWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("EventEmitter"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(AddHandler, v8::Handle<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addHandler"), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(RemoveHandler, v8::Handle<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeHandler"), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(Clear, v8::Handle<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clear"), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(BlockEvent, v8::Handle<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("blockEvent"), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(UnblockEvent, v8::Handle<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unblockEvent"), UnblockEvent_Tpl);
        target->Set(v8::String::NewSymbol("EventEmitter"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> EventEmitterWrap::AddHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventEmitterWrap::RemoveHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                "If the handler is listed multiple times it will only remove it once.\n"
                "NOTE: inType == all_events doesn't work quite like you might expect. If "
                "you have registered a handler for multiple events, but not with all_events, "
                "doing removeHandler(handler, all_events) will do nothing. Basically, "
                "all_events is a special event type that matches all event types when "
                "considering whether to invoke a handler or not.\n"
                "It is safe to call remove handler from within an event handler's handleEvent() call."
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventEmitterWrap::Clear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "remove all handlers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clear();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventEmitterWrap::BlockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                "Events that are blocked are NOT cached for later, they are just dropped."
                " \\param inEventType the type of event to block") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventEmitterWrap::UnblockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventEmitterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventEmitterWrap>(args.This());
        EventEmitter* self = dynamic_cast<EventEmitter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                " \\param inEventType the type of event to unblock") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    EventEmitter* New_EventEmitter(const v8::Arguments& args)
    {
        if (s_EventEmitter_InNewFromNative) return 0;
        return new EventEmitter();
    }

    static bool s_EventManager_InNewFromNative = false;

    v8::Handle<v8::Value> EventManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventManagerWrap* objWrapper = new EventManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> EventManagerWrap::instance_;
    bool EventManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> EventManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    EventManager* EventManagerWrap::getSingletonInstance()
    {
        v8::Handle<v8::Object> val =
            GetScriptSingletonInstance()->ToObject();
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(val);
        return dynamic_cast<EventManager*>(objWrapper->refPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> EventManagerWrap::constructorTpl_;

    void EventManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("EventManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(AddHandler, v8::Handle<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addHandler"), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(RemoveHandler, v8::Handle<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeHandler"), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(Clear, v8::Handle<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clear"), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(BlockEvent, v8::Handle<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("blockEvent"), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(UnblockEvent, v8::Handle<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unblockEvent"), UnblockEvent_Tpl);
        v8::Local<v8::Signature> IsKeyDown_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsKeyDown_Tpl =
            v8::FunctionTemplate::New(IsKeyDown, v8::Handle<v8::Value>(), IsKeyDown_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isKeyDown"), IsKeyDown_Tpl);
        v8::Local<v8::Signature> IsRawKeyDown_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsRawKeyDown_Tpl =
            v8::FunctionTemplate::New(IsRawKeyDown, v8::Handle<v8::Value>(), IsRawKeyDown_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isRawKeyDown"), IsRawKeyDown_Tpl);
        v8::Local<v8::Signature> IsButtonDown_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsButtonDown_Tpl =
            v8::FunctionTemplate::New(IsButtonDown, v8::Handle<v8::Value>(), IsButtonDown_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isButtonDown"), IsButtonDown_Tpl);
        v8::Local<v8::Signature> GetDeviceOrientation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetDeviceOrientation_Tpl =
            v8::FunctionTemplate::New(GetDeviceOrientation, v8::Handle<v8::Value>(), GetDeviceOrientation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getDeviceOrientation"), GetDeviceOrientation_Tpl);
        target->Set(v8::String::NewSymbol("EventManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> EventManagerWrap::AddHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventManagerWrap::RemoveHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                "If the handler is listed multiple times it will only remove it once.\n"
                "NOTE: inType == all_events doesn't work quite like you might expect. If "
                "you have registered a handler for multiple events, but not with all_events, "
                "doing removeHandler(handler, all_events) will do nothing. Basically, "
                "all_events is a special event type that matches all event types when "
                "considering whether to invoke a handler or not.\n"
                "It is safe to call remove handler from within an event handler's handleEvent() call."
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventManagerWrap::Clear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "remove all handlers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clear();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventManagerWrap::BlockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                "Events that are blocked are NOT cached for later, they are just dropped."
                " \\param inEventType the type of event to block") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> EventManagerWrap::UnblockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        EventManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<EventManagerWrap>(args.This());
        EventManager* self = dynamic_cast<EventManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                " \\param inEventType the type of event to unblock") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }
    v8::Handle<v8::Value> EventManagerWrap::IsRawKeyDown(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([number int] keyCode)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""keyCode"")");
        long keyCode = args[1 -1]->Int32Value();
        return scope.Close( v8::Boolean::New(OS::isRawKeyDown(keyCode)) );
    }
    v8::Handle<v8::Value> EventManagerWrap::IsButtonDown(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([number int] buttonNumber = 0)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""buttonNumber"")");
        long buttonNumber = (args.Length()<1) ? 0 : args[1 -1]->Int32Value();;
        return scope.Close( v8::Boolean::New(OS::isButtonDown(buttonNumber)) );
    }

    EventManager* New_EventManager(const v8::Arguments& args)
    {
        if (s_EventManager_InNewFromNative) return 0;
        return EventManager::getSingletonInstance();
    }

    static bool s_ResourceManager_InNewFromNative = false;

    v8::Handle<v8::Value> ResourceManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = new ResourceManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> ResourceManagerWrap::instance_;
    bool ResourceManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> ResourceManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    ResourceManager* ResourceManagerWrap::getSingletonInstance()
    {
        v8::Handle<v8::Object> val =
            GetScriptSingletonInstance()->ToObject();
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(val);
        return dynamic_cast<ResourceManager*>(objWrapper->refPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> ResourceManagerWrap::constructorTpl_;

    void ResourceManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("ResourceManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetLanguage_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetLanguage_Tpl =
            v8::FunctionTemplate::New(GetLanguage, v8::Handle<v8::Value>(), GetLanguage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Language"), GetLanguage_Tpl);
        v8::Local<v8::Signature> SetLanguage_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetLanguage_Tpl =
            v8::FunctionTemplate::New(SetLanguage, v8::Handle<v8::Value>(), SetLanguage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Language"), SetLanguage_Tpl);
        v8::Local<v8::Signature> OpenResourceFile_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> OpenResourceFile_Tpl =
            v8::FunctionTemplate::New(OpenResourceFile, v8::Handle<v8::Value>(), OpenResourceFile_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("openResourceFile"), OpenResourceFile_Tpl);
        v8::Local<v8::Signature> CloseResourceFile_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CloseResourceFile_Tpl =
            v8::FunctionTemplate::New(CloseResourceFile, v8::Handle<v8::Value>(), CloseResourceFile_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("closeResourceFile"), CloseResourceFile_Tpl);
        v8::Local<v8::Signature> GetImage_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetImage_Tpl =
            v8::FunctionTemplate::New(GetImage, v8::Handle<v8::Value>(), GetImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getImage"), GetImage_Tpl);
        v8::Local<v8::Signature> GetImageStrip_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetImageStrip_Tpl =
            v8::FunctionTemplate::New(GetImageStrip, v8::Handle<v8::Value>(), GetImageStrip_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getImageStrip"), GetImageStrip_Tpl);
        v8::Local<v8::Signature> GetString_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetString_Tpl =
            v8::FunctionTemplate::New(GetString, v8::Handle<v8::Value>(), GetString_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getString"), GetString_Tpl);
        v8::Local<v8::Signature> GetResourceSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetResourceSize_Tpl =
            v8::FunctionTemplate::New(GetResourceSize, v8::Handle<v8::Value>(), GetResourceSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getResourceSize"), GetResourceSize_Tpl);
        v8::Local<v8::Signature> GetResource_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetResource_Tpl =
            v8::FunctionTemplate::New(GetResource, v8::Handle<v8::Value>(), GetResource_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getResource"), GetResource_Tpl);
        v8::Local<v8::Signature> GetResourcePaths_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetResourcePaths_Tpl =
            v8::FunctionTemplate::New(GetResourcePaths, v8::Handle<v8::Value>(), GetResourcePaths_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getResourcePaths"), GetResourcePaths_Tpl);
        target->Set(v8::String::NewSymbol("ResourceManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> ResourceManagerWrap::GetLanguage(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        const char* theLanguage = self->getLanguage();
        return scope.Close( v8::String::New(theLanguage) );
    }

    v8::Handle<v8::Value> ResourceManagerWrap::SetLanguage(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("ResourceManager" " function" "(string inLanguage)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""theLanguage"")");
        v8::String::Utf8Value theLanguage_Str(args[1 -1]->ToString());
        const char* theLanguage = *theLanguage_Str;;

        self->setLanguage(theLanguage);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> ResourceManagerWrap::OpenResourceFile(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(string filename)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""filename"")");
        v8::String::Utf8Value filename_Str(args[1 -1]->ToString());
        const char* filename = *filename_Str;;
        int refNum = self->openResourceFile(filename);
        return scope.Close( v8::Integer::New(refNum) );
    }

    v8::Handle<v8::Value> ResourceManagerWrap::CloseResourceFile(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] refNum)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""refNum"")");
        long refNum = args[1 -1]->Int32Value();
        self->closeResourceFile(refNum);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ResourceManagerWrap::GetString(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "([number int] id, [number int] substring = -1)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""substring"")");
        long substring = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        std::string ioStr;
        const char* outStr = self->getString(ioStr, id, substring);
        return scope.Close( v8::String::New(outStr) );
    }

    v8::Handle<v8::Value> ResourceManagerWrap::GetResourceSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(string resourceName)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""resourceName"")");
        v8::String::Utf8Value resourceName_Str(args[1 -1]->ToString());
        const char* resourceName = *resourceName_Str;;
        unsigned long resSize = self->getResourceSize(resourceName);
        return scope.Close( v8::Integer::NewFromUnsigned(resSize) );
    }

    v8::Handle<v8::Value> ResourceManagerWrap::GetResource(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[string Binary]" " function" "(string resourceName)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""resourceName"")");
        v8::String::Utf8Value resourceName_Str(args[1 -1]->ToString());
        const char* resourceName = *resourceName_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""maxSize"")");
        long maxSize = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        unsigned long bufferSize;
        if (maxSize < 0)
        {
            bufferSize = self->getResourceSize(resourceName);
        }
        else
        {
            bufferSize = maxSize;
        }
        uint8* buffer = (uint8*) std::malloc(bufferSize);
        bool loaded = self->getResource(resourceName, buffer, bufferSize);
        if (!loaded)
        {
            std::free(buffer);
            return scope.Close( v8::Boolean::New(false) );
        }
        v8::Local<v8::Value> resultVal = EncodeBinary(buffer, bufferSize);
        std::free(buffer);
        return scope.Close( resultVal );
    }

    v8::Handle<v8::Value> ResourceManagerWrap::GetResourcePaths(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ResourceManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ResourceManagerWrap>(args.This());
        ResourceManager* self = dynamic_cast<ResourceManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        std::string outStr = self->getResourcePaths();
        return scope.Close( v8::String::New(outStr.c_str()) );
    }

    ResourceManager* New_ResourceManager(const v8::Arguments& args)
    {
        if (s_ResourceManager_InNewFromNative) return 0;
        return ResourceManager::getSingletonInstance();
    }

    static bool s_ISerializable_InNewFromNative = false;

    v8::Handle<v8::Value> ISerializableWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ISerializableWrap* objWrapper = new ISerializableWrap(args);
        objWrapper->Wrap(args.This());
        ISerializable* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mISerializableScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> ISerializableWrap::NewFromNative(ISerializable* nativeObj)
    {
        s_ISerializable_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        ISerializableWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ISerializableWrap>(obj);

        nativeObj->mISerializableScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_ISerializable_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> ISerializableWrap::constructorTpl_;

    void ISerializableWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("ISerializable"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        target->Set(v8::String::NewSymbol("ISerializable"), constructorTpl_->GetFunction());
    }

    void CleanupISerializableScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISerializableWrap* obj__=jswrap::ObjectWrap::Unwrap<ISerializableWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ISerializableWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""ISerializable""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""ISerializable""\n";
                }
            }
            else
            {
                ISerializable* obj = dynamic_cast<ISerializable*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""ISerializable"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "ISerializable" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    static bool s_Serializer_InNewFromNative = false;

    v8::Handle<v8::Value> SerializerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = new SerializerWrap(args);
        objWrapper->Wrap(args.This());
        Serializer* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mSerializerScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> SerializerWrap::NewFromNative(Serializer* nativeObj)
    {
        s_Serializer_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(obj);

        nativeObj->mSerializerScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Serializer_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> SerializerWrap::constructorTpl_;

    void SerializerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Serializer"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
#ifndef PDG_NO_64BIT
        v8::Local<v8::Signature> Serialize_8_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_8_Tpl =
            v8::FunctionTemplate::New(Serialize_8, v8::Handle<v8::Value>(), Serialize_8_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_8"), Serialize_8_Tpl);
        v8::Local<v8::Signature> Serialize_8u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_8u_Tpl =
            v8::FunctionTemplate::New(Serialize_8u, v8::Handle<v8::Value>(), Serialize_8u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_8u"), Serialize_8u_Tpl);
#endif
        v8::Local<v8::Signature> Serialize_d_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_d_Tpl =
            v8::FunctionTemplate::New(Serialize_d, v8::Handle<v8::Value>(), Serialize_d_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_d"), Serialize_d_Tpl);
        v8::Local<v8::Signature> Serialize_f_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_f_Tpl =
            v8::FunctionTemplate::New(Serialize_f, v8::Handle<v8::Value>(), Serialize_f_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_f"), Serialize_f_Tpl);
        v8::Local<v8::Signature> Serialize_4_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_4_Tpl =
            v8::FunctionTemplate::New(Serialize_4, v8::Handle<v8::Value>(), Serialize_4_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_4"), Serialize_4_Tpl);
        v8::Local<v8::Signature> Serialize_4u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_4u_Tpl =
            v8::FunctionTemplate::New(Serialize_4u, v8::Handle<v8::Value>(), Serialize_4u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_4u"), Serialize_4u_Tpl);
        v8::Local<v8::Signature> Serialize_3u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_3u_Tpl =
            v8::FunctionTemplate::New(Serialize_3u, v8::Handle<v8::Value>(), Serialize_3u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_3u"), Serialize_3u_Tpl);
        v8::Local<v8::Signature> Serialize_2_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_2_Tpl =
            v8::FunctionTemplate::New(Serialize_2, v8::Handle<v8::Value>(), Serialize_2_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_2"), Serialize_2_Tpl);
        v8::Local<v8::Signature> Serialize_2u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_2u_Tpl =
            v8::FunctionTemplate::New(Serialize_2u, v8::Handle<v8::Value>(), Serialize_2u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_2u"), Serialize_2u_Tpl);
        v8::Local<v8::Signature> Serialize_1_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_1_Tpl =
            v8::FunctionTemplate::New(Serialize_1, v8::Handle<v8::Value>(), Serialize_1_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_1"), Serialize_1_Tpl);
        v8::Local<v8::Signature> Serialize_1u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_1u_Tpl =
            v8::FunctionTemplate::New(Serialize_1u, v8::Handle<v8::Value>(), Serialize_1u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_1u"), Serialize_1u_Tpl);
        v8::Local<v8::Signature> Serialize_bool_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_bool_Tpl =
            v8::FunctionTemplate::New(Serialize_bool, v8::Handle<v8::Value>(), Serialize_bool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_bool"), Serialize_bool_Tpl);
        v8::Local<v8::Signature> Serialize_uint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_uint_Tpl =
            v8::FunctionTemplate::New(Serialize_uint, v8::Handle<v8::Value>(), Serialize_uint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_uint"), Serialize_uint_Tpl);
        v8::Local<v8::Signature> Serialize_color_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_color_Tpl =
            v8::FunctionTemplate::New(Serialize_color, v8::Handle<v8::Value>(), Serialize_color_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_color"), Serialize_color_Tpl);
        v8::Local<v8::Signature> Serialize_offset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_offset_Tpl =
            v8::FunctionTemplate::New(Serialize_offset, v8::Handle<v8::Value>(), Serialize_offset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_offset"), Serialize_offset_Tpl);
        v8::Local<v8::Signature> Serialize_point_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_point_Tpl =
            v8::FunctionTemplate::New(Serialize_point, v8::Handle<v8::Value>(), Serialize_point_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_point"), Serialize_point_Tpl);
        v8::Local<v8::Signature> Serialize_vector_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_vector_Tpl =
            v8::FunctionTemplate::New(Serialize_vector, v8::Handle<v8::Value>(), Serialize_vector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_vector"), Serialize_vector_Tpl);
        v8::Local<v8::Signature> Serialize_rect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_rect_Tpl =
            v8::FunctionTemplate::New(Serialize_rect, v8::Handle<v8::Value>(), Serialize_rect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_rect"), Serialize_rect_Tpl);
        v8::Local<v8::Signature> Serialize_rotr_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_rotr_Tpl =
            v8::FunctionTemplate::New(Serialize_rotr, v8::Handle<v8::Value>(), Serialize_rotr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_rotr"), Serialize_rotr_Tpl);
        v8::Local<v8::Signature> Serialize_quad_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_quad_Tpl =
            v8::FunctionTemplate::New(Serialize_quad, v8::Handle<v8::Value>(), Serialize_quad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_quad"), Serialize_quad_Tpl);
        v8::Local<v8::Signature> Serialize_str_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_str_Tpl =
            v8::FunctionTemplate::New(Serialize_str, v8::Handle<v8::Value>(), Serialize_str_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_str"), Serialize_str_Tpl);
        v8::Local<v8::Signature> Serialize_mem_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_mem_Tpl =
            v8::FunctionTemplate::New(Serialize_mem, v8::Handle<v8::Value>(), Serialize_mem_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_mem"), Serialize_mem_Tpl);
        v8::Local<v8::Signature> Serialize_obj_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_obj_Tpl =
            v8::FunctionTemplate::New(Serialize_obj, v8::Handle<v8::Value>(), Serialize_obj_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize_obj"), Serialize_obj_Tpl);
        v8::Local<v8::Signature> SerializedSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SerializedSize_Tpl =
            v8::FunctionTemplate::New(SerializedSize, v8::Handle<v8::Value>(), SerializedSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serializedSize"), SerializedSize_Tpl);
        v8::Local<v8::Signature> GetDataSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetDataSize_Tpl =
            v8::FunctionTemplate::New(GetDataSize, v8::Handle<v8::Value>(), GetDataSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getDataSize"), GetDataSize_Tpl);
        v8::Local<v8::Signature> GetDataPtr_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetDataPtr_Tpl =
            v8::FunctionTemplate::New(GetDataPtr, v8::Handle<v8::Value>(), GetDataPtr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getDataPtr"), GetDataPtr_Tpl);
        target->Set(v8::String::NewSymbol("Serializer"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_d(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_d(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_f(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_f(val);
        return scope.Close( v8::Undefined() );
    }
#ifndef PDG_NO_64BIT

    v8::Handle<v8::Value> SerializerWrap::Serialize_8(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_8(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_8u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        double val = args[1 -1]->NumberValue();
        self->serialize_8u(val);
        return scope.Close( v8::Undefined() );
    }
#endif

    v8::Handle<v8::Value> SerializerWrap::Serialize_4(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        self->serialize_4(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_4u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_4u(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_3u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_3u(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_2(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        self->serialize_2(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_2u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_2u(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_1(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        long val = args[1 -1]->Int32Value();
        self->serialize_1(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_1u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_1u(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_bool(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""val"")");
        bool val = args[1 -1]->BooleanValue();
        self->serialize_bool(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_uint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""val"")");
        unsigned long val = args[1 -1]->Uint32Value();
        self->serialize_uint(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_color(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Color] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsColor(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Color", *args[1 -1]);
        pdg::Color val = v8_ValueToColor(args[1 -1]);
        self->serialize_color(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_offset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset val = v8_ValueToOffset(args[1 -1]);
        self->serialize_offset(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_point(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point val = v8_ValueToPoint(args[1 -1]);
        self->serialize_point(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_vector(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Vector] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector val = v8_ValueToVector(args[1 -1]);
        self->serialize_vector(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_rect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Rect] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Rect", *args[1 -1]);
        pdg::Rect r = v8_ValueToRect(args[1 -1]);
        self->serialize_rect(r);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_rotr(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object RotatedRect] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsRotatedRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect val = v8_ValueToRotatedRect(args[1 -1]);
        self->serialize_rotr(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_quad(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Quad] val)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad val = v8_ValueToQuad(args[1 -1]);
        self->serialize_quad(val);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_str(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(string str)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""str"")");
        v8::String::Utf8Value str_Str(args[1 -1]->ToString());
        const char* str = *str_Str;;
        self->serialize_str(str);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::Serialize_mem(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[string Binary]|[object MemBlock]} mem)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        bool isStr = args[0]->IsString();
        if (!isStr && !args[0]->IsObject())
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (mem) must be either a binary string or an object of type MemBlock";
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str())));
        }
        if (isStr)
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            self->serialize_mem(ptr, bytes);
        }
        else
        {
            REQUIRE_NATIVE_OBJECT_ARG(1, memBlock, MemBlock);
            self->serialize_mem(memBlock->ptr, memBlock->bytes);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SerializerWrap::GetDataSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        uint32 dataSize = self->getDataSize();
        return scope.Close( v8::Integer::NewFromUnsigned(dataSize) );
    }

    v8::Handle<v8::Value> SerializerWrap::GetDataPtr(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SerializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SerializerWrap>(args.This());
        Serializer* self = dynamic_cast<Serializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object MemBlock]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        MemBlock* memBlock = new MemBlock((char*)self->getDataPtr(), self->getDataSize(), false);
        if (!memBlock) return scope.Close( v8::Null() );
        if (memBlock->mMemBlockScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = MemBlockWrap::NewFromNative(memBlock);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( memBlock->mMemBlockScriptObj );
        };
    }

    void CleanupSerializerScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                SerializerWrap* obj__=jswrap::ObjectWrap::Unwrap<SerializerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<SerializerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Serializer""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Serializer""\n";
                }
            }
            else
            {
                Serializer* obj = dynamic_cast<Serializer*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Serializer"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Serializer" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    Serializer* New_Serializer(const v8::Arguments& args)
    {
        if (s_Serializer_InNewFromNative) return 0;
        return new Serializer();
    }

    static bool s_Deserializer_InNewFromNative = false;

    v8::Handle<v8::Value> DeserializerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = new DeserializerWrap(args);
        objWrapper->Wrap(args.This());
        Deserializer* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mDeserializerScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> DeserializerWrap::NewFromNative(Deserializer* nativeObj)
    {
        s_Deserializer_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(obj);

        nativeObj->mDeserializerScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Deserializer_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> DeserializerWrap::constructorTpl_;

    void DeserializerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Deserializer"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
#ifndef PDG_NO_64BIT
        v8::Local<v8::Signature> Deserialize_8_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_8_Tpl =
            v8::FunctionTemplate::New(Deserialize_8, v8::Handle<v8::Value>(), Deserialize_8_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_8"), Deserialize_8_Tpl);
        v8::Local<v8::Signature> Deserialize_8u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_8u_Tpl =
            v8::FunctionTemplate::New(Deserialize_8u, v8::Handle<v8::Value>(), Deserialize_8u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_8u"), Deserialize_8u_Tpl);
#endif
        v8::Local<v8::Signature> Deserialize_d_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_d_Tpl =
            v8::FunctionTemplate::New(Deserialize_d, v8::Handle<v8::Value>(), Deserialize_d_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_d"), Deserialize_d_Tpl);
        v8::Local<v8::Signature> Deserialize_f_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_f_Tpl =
            v8::FunctionTemplate::New(Deserialize_f, v8::Handle<v8::Value>(), Deserialize_f_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_f"), Deserialize_f_Tpl);
        v8::Local<v8::Signature> Deserialize_4_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_4_Tpl =
            v8::FunctionTemplate::New(Deserialize_4, v8::Handle<v8::Value>(), Deserialize_4_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_4"), Deserialize_4_Tpl);
        v8::Local<v8::Signature> Deserialize_4u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_4u_Tpl =
            v8::FunctionTemplate::New(Deserialize_4u, v8::Handle<v8::Value>(), Deserialize_4u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_4u"), Deserialize_4u_Tpl);
        v8::Local<v8::Signature> Deserialize_3u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_3u_Tpl =
            v8::FunctionTemplate::New(Deserialize_3u, v8::Handle<v8::Value>(), Deserialize_3u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_3u"), Deserialize_3u_Tpl);
        v8::Local<v8::Signature> Deserialize_2_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_2_Tpl =
            v8::FunctionTemplate::New(Deserialize_2, v8::Handle<v8::Value>(), Deserialize_2_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_2"), Deserialize_2_Tpl);
        v8::Local<v8::Signature> Deserialize_2u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_2u_Tpl =
            v8::FunctionTemplate::New(Deserialize_2u, v8::Handle<v8::Value>(), Deserialize_2u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_2u"), Deserialize_2u_Tpl);
        v8::Local<v8::Signature> Deserialize_1_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_1_Tpl =
            v8::FunctionTemplate::New(Deserialize_1, v8::Handle<v8::Value>(), Deserialize_1_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_1"), Deserialize_1_Tpl);
        v8::Local<v8::Signature> Deserialize_1u_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_1u_Tpl =
            v8::FunctionTemplate::New(Deserialize_1u, v8::Handle<v8::Value>(), Deserialize_1u_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_1u"), Deserialize_1u_Tpl);
        v8::Local<v8::Signature> Deserialize_bool_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_bool_Tpl =
            v8::FunctionTemplate::New(Deserialize_bool, v8::Handle<v8::Value>(), Deserialize_bool_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_bool"), Deserialize_bool_Tpl);
        v8::Local<v8::Signature> Deserialize_uint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_uint_Tpl =
            v8::FunctionTemplate::New(Deserialize_uint, v8::Handle<v8::Value>(), Deserialize_uint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_uint"), Deserialize_uint_Tpl);
        v8::Local<v8::Signature> Deserialize_color_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_color_Tpl =
            v8::FunctionTemplate::New(Deserialize_color, v8::Handle<v8::Value>(), Deserialize_color_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_color"), Deserialize_color_Tpl);
        v8::Local<v8::Signature> Deserialize_offset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_offset_Tpl =
            v8::FunctionTemplate::New(Deserialize_offset, v8::Handle<v8::Value>(), Deserialize_offset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_offset"), Deserialize_offset_Tpl);
        v8::Local<v8::Signature> Deserialize_point_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_point_Tpl =
            v8::FunctionTemplate::New(Deserialize_point, v8::Handle<v8::Value>(), Deserialize_point_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_point"), Deserialize_point_Tpl);
        v8::Local<v8::Signature> Deserialize_vector_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_vector_Tpl =
            v8::FunctionTemplate::New(Deserialize_vector, v8::Handle<v8::Value>(), Deserialize_vector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_vector"), Deserialize_vector_Tpl);
        v8::Local<v8::Signature> Deserialize_rect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_rect_Tpl =
            v8::FunctionTemplate::New(Deserialize_rect, v8::Handle<v8::Value>(), Deserialize_rect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_rect"), Deserialize_rect_Tpl);
        v8::Local<v8::Signature> Deserialize_rotr_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_rotr_Tpl =
            v8::FunctionTemplate::New(Deserialize_rotr, v8::Handle<v8::Value>(), Deserialize_rotr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_rotr"), Deserialize_rotr_Tpl);
        v8::Local<v8::Signature> Deserialize_quad_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_quad_Tpl =
            v8::FunctionTemplate::New(Deserialize_quad, v8::Handle<v8::Value>(), Deserialize_quad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_quad"), Deserialize_quad_Tpl);
        v8::Local<v8::Signature> Deserialize_str_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_str_Tpl =
            v8::FunctionTemplate::New(Deserialize_str, v8::Handle<v8::Value>(), Deserialize_str_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_str"), Deserialize_str_Tpl);
        v8::Local<v8::Signature> Deserialize_mem_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_mem_Tpl =
            v8::FunctionTemplate::New(Deserialize_mem, v8::Handle<v8::Value>(), Deserialize_mem_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_mem"), Deserialize_mem_Tpl);
        v8::Local<v8::Signature> Deserialize_memGetLen_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_memGetLen_Tpl =
            v8::FunctionTemplate::New(Deserialize_memGetLen, v8::Handle<v8::Value>(), Deserialize_memGetLen_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_memGetLen"), Deserialize_memGetLen_Tpl);
        v8::Local<v8::Signature> Deserialize_obj_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_obj_Tpl =
            v8::FunctionTemplate::New(Deserialize_obj, v8::Handle<v8::Value>(), Deserialize_obj_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize_obj"), Deserialize_obj_Tpl);
        v8::Local<v8::Signature> SetDataPtr_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetDataPtr_Tpl =
            v8::FunctionTemplate::New(SetDataPtr, v8::Handle<v8::Value>(), SetDataPtr_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setDataPtr"), SetDataPtr_Tpl);
        target->Set(v8::String::NewSymbol("Deserializer"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_d(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            double val = self->deserialize_d();
            return scope.Close( v8::Number::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_f(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            float val = self->deserialize_f();
            return scope.Close( v8::Number::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }
#ifndef PDG_NO_64BIT

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_8(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            int64 val = self->deserialize_8();
            return scope.Close( v8::Number::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_8u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint64 val = self->deserialize_8u();
            return scope.Close( v8::Number::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }
#endif

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_4(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            int32 val = self->deserialize_4();
            return scope.Close( v8::Integer::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_4u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint32 val = self->deserialize_4u();
            return scope.Close( v8::Integer::NewFromUnsigned(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_3u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint32 val = self->deserialize_3u();
            return scope.Close( v8::Integer::NewFromUnsigned(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_2(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            int16 val = self->deserialize_2();
            return scope.Close( v8::Integer::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_2u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint16 val = self->deserialize_2u();
            return scope.Close( v8::Integer::NewFromUnsigned(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_1(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            int8 val = self->deserialize_1();
            return scope.Close( v8::Integer::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_1u(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint8 val = self->deserialize_1u();
            return scope.Close( v8::Integer::NewFromUnsigned(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_bool(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            bool val = self->deserialize_bool();
            return scope.Close( v8::Boolean::New(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_uint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint32 val = self->deserialize_uint();
            return scope.Close( v8::Integer::NewFromUnsigned(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_color(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Color]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            Color val = self->deserialize_color();
            return scope.Close( v8_MakeJavascriptColor(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_offset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            Offset val = self->deserialize_offset();
            return scope.Close( v8_MakeJavascriptOffset(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_point(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            Point val = self->deserialize_point();
            return scope.Close( v8_MakeJavascriptPoint(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_vector(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            Vector val = self->deserialize_vector();
            return scope.Close( v8_MakeJavascriptVector(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_rect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            Rect val = self->deserialize_rect();
            return scope.Close( v8_MakeJavascriptRect(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_rotr(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object RotatedRect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            RotatedRect val = self->deserialize_rotr();
            return scope.Close( v8_MakeJavascriptRect(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_quad(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Quad]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            Quad val = self->deserialize_quad();
            return scope.Close( v8_MakeJavascriptQuad(val) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_str(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            std::string mystr;
            self->deserialize_string(mystr);
            return scope.Close( v8::String::New(mystr.c_str()) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_strGetLen(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint32 len = self->deserialize_strGetLen();
            return scope.Close( v8::Integer::NewFromUnsigned(len) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_mem(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object MemBlock]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        size_t len, len2;
        try
        {
            len = self->deserialize_memGetLen();
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        char* mem = (char*) std::malloc(len);
        try
        {
            len2 = self->deserialize_mem(mem, len);
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        if (len2 != len)
        {
            std::ostringstream excpt_;
            excpt_ << "Deserializer internal error, deserialized memory length mismatch " << len << " (" << (void*)len << ") != " << len2 << " (" << (void*)len2 << ")";
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));

        }

        MemBlock* memBlock = new MemBlock(mem, len, true);
        if (!memBlock) return scope.Close( v8::Null() );
        if (memBlock->mMemBlockScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = MemBlockWrap::NewFromNative(memBlock);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( memBlock->mMemBlockScriptObj );
        };
    }

    v8::Handle<v8::Value> DeserializerWrap::Deserialize_memGetLen(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        try
        {
            uint32 len = self->deserialize_memGetLen();
            return scope.Close( v8::Integer::NewFromUnsigned(len) );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> DeserializerWrap::SetDataPtr(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        DeserializerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(args.This());
        Deserializer* self = dynamic_cast<Deserializer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[string Binary]|[object MemBlock]} data)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[0]->IsString() && !args[0]->IsObject())
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (mem) must be either a binary string or an object of type MemBlock";
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str())));
        }
        if (args[0]->IsString())
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            self->setDataPtr(ptr, bytes);
        }
        else
        {
            REQUIRE_NATIVE_OBJECT_ARG(1, memBlock, MemBlock);
            self->setDataPtr(memBlock->ptr, memBlock->bytes);
        }
        return scope.Close( v8::Undefined() );
    }

    void CleanupDeserializerScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                DeserializerWrap* obj__=jswrap::ObjectWrap::Unwrap<DeserializerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<DeserializerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Deserializer""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Deserializer""\n";
                }
            }
            else
            {
                Deserializer* obj = dynamic_cast<Deserializer*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Deserializer"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Deserializer" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    Deserializer* New_Deserializer(const v8::Arguments& args)
    {
        if (s_Deserializer_InNewFromNative) return 0;
        return new Deserializer();
    }

    static bool s_Image_InNewFromNative = false;

    v8::Handle<v8::Value> ImageWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = new ImageWrap(args);
        objWrapper->Wrap(args.This());
        Image* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mImageScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> ImageWrap::NewFromNative(Image* nativeObj)
    {
        s_Image_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(obj);

        nativeObj->mImageScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Image_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> ImageWrap::constructorTpl_;

    void ImageWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Image"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(GetWidth, v8::Handle<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Width"), GetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(GetHeight, v8::Handle<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Height"), GetHeight_Tpl);
        v8::Local<v8::Signature> GetImageBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetImageBounds_Tpl =
            v8::FunctionTemplate::New(GetImageBounds, v8::Handle<v8::Value>(), GetImageBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""ImageBounds"), GetImageBounds_Tpl);
        v8::Local<v8::Signature> GetSubsection_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSubsection_Tpl =
            v8::FunctionTemplate::New(GetSubsection, v8::Handle<v8::Value>(), GetSubsection_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Subsection"), GetSubsection_Tpl);
        v8::Local<v8::Signature> SetTransparentColor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetTransparentColor_Tpl =
            v8::FunctionTemplate::New(SetTransparentColor, v8::Handle<v8::Value>(), SetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""TransparentColor"), SetTransparentColor_Tpl);
        v8::Local<v8::Signature> GetOpacity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetOpacity_Tpl =
            v8::FunctionTemplate::New(GetOpacity, v8::Handle<v8::Value>(), GetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Opacity"), GetOpacity_Tpl);
        v8::Local<v8::Signature> SetOpacity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetOpacity_Tpl =
            v8::FunctionTemplate::New(SetOpacity, v8::Handle<v8::Value>(), SetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Opacity"), SetOpacity_Tpl);
        v8::Local<v8::Signature> SetEdgeClamping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetEdgeClamping_Tpl =
            v8::FunctionTemplate::New(SetEdgeClamping, v8::Handle<v8::Value>(), SetEdgeClamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""EdgeClamping"), SetEdgeClamping_Tpl);
        v8::Local<v8::Signature> GetTransparentColor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTransparentColor_Tpl =
            v8::FunctionTemplate::New(GetTransparentColor, v8::Handle<v8::Value>(), GetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getTransparentColor"), GetTransparentColor_Tpl);
        v8::Local<v8::Signature> RetainData_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RetainData_Tpl =
            v8::FunctionTemplate::New(RetainData, v8::Handle<v8::Value>(), RetainData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("retainData"), RetainData_Tpl);
        v8::Local<v8::Signature> RetainAlpha_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RetainAlpha_Tpl =
            v8::FunctionTemplate::New(RetainAlpha, v8::Handle<v8::Value>(), RetainAlpha_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("retainAlpha"), RetainAlpha_Tpl);
        v8::Local<v8::Signature> PrepareToRasterize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PrepareToRasterize_Tpl =
            v8::FunctionTemplate::New(PrepareToRasterize, v8::Handle<v8::Value>(), PrepareToRasterize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("prepareToRasterize"), PrepareToRasterize_Tpl);
        v8::Local<v8::Signature> GetAlphaValue_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetAlphaValue_Tpl =
            v8::FunctionTemplate::New(GetAlphaValue, v8::Handle<v8::Value>(), GetAlphaValue_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""AlphaValue"), GetAlphaValue_Tpl);
        v8::Local<v8::Signature> GetPixel_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetPixel_Tpl =
            v8::FunctionTemplate::New(GetPixel, v8::Handle<v8::Value>(), GetPixel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getPixel"), GetPixel_Tpl);
        target->Set(v8::String::NewSymbol("Image"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> ImageWrap::GetTransparentColor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("object" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Color theTransparentColor = self->getTransparentColor();
        return scope.Close( v8_MakeJavascriptColor(theTransparentColor) );
    }

    v8::Handle<v8::Value> ImageWrap::SetTransparentColor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Image" " function" "(object inTransparentColor)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsColor(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Color", *args[1 -1]);
        pdg::Color theTransparentColor = v8_ValueToColor(args[1 -1]);

        self->setTransparentColor(theTransparentColor);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> ImageWrap::GetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int theWidth = self->getWidth();
        return scope.Close( v8::Integer::New(theWidth) );
    }

    v8::Handle<v8::Value> ImageWrap::GetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int theHeight = self->getHeight();
        return scope.Close( v8::Integer::New(theHeight) );
    }

    v8::Handle<v8::Value> ImageWrap::GetImageBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR [object Rect]" " function" "([object Point] at)" " - " "get image boundary rect, optionally with top left at given point") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point at = (args.Length()<1) ? pdg::Point(0,0) : v8_ValueToPoint(args[1 -1]);
        Rect r = self->getImageBounds(at);
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> ImageWrap::GetSubsection(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR [object Image]" " function" "({[object Quad]|[object Rect]} quad)" " - " "get image that is an arbitrary subsection of this image") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(args[1 -1]);
        Image* image = self->getSubsection(quad);
        if (!image) return scope.Close( v8::Null() );
        if (image->mImageScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = ImageWrap::NewFromNative(image);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( image->mImageScriptObj );
        };
    }

    v8::Handle<v8::Value> ImageWrap::GetOpacity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR number" " function" "()" " - " "get opacity of this image: 0.0 - completely transparent to 1.0 - completely solid") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        uint8 opacity = self->getOpacity();
        double opacityFloat = (float)opacity / 255.0f;
        return scope.Close( v8::Number::New(opacityFloat) );
    }

    v8::Handle<v8::Value> ImageWrap::SetOpacity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "(number opacity)" " - " "set opacity of this image as range from either (0-255) or (0.0 to 1.0)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""opacity"")");
        unsigned long opacity = (args.Length()<1) ? 0xffffffff : args[1 -1]->Uint32Value();;
        if (opacity == 0xffffffff)
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""opacityFloat"")");
            double opacityFloat = args[1 -1]->NumberValue();
            opacity = std::floor(255.0f * opacityFloat);
        }
        if (opacity > 255) opacity = 255;
        self->setOpacity(opacity);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageWrap::SetEdgeClamping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "(boolean inUseEdgeClamp)" " - " "set whether image uses edge clamping or not") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""inUseEdgeClamp"")");
        bool inUseEdgeClamp = args[1 -1]->BooleanValue();
        self->setEdgeClamping(inUseEdgeClamp);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageWrap::RetainData(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "()" " - " "retain pixel data for use by Image.getPixel()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->retainData();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageWrap::RetainAlpha(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "()" " - " "retain alpha data for use by Image.getAlphaValue() or per-pixel sprite collisions") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->retainAlpha();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageWrap::PrepareToRasterize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR number" " function" "()" " - " "bind the image into an OpenGL texture and free image data from main memory") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->prepareToRasterize();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageWrap::GetAlphaValue(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "({ ([object Point] p) | ([number int] x, [number int] y) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        uint8 a;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            a = self->getAlphaValue(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(args[1 -1]))
                return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(args[1 -1]);
            a = self->getAlphaValue(p.x, p.y);
        }
        return scope.Close( v8::Integer::NewFromUnsigned(a) );
    }

    v8::Handle<v8::Value> ImageWrap::GetPixel(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageWrap>(args.This());
        Image* self = dynamic_cast<Image*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Color]" " function" "({ ([object Point] p) | ([number int] x, [number int] y) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        pdg::Color c;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            c = self->getPixel(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(args[1 -1]))
                return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(args[1 -1]);
            c = self->getPixel(p.x, p.y);
        }
        return scope.Close( v8_MakeJavascriptColor(c) );
    }

    void CleanupImageScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ImageWrap* obj__=jswrap::ObjectWrap::Unwrap<ImageWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ImageWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Image""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Image""\n";
                }
            }
            else
            {
                Image* obj = dynamic_cast<Image*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Image"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Image" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    Image* New_Image(const v8::Arguments& args)
    {
        if (s_Image_InNewFromNative) return 0;
        ;
        if (args.Length() < 1)
        {
            return 0;
        }
        else if (!args[0]->IsString())
        {
            s_HaveSavedError = true;
            std::ostringstream excpt_;
            excpt_ << "argument 1 must be a string (filename)";
            s_SavedError = s_SavedError.New(v8::Exception::SyntaxError( v8::String::New(excpt_.str().c_str())));
            return 0;
        }
        else
        {
            v8::String::Utf8Value filename_Str(args[0]->ToString());
            const char* filename = *filename_Str;;
            return Image::createImageFromFile(filename);
        }
    }

    static bool s_ImageStrip_InNewFromNative = false;

    v8::Handle<v8::Value> ImageStripWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = new ImageStripWrap(args);
        objWrapper->Wrap(args.This());
        ImageStrip* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mImageStripScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> ImageStripWrap::NewFromNative(ImageStrip* nativeObj)
    {
        s_ImageStrip_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(obj);

        nativeObj->mImageStripScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_ImageStrip_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> ImageStripWrap::constructorTpl_;

    void ImageStripWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("ImageStrip"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(GetWidth, v8::Handle<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Width"), GetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(GetHeight, v8::Handle<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Height"), GetHeight_Tpl);
        v8::Local<v8::Signature> GetImageBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetImageBounds_Tpl =
            v8::FunctionTemplate::New(GetImageBounds, v8::Handle<v8::Value>(), GetImageBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""ImageBounds"), GetImageBounds_Tpl);
        v8::Local<v8::Signature> GetSubsection_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSubsection_Tpl =
            v8::FunctionTemplate::New(GetSubsection, v8::Handle<v8::Value>(), GetSubsection_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Subsection"), GetSubsection_Tpl);
        v8::Local<v8::Signature> SetTransparentColor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetTransparentColor_Tpl =
            v8::FunctionTemplate::New(SetTransparentColor, v8::Handle<v8::Value>(), SetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""TransparentColor"), SetTransparentColor_Tpl);
        v8::Local<v8::Signature> GetOpacity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetOpacity_Tpl =
            v8::FunctionTemplate::New(GetOpacity, v8::Handle<v8::Value>(), GetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Opacity"), GetOpacity_Tpl);
        v8::Local<v8::Signature> SetOpacity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetOpacity_Tpl =
            v8::FunctionTemplate::New(SetOpacity, v8::Handle<v8::Value>(), SetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Opacity"), SetOpacity_Tpl);
        v8::Local<v8::Signature> SetEdgeClamping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetEdgeClamping_Tpl =
            v8::FunctionTemplate::New(SetEdgeClamping, v8::Handle<v8::Value>(), SetEdgeClamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""EdgeClamping"), SetEdgeClamping_Tpl);
        v8::Local<v8::Signature> GetTransparentColor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTransparentColor_Tpl =
            v8::FunctionTemplate::New(GetTransparentColor, v8::Handle<v8::Value>(), GetTransparentColor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getTransparentColor"), GetTransparentColor_Tpl);
        v8::Local<v8::Signature> RetainData_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RetainData_Tpl =
            v8::FunctionTemplate::New(RetainData, v8::Handle<v8::Value>(), RetainData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("retainData"), RetainData_Tpl);
        v8::Local<v8::Signature> RetainAlpha_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RetainAlpha_Tpl =
            v8::FunctionTemplate::New(RetainAlpha, v8::Handle<v8::Value>(), RetainAlpha_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("retainAlpha"), RetainAlpha_Tpl);
        v8::Local<v8::Signature> PrepareToRasterize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PrepareToRasterize_Tpl =
            v8::FunctionTemplate::New(PrepareToRasterize, v8::Handle<v8::Value>(), PrepareToRasterize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("prepareToRasterize"), PrepareToRasterize_Tpl);
        v8::Local<v8::Signature> GetAlphaValue_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetAlphaValue_Tpl =
            v8::FunctionTemplate::New(GetAlphaValue, v8::Handle<v8::Value>(), GetAlphaValue_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""AlphaValue"), GetAlphaValue_Tpl);
        v8::Local<v8::Signature> GetPixel_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetPixel_Tpl =
            v8::FunctionTemplate::New(GetPixel, v8::Handle<v8::Value>(), GetPixel_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getPixel"), GetPixel_Tpl);
        v8::Local<v8::Signature> GetFrame_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFrame_Tpl =
            v8::FunctionTemplate::New(GetFrame, v8::Handle<v8::Value>(), GetFrame_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Frame"), GetFrame_Tpl);
        v8::Local<v8::Signature> GetFrameWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFrameWidth_Tpl =
            v8::FunctionTemplate::New(GetFrameWidth, v8::Handle<v8::Value>(), GetFrameWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""FrameWidth"), GetFrameWidth_Tpl);
        v8::Local<v8::Signature> SetFrameWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFrameWidth_Tpl =
            v8::FunctionTemplate::New(SetFrameWidth, v8::Handle<v8::Value>(), SetFrameWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""FrameWidth"), SetFrameWidth_Tpl);
        v8::Local<v8::Signature> GetNumFrames_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetNumFrames_Tpl =
            v8::FunctionTemplate::New(GetNumFrames, v8::Handle<v8::Value>(), GetNumFrames_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""NumFrames"), GetNumFrames_Tpl);
        v8::Local<v8::Signature> SetNumFrames_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetNumFrames_Tpl =
            v8::FunctionTemplate::New(SetNumFrames, v8::Handle<v8::Value>(), SetNumFrames_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""NumFrames"), SetNumFrames_Tpl);
        target->Set(v8::String::NewSymbol("ImageStrip"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> ImageStripWrap::GetTransparentColor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("object" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Color theTransparentColor = self->getTransparentColor();
        return scope.Close( v8_MakeJavascriptColor(theTransparentColor) );
    }

    v8::Handle<v8::Value> ImageStripWrap::SetTransparentColor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("ImageStrip" " function" "(object inTransparentColor)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsColor(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Color", *args[1 -1]);
        pdg::Color theTransparentColor = v8_ValueToColor(args[1 -1]);

        self->setTransparentColor(theTransparentColor);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int theWidth = self->getWidth();
        return scope.Close( v8::Integer::New(theWidth) );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int theHeight = self->getHeight();
        return scope.Close( v8::Integer::New(theHeight) );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetImageBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR [object Rect]" " function" "([object Point] at)" " - " "get image boundary rect, optionally with top left at given point") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point at = (args.Length()<1) ? pdg::Point(0,0) : v8_ValueToPoint(args[1 -1]);
        Rect r = self->getImageBounds(at);
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetSubsection(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR [object Image]" " function" "({[object Quad]|[object Rect]} quad)" " - " "get image that is an arbitrary subsection of this image") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(args[1 -1]);
        Image* image = self->getSubsection(quad);
        if (!image) return scope.Close( v8::Null() );
        if (image->mImageScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = ImageWrap::NewFromNative(image);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( image->mImageScriptObj );
        };
    }

    v8::Handle<v8::Value> ImageStripWrap::GetOpacity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR number" " function" "()" " - " "get opacity of this image: 0.0 - completely transparent to 1.0 - completely solid") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        uint8 opacity = self->getOpacity();
        double opacityFloat = (float)opacity / 255.0f;
        return scope.Close( v8::Number::New(opacityFloat) );
    }

    v8::Handle<v8::Value> ImageStripWrap::SetOpacity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "(number opacity)" " - " "set opacity of this image as range from either (0-255) or (0.0 to 1.0)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""opacity"")");
        unsigned long opacity = (args.Length()<1) ? 0xffffffff : args[1 -1]->Uint32Value();;
        if (opacity == 0xffffffff)
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""opacityFloat"")");
            double opacityFloat = args[1 -1]->NumberValue();
            opacity = std::floor(255.0f * opacityFloat);
        }
        if (opacity > 255) opacity = 255;
        self->setOpacity(opacity);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageStripWrap::SetEdgeClamping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "(boolean inUseEdgeClamp)" " - " "set whether image uses edge clamping or not") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""inUseEdgeClamp"")");
        bool inUseEdgeClamp = args[1 -1]->BooleanValue();
        self->setEdgeClamping(inUseEdgeClamp);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageStripWrap::RetainData(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "()" " - " "retain pixel data for use by Image.getPixel()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->retainData();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageStripWrap::RetainAlpha(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "()" " - " "retain alpha data for use by Image.getAlphaValue() or per-pixel sprite collisions") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->retainAlpha();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageStripWrap::PrepareToRasterize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR number" " function" "()" " - " "bind the image into an OpenGL texture and free image data from main memory") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->prepareToRasterize();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetAlphaValue(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "({ ([object Point] p) | ([number int] x, [number int] y) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        uint8 a;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            a = self->getAlphaValue(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(args[1 -1]))
                return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(args[1 -1]);
            a = self->getAlphaValue(p.x, p.y);
        }
        return scope.Close( v8::Integer::NewFromUnsigned(a) );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetPixel(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Color]" " function" "({ ([object Point] p) | ([number int] x, [number int] y) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""y"")");
        long y = (args.Length()<2) ? -1 : args[2 -1]->Int32Value();;
        pdg::Color c;
        if (y != -1)
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            long x = args[1 -1]->Int32Value();
            c = self->getPixel(x, y);
        }
        else
        {
            if (!v8_ValueIsPoint(args[1 -1]))
                return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
            pdg::Point p = v8_ValueToPoint(args[1 -1]);
            c = self->getPixel(p.x, p.y);
        }
        return scope.Close( v8_MakeJavascriptColor(c) );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetNumFrames(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int32 theNumFrames = self->getNumFrames();
        return scope.Close( v8::Integer::New(theNumFrames) );
    }

    v8::Handle<v8::Value> ImageStripWrap::SetNumFrames(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("ImageStrip" " function" "([number int] inNumFrames)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theNumFrames"")");
        long theNumFrames = args[1 -1]->Int32Value();

        self->setNumFrames(theNumFrames);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetFrameWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int32 theFrameWidth = self->getFrameWidth();
        return scope.Close( v8::Integer::New(theFrameWidth) );
    }

    v8::Handle<v8::Value> ImageStripWrap::SetFrameWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("ImageStrip" " function" "([number int] inFrameWidth)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theFrameWidth"")");
        long theFrameWidth = args[1 -1]->Int32Value();

        self->setFrameWidth(theFrameWidth);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> ImageStripWrap::GetFrame(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ImageStripWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(args.This());
        ImageStrip* self = dynamic_cast<ImageStrip*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Image]" " function" "([number int] frameNum)" " - " "get image that is a single frame of this multi-frame image") );
        };

        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""frameNum"")");
        long frameNum = args[1 -1]->Int32Value();
        Image* image = self->getFrame(frameNum);
        if (!image) return scope.Close( v8::Null() );
        if (image->mImageScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = ImageWrap::NewFromNative(image);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( image->mImageScriptObj );
        };
    }

    void CleanupImageStripScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ImageStripWrap* obj__=jswrap::ObjectWrap::Unwrap<ImageStripWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ImageStripWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""ImageStrip""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""ImageStrip""\n";
                }
            }
            else
            {
                ImageStrip* obj = dynamic_cast<ImageStrip*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""ImageStrip"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "ImageStrip" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    ImageStrip* New_ImageStrip(const v8::Arguments& args)
    {
        if (s_ImageStrip_InNewFromNative) return 0;
        ;
        if (args.Length() < 1)
        {
            return 0;
        }
        else if (!args[0]->IsString())
        {
            s_HaveSavedError = true;
            std::ostringstream excpt_;
            excpt_ << "argument 1 must be a string (filename)";
            s_SavedError = s_SavedError.New(v8::Exception::SyntaxError( v8::String::New(excpt_.str().c_str())));
            return 0;
        }
        else
        {
            v8::String::Utf8Value filename_Str(args[0]->ToString());
            const char* filename = *filename_Str;;
            return ImageStrip::createImageStripFromFile(filename);
        }
    }

#ifndef PDG_NO_GUI

    static bool s_GraphicsManager_InNewFromNative = false;

    v8::Handle<v8::Value> GraphicsManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = new GraphicsManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> GraphicsManagerWrap::instance_;
    bool GraphicsManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> GraphicsManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    GraphicsManager* GraphicsManagerWrap::getSingletonInstance()
    {
        v8::Handle<v8::Object> val =
            GetScriptSingletonInstance()->ToObject();
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(val);
        return dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> GraphicsManagerWrap::constructorTpl_;

    void GraphicsManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("GraphicsManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetNumScreens_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetNumScreens_Tpl =
            v8::FunctionTemplate::New(GetNumScreens, v8::Handle<v8::Value>(), GetNumScreens_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""NumScreens"), GetNumScreens_Tpl);
        v8::Local<v8::Signature> GetFPS_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFPS_Tpl =
            v8::FunctionTemplate::New(GetFPS, v8::Handle<v8::Value>(), GetFPS_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""FPS"), GetFPS_Tpl);
        v8::Local<v8::Signature> GetTargetFPS_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTargetFPS_Tpl =
            v8::FunctionTemplate::New(GetTargetFPS, v8::Handle<v8::Value>(), GetTargetFPS_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""TargetFPS"), GetTargetFPS_Tpl);
        v8::Local<v8::Signature> SetTargetFPS_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetTargetFPS_Tpl =
            v8::FunctionTemplate::New(SetTargetFPS, v8::Handle<v8::Value>(), SetTargetFPS_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""TargetFPS"), SetTargetFPS_Tpl);
        v8::Local<v8::Signature> GetMouse_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMouse_Tpl =
            v8::FunctionTemplate::New(GetMouse, v8::Handle<v8::Value>(), GetMouse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Mouse"), GetMouse_Tpl);
        v8::Local<v8::Signature> GetCurrentScreenMode_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCurrentScreenMode_Tpl =
            v8::FunctionTemplate::New(GetCurrentScreenMode, v8::Handle<v8::Value>(), GetCurrentScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getCurrentScreenMode"), GetCurrentScreenMode_Tpl);
        v8::Local<v8::Signature> GetNumSupportedScreenModes_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetNumSupportedScreenModes_Tpl =
            v8::FunctionTemplate::New(GetNumSupportedScreenModes, v8::Handle<v8::Value>(), GetNumSupportedScreenModes_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getNumSupportedScreenModes"), GetNumSupportedScreenModes_Tpl);
        v8::Local<v8::Signature> GetNthSupportedScreenMode_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetNthSupportedScreenMode_Tpl =
            v8::FunctionTemplate::New(GetNthSupportedScreenMode, v8::Handle<v8::Value>(), GetNthSupportedScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getNthSupportedScreenMode"), GetNthSupportedScreenMode_Tpl);
        v8::Local<v8::Signature> SetScreenMode_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetScreenMode_Tpl =
            v8::FunctionTemplate::New(SetScreenMode, v8::Handle<v8::Value>(), SetScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setScreenMode"), SetScreenMode_Tpl);
        v8::Local<v8::Signature> CreateWindowPort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateWindowPort_Tpl =
            v8::FunctionTemplate::New(CreateWindowPort, v8::Handle<v8::Value>(), CreateWindowPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createWindowPort"), CreateWindowPort_Tpl);
        v8::Local<v8::Signature> CreateFullScreenPort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateFullScreenPort_Tpl =
            v8::FunctionTemplate::New(CreateFullScreenPort, v8::Handle<v8::Value>(), CreateFullScreenPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createFullScreenPort"), CreateFullScreenPort_Tpl);
        v8::Local<v8::Signature> CloseGraphicsPort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CloseGraphicsPort_Tpl =
            v8::FunctionTemplate::New(CloseGraphicsPort, v8::Handle<v8::Value>(), CloseGraphicsPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("closeGraphicsPort"), CloseGraphicsPort_Tpl);
        v8::Local<v8::Signature> CreateFont_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateFont_Tpl =
            v8::FunctionTemplate::New(CreateFont, v8::Handle<v8::Value>(), CreateFont_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createFont"), CreateFont_Tpl);
        v8::Local<v8::Signature> GetMainPort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMainPort_Tpl =
            v8::FunctionTemplate::New(GetMainPort, v8::Handle<v8::Value>(), GetMainPort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getMainPort"), GetMainPort_Tpl);
        v8::Local<v8::Signature> SwitchToFullScreenMode_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SwitchToFullScreenMode_Tpl =
            v8::FunctionTemplate::New(SwitchToFullScreenMode, v8::Handle<v8::Value>(), SwitchToFullScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("switchToFullScreenMode"), SwitchToFullScreenMode_Tpl);
        v8::Local<v8::Signature> SwitchToWindowMode_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SwitchToWindowMode_Tpl =
            v8::FunctionTemplate::New(SwitchToWindowMode, v8::Handle<v8::Value>(), SwitchToWindowMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("switchToWindowMode"), SwitchToWindowMode_Tpl);
        v8::Local<v8::Signature> InFullScreenMode_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> InFullScreenMode_Tpl =
            v8::FunctionTemplate::New(InFullScreenMode, v8::Handle<v8::Value>(), InFullScreenMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("inFullScreenMode"), InFullScreenMode_Tpl);
        target->Set(v8::String::NewSymbol("GraphicsManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> GraphicsManagerWrap::GetNumScreens(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int theNumScreens = self->getNumScreens();
        return scope.Close( v8::Integer::New(theNumScreens) );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::GetFPS(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theFPS = self->getFPS();
        return scope.Close( v8::Number::New(theFPS) );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::GetTargetFPS(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theTargetFPS = self->getTargetFPS();
        return scope.Close( v8::Number::New(theTargetFPS) );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::SetTargetFPS(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("GraphicsManager" " function" "(number inTargetFPS)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theTargetFPS"")");
        double theTargetFPS = args[1 -1]->NumberValue();

        self->setTargetFPS(theTargetFPS);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::GetMouse(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "([number int] mouseNumber = 0)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""mouseNumber"")");
        long mouseNumber = (args.Length()<1) ? 0 : args[1 -1]->Int32Value();;

        pdg::Point theMouse = self->getMouse(mouseNumber);
        return scope.Close( v8_MakeJavascriptPoint(theMouse) );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::GetNumSupportedScreenModes(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([number int] screen = PRIMARY_SCREEN)") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""screenNum"")");
        long screenNum = (args.Length()<1) ? GraphicsManager::screenNum_PrimaryScreen : args[1 -1]->Int32Value();;

        int32 theNumSupportedScreenModes = self->getNumSupportedScreenModes(screenNum);
        return scope.Close( v8::Integer::New(theNumSupportedScreenModes) );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::SetScreenMode(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] width, [number int] height, [number int] screenNum = PRIMARY_SCREEN, [number int] bpp = 0)" " - " "changes specified screen to closest matching mode") );
        };

        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        long width = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        long height = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""screenNum"")");
        long screenNum = (args.Length()<3) ? GraphicsManager::screenNum_PrimaryScreen : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""bpp"")");
        long bpp = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        self->setScreenMode(width, height, screenNum, bpp);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::CreateWindowPort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Port]" " function" "([object Rect] rect, string windName = \"\", [number int] bpp = 0)" " - " "create windowed drawing port with given dimensions, title and depth") );
        };

        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsString())
            return v8_ThrowArgTypeException(2, "a string  (""windName"")");
        v8::String::Utf8Value _windName_String( (args.Length()<2) ? v8::String::NewSymbol("") : args[2 -1]->ToString() );
        const char* windName = (args.Length()<2) ? "" : *_windName_String;;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""bpp"")");
        long bpp = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        Port* port = self->createWindowPort(rect, windName, bpp);
        if (!port) return scope.Close( v8::Null() );
        if (port->mPortScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = PortWrap::NewFromNative(port);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( port->mPortScriptObj );
        };
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::CreateFullScreenPort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Port]" " function" "([object Rect] rect, [number int] screenNum = PRIMARY_SCREEN, boolean allowResChange = true, [number int] bpp = 0)" " - " "create full screen drawing port with given dimensions on given screen, optionally changing depth") );
        };

        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""screenNum"")");
        long screenNum = (args.Length()<2) ? GraphicsManager::screenNum_PrimaryScreen : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            return v8_ThrowArgTypeException(3, "a boolean (""allowResChange"")");
        bool allowResChange = (args.Length()<3) ? true : args[3 -1]->BooleanValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""bpp"")");
        long bpp = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        Port* port = self->createFullScreenPort(rect, screenNum, allowResChange, bpp);
        if (!port) return scope.Close( v8::Null() );
        if (port->mPortScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = PortWrap::NewFromNative(port);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( port->mPortScriptObj );
        };
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::CloseGraphicsPort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Port] port = MAIN_PORT)" " - " "close given port, along with its window and restore screen mode if changed") );
        };

        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Handle<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap<PortWrap>(port_);
                port = port__->getNativeObject();
            }
        };
        self->closeGraphicsPort(port);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::CreateFont(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Font]" " function" "(string fontName, number scalingFactor = 1.0)" " - " "get a font with optional scaling adjust") );
        };

        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""fontName"")");
        v8::String::Utf8Value fontName_Str(args[1 -1]->ToString());
        const char* fontName = *fontName_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""scalingFactor"")");
        double scalingFactor = (args.Length()<2) ? 1.0f : args[2 -1]->NumberValue();;
        Font* font = self->createFont(fontName, scalingFactor);
        if (!font) return scope.Close( v8::Null() );
        if (font->mFontScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = FontWrap::NewFromNative(font);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( font->mFontScriptObj );
        };
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::GetMainPort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Port]" " function" "()" " - " "return the primary graphics port") );
        };

        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Port* port = self->getMainPort();
        if (!port) return scope.Close( v8::Null() );
        if (port->mPortScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = PortWrap::NewFromNative(port);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( port->mPortScriptObj );
        };
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::SwitchToFullScreenMode(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "(boolean allowResChange = false, [object Port] port = MAIN_PORT)" " - " "change a port to fullscreen mode, return true on success") );
        };

        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""allowResChange"")");
        bool allowResChange = (args.Length()<1) ? 0 : args[1 -1]->BooleanValue();;
        Port* port = 0;
        if (args.Length() >= 2)
        {
            if (!args[2 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(2, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Handle<v8::Object> port_ = args[2 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap<PortWrap>(port_);
                port = port__->getNativeObject();
            }
        };
        bool result = self->switchToFullScreenMode(allowResChange, port);
        return scope.Close( v8::Boolean::New(result) );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::SwitchToWindowMode(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([object Port] port = MAIN_PORT, string windName = \"\")" " - " "change a port to window mode, return true on success") );
        };

        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Handle<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap<PortWrap>(port_);
                port = port__->getNativeObject();
            }
        };
        if (args.Length() >= 2 && !args[2 -1]->IsString())
            return v8_ThrowArgTypeException(2, "a string  (""windName"")");
        v8::String::Utf8Value _windName_String( (args.Length()<2) ? v8::String::NewSymbol("") : args[2 -1]->ToString() );
        const char* windName = (args.Length()<2) ? "" : *_windName_String;;
        bool result = self->switchToWindowMode(port, windName);
        return scope.Close( v8::Boolean::New(result) );
    }

    v8::Handle<v8::Value> GraphicsManagerWrap::InFullScreenMode(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        GraphicsManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<GraphicsManagerWrap>(args.This());
        GraphicsManager* self = dynamic_cast<GraphicsManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "return whether primary graphics port is fullscreen or not") );
        };

        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        bool fullscreen = self->inFullScreenMode();
        return scope.Close( v8::Boolean::New(fullscreen) );
    }

    GraphicsManager* New_GraphicsManager(const v8::Arguments& args)
    {
        if (s_GraphicsManager_InNewFromNative) return 0;
        return GraphicsManager::getSingletonInstance();
    }

    static bool s_Font_InNewFromNative = false;

    v8::Handle<v8::Value> FontWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        FontWrap* objWrapper = new FontWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> FontWrap::NewFromNative(Font* nativeObj)
    {
        s_Font_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(obj);

        nativeObj->mFontScriptObj = v8::Persistent<v8::Object>::New(obj);
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Font_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> FontWrap::constructorTpl_;

    void FontWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Font"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetFontName_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFontName_Tpl =
            v8::FunctionTemplate::New(GetFontName, v8::Handle<v8::Value>(), GetFontName_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""FontName"), GetFontName_Tpl);
        v8::Local<v8::Signature> GetFontHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFontHeight_Tpl =
            v8::FunctionTemplate::New(GetFontHeight, v8::Handle<v8::Value>(), GetFontHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""FontHeight"), GetFontHeight_Tpl);
        v8::Local<v8::Signature> GetFontLeading_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFontLeading_Tpl =
            v8::FunctionTemplate::New(GetFontLeading, v8::Handle<v8::Value>(), GetFontLeading_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""FontLeading"), GetFontLeading_Tpl);
        v8::Local<v8::Signature> GetFontAscent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFontAscent_Tpl =
            v8::FunctionTemplate::New(GetFontAscent, v8::Handle<v8::Value>(), GetFontAscent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""FontAscent"), GetFontAscent_Tpl);
        v8::Local<v8::Signature> GetFontDescent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFontDescent_Tpl =
            v8::FunctionTemplate::New(GetFontDescent, v8::Handle<v8::Value>(), GetFontDescent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""FontDescent"), GetFontDescent_Tpl);
        target->Set(v8::String::NewSymbol("Font"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> FontWrap::GetFontName(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        const char* theFontName = self->getFontName();
        return scope.Close( v8::String::New(theFontName) );
    }

    v8::Handle<v8::Value> FontWrap::GetFontHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(number size, [number int] style = textStyle_Plain)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? Graphics::textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontHeight = self->getFontHeight(size, style);
        return scope.Close( v8::Number::New(theFontHeight) );
    }

    v8::Handle<v8::Value> FontWrap::GetFontLeading(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(number size, [number int] style = textStyle_Plain)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? Graphics::textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontLeading = self->getFontLeading(size, style);
        return scope.Close( v8::Number::New(theFontLeading) );
    }

    v8::Handle<v8::Value> FontWrap::GetFontAscent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(number size, [number int] style = textStyle_Plain)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? Graphics::textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontAscent = self->getFontAscent(size, style);
        return scope.Close( v8::Number::New(theFontAscent) );
    }

    v8::Handle<v8::Value> FontWrap::GetFontDescent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        FontWrap* objWrapper = jswrap::ObjectWrap::Unwrap<FontWrap>(args.This());
        Font* self = dynamic_cast<Font*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(number size, [number int] style = textStyle_Plain)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""size"")");
        long size = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""style"")");
        unsigned long style = (args.Length()<2) ? Graphics::textStyle_Plain : args[2 -1]->Uint32Value();;

        float theFontDescent = self->getFontDescent(size, style);
        return scope.Close( v8::Number::New(theFontDescent) );
    }

    void CleanupFontScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                FontWrap* obj__=jswrap::ObjectWrap::Unwrap<FontWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<FontWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Font""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Font""\n";
                }
            }
            else
            {
                Font* obj = dynamic_cast<Font*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Font"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Font" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    static bool s_Port_InNewFromNative = false;

    v8::Handle<v8::Value> PortWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = new PortWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> PortWrap::NewFromNative(Port* nativeObj)
    {
        s_Port_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(obj);

        nativeObj->mPortScriptObj = obj;
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Port_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> PortWrap::constructorTpl_;

    void PortWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Port"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetClipRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetClipRect_Tpl =
            v8::FunctionTemplate::New(GetClipRect, v8::Handle<v8::Value>(), GetClipRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""ClipRect"), GetClipRect_Tpl);
        v8::Local<v8::Signature> SetClipRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetClipRect_Tpl =
            v8::FunctionTemplate::New(SetClipRect, v8::Handle<v8::Value>(), SetClipRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""ClipRect"), SetClipRect_Tpl);
        v8::Local<v8::Signature> GetCursor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCursor_Tpl =
            v8::FunctionTemplate::New(GetCursor, v8::Handle<v8::Value>(), GetCursor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Cursor"), GetCursor_Tpl);
        v8::Local<v8::Signature> SetCursor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCursor_Tpl =
            v8::FunctionTemplate::New(SetCursor, v8::Handle<v8::Value>(), SetCursor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Cursor"), SetCursor_Tpl);
        v8::Local<v8::Signature> GetDrawingArea_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetDrawingArea_Tpl =
            v8::FunctionTemplate::New(GetDrawingArea, v8::Handle<v8::Value>(), GetDrawingArea_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""DrawingArea"), GetDrawingArea_Tpl);
        v8::Local<v8::Signature> FillRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FillRect_Tpl =
            v8::FunctionTemplate::New(FillRect, v8::Handle<v8::Value>(), FillRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fillRect"), FillRect_Tpl);
        v8::Local<v8::Signature> FrameRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FrameRect_Tpl =
            v8::FunctionTemplate::New(FrameRect, v8::Handle<v8::Value>(), FrameRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("frameRect"), FrameRect_Tpl);
        v8::Local<v8::Signature> DrawLine_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DrawLine_Tpl =
            v8::FunctionTemplate::New(DrawLine, v8::Handle<v8::Value>(), DrawLine_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("drawLine"), DrawLine_Tpl);
        v8::Local<v8::Signature> FrameOval_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FrameOval_Tpl =
            v8::FunctionTemplate::New(FrameOval, v8::Handle<v8::Value>(), FrameOval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("frameOval"), FrameOval_Tpl);
        v8::Local<v8::Signature> FillOval_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FillOval_Tpl =
            v8::FunctionTemplate::New(FillOval, v8::Handle<v8::Value>(), FillOval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fillOval"), FillOval_Tpl);
        v8::Local<v8::Signature> FrameCircle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FrameCircle_Tpl =
            v8::FunctionTemplate::New(FrameCircle, v8::Handle<v8::Value>(), FrameCircle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("frameCircle"), FrameCircle_Tpl);
        v8::Local<v8::Signature> FillCircle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FillCircle_Tpl =
            v8::FunctionTemplate::New(FillCircle, v8::Handle<v8::Value>(), FillCircle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fillCircle"), FillCircle_Tpl);
        v8::Local<v8::Signature> FrameRoundRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FrameRoundRect_Tpl =
            v8::FunctionTemplate::New(FrameRoundRect, v8::Handle<v8::Value>(), FrameRoundRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("frameRoundRect"), FrameRoundRect_Tpl);
        v8::Local<v8::Signature> FillRoundRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FillRoundRect_Tpl =
            v8::FunctionTemplate::New(FillRoundRect, v8::Handle<v8::Value>(), FillRoundRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fillRoundRect"), FillRoundRect_Tpl);
        v8::Local<v8::Signature> FillRectEx_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FillRectEx_Tpl =
            v8::FunctionTemplate::New(FillRectEx, v8::Handle<v8::Value>(), FillRectEx_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fillRectEx"), FillRectEx_Tpl);
        v8::Local<v8::Signature> FrameRectEx_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FrameRectEx_Tpl =
            v8::FunctionTemplate::New(FrameRectEx, v8::Handle<v8::Value>(), FrameRectEx_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("frameRectEx"), FrameRectEx_Tpl);
        v8::Local<v8::Signature> DrawLineEx_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DrawLineEx_Tpl =
            v8::FunctionTemplate::New(DrawLineEx, v8::Handle<v8::Value>(), DrawLineEx_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("drawLineEx"), DrawLineEx_Tpl);
        v8::Local<v8::Signature> FillRectWithGradient_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FillRectWithGradient_Tpl =
            v8::FunctionTemplate::New(FillRectWithGradient, v8::Handle<v8::Value>(), FillRectWithGradient_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fillRectWithGradient"), FillRectWithGradient_Tpl);
        v8::Local<v8::Signature> DrawText_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DrawText_Tpl =
            v8::FunctionTemplate::New(DrawText, v8::Handle<v8::Value>(), DrawText_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("drawText"), DrawText_Tpl);
        v8::Local<v8::Signature> DrawImage_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DrawImage_Tpl =
            v8::FunctionTemplate::New(DrawImage, v8::Handle<v8::Value>(), DrawImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("drawImage"), DrawImage_Tpl);
        v8::Local<v8::Signature> DrawTexture_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DrawTexture_Tpl =
            v8::FunctionTemplate::New(DrawTexture, v8::Handle<v8::Value>(), DrawTexture_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("drawTexture"), DrawTexture_Tpl);
        v8::Local<v8::Signature> DrawTexturedSphere_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DrawTexturedSphere_Tpl =
            v8::FunctionTemplate::New(DrawTexturedSphere, v8::Handle<v8::Value>(), DrawTexturedSphere_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("drawTexturedSphere"), DrawTexturedSphere_Tpl);
        v8::Local<v8::Signature> GetTextWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTextWidth_Tpl =
            v8::FunctionTemplate::New(GetTextWidth, v8::Handle<v8::Value>(), GetTextWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getTextWidth"), GetTextWidth_Tpl);
        v8::Local<v8::Signature> GetCurrentFont_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCurrentFont_Tpl =
            v8::FunctionTemplate::New(GetCurrentFont, v8::Handle<v8::Value>(), GetCurrentFont_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getCurrentFont"), GetCurrentFont_Tpl);
        v8::Local<v8::Signature> SetFont_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFont_Tpl =
            v8::FunctionTemplate::New(SetFont, v8::Handle<v8::Value>(), SetFont_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFont"), SetFont_Tpl);
        v8::Local<v8::Signature> SetFontForStyle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFontForStyle_Tpl =
            v8::FunctionTemplate::New(SetFontForStyle, v8::Handle<v8::Value>(), SetFontForStyle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFontForStyle"), SetFontForStyle_Tpl);
        v8::Local<v8::Signature> SetFontScalingFactor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFontScalingFactor_Tpl =
            v8::FunctionTemplate::New(SetFontScalingFactor, v8::Handle<v8::Value>(), SetFontScalingFactor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFontScalingFactor"), SetFontScalingFactor_Tpl);
        v8::Local<v8::Signature> StartTrackingMouse_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartTrackingMouse_Tpl =
            v8::FunctionTemplate::New(StartTrackingMouse, v8::Handle<v8::Value>(), StartTrackingMouse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startTrackingMouse"), StartTrackingMouse_Tpl);
        v8::Local<v8::Signature> StopTrackingMouse_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopTrackingMouse_Tpl =
            v8::FunctionTemplate::New(StopTrackingMouse, v8::Handle<v8::Value>(), StopTrackingMouse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopTrackingMouse"), StopTrackingMouse_Tpl);
        v8::Local<v8::Signature> ResetCursor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ResetCursor_Tpl =
            v8::FunctionTemplate::New(ResetCursor, v8::Handle<v8::Value>(), ResetCursor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resetCursor"), ResetCursor_Tpl);
        target->Set(v8::String::NewSymbol("Port"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> PortWrap::GetDrawingArea(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Rect theDrawingArea = self->getDrawingArea();
        return scope.Close( v8_MakeJavascriptRect(theDrawingArea) );
    }

    v8::Handle<v8::Value> PortWrap::GetClipRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Rect theClipRect = self->getClipRect();
        return scope.Close( v8_MakeJavascriptRect(theClipRect) );
    }

    v8::Handle<v8::Value> PortWrap::SetClipRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Port" " function" "([object Rect] inClipRect)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Rect", *args[1 -1]);
        pdg::Rect theClipRect = v8_ValueToRect(args[1 -1]);

        self->setClipRect(theClipRect);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> PortWrap::FillRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[object Quad]|[object Rect]} quad, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(args[1 -1]);
        if (args.Length() >= 2 && !v8_ValueIsColor(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Color", *args[2 -1]);
        pdg::Color rgba = (args.Length()<2) ? PDG_BLACK_COLOR : v8_ValueToColor(args[2 -1]);
        self->fillRect(quad, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FrameRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[object Quad]|[object Rect]} quad, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(args[1 -1]);
        if (args.Length() >= 2 && !v8_ValueIsColor(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Color", *args[2 -1]);
        pdg::Color rgba = (args.Length()<2) ? PDG_BLACK_COLOR : v8_ValueToColor(args[2 -1]);
        self->frameRect(quad, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::DrawLine(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] from, [object Point] to, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point from = v8_ValueToPoint(args[1 -1]);
        if (!v8_ValueIsPoint(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Point", *args[2 -1]);
        pdg::Point to = v8_ValueToPoint(args[2 -1]);
        if (args.Length() >= 3 && !v8_ValueIsColor(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(args[3 -1]);
        self->drawLine(from, to, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FrameOval(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] centerPt, number xRadius, number yRadius, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""xRadius"")");
        double xRadius = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""yRadius"")");
        double yRadius = args[3 -1]->NumberValue();
        if (args.Length() >= 4 && !v8_ValueIsColor(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Color", *args[4 -1]);
        pdg::Color rgba = (args.Length()<4) ? PDG_BLACK_COLOR : v8_ValueToColor(args[4 -1]);
        self->frameOval(centerPt, xRadius, yRadius, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FillOval(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] centerPt, number xRadius, number yRadius, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""xRadius"")");
        double xRadius = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""yRadius"")");
        double yRadius = args[3 -1]->NumberValue();
        if (args.Length() >= 4 && !v8_ValueIsColor(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Color", *args[4 -1]);
        pdg::Color rgba = (args.Length()<4) ? PDG_BLACK_COLOR : v8_ValueToColor(args[4 -1]);
        self->fillOval(centerPt, xRadius, yRadius, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FrameCircle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] centerPt, number radius, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(args[3 -1]);
        self->frameCircle(centerPt, radius, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FillCircle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] centerPt, number radius, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point centerPt = v8_ValueToPoint(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(args[3 -1]);
        self->fillCircle(centerPt, radius, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FrameRoundRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Rect] rect, number radius, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!v8_ValueIsRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(args[3 -1]);
        self->frameRoundRect(rect, radius, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FillRoundRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Rect] rect, number radius, [object Color] rgba = \"black\")" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!v8_ValueIsRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""radius"")");
        double radius = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !v8_ValueIsColor(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Color", *args[3 -1]);
        pdg::Color rgba = (args.Length()<3) ? PDG_BLACK_COLOR : v8_ValueToColor(args[3 -1]);
        self->fillRoundRect(rect, radius, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FillRectEx(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[object Quad]|[object Rect]} quad, [number uint] pattern, [number uint] patternShift, [object Color] rgba)" " - " "") );
        };
        if (args.Length() != 4)
            return v8_ThrowArgCountException(args.Length(), 4);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""pattern"")");
        unsigned long pattern = args[2 -1]->Uint32Value();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""patternShift"")");
        unsigned long patternShift = args[3 -1]->Uint32Value();
        if (!v8_ValueIsColor(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Color", *args[4 -1]);
        pdg::Color rgba = v8_ValueToColor(args[4 -1]);
        self->fillRectEx(quad, pattern, patternShift, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FrameRectEx(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[object Quad]|[object Rect]} quad, [number uint] thickness, [number uint] pattern, [number uint] patternShift, [object Color] rgba)" " - " "") );
        };
        if (args.Length() != 5)
            return v8_ThrowArgCountException(args.Length(), 5);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(args[1 -1]);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""thickness"")");
        unsigned long thickness = args[2 -1]->Uint32Value();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""pattern"")");
        unsigned long pattern = args[3 -1]->Uint32Value();
        if (!args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""patternShift"")");
        unsigned long patternShift = args[4 -1]->Uint32Value();
        if (!v8_ValueIsColor(args[5 -1]))
            return v8_ThrowArgTypeException(5, "Color", *args[5 -1]);
        pdg::Color rgba = v8_ValueToColor(args[5 -1]);
        self->frameRectEx(quad, thickness, pattern, patternShift, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::DrawLineEx(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] from, [object Point] to, [number uint] thickness, [number uint] pattern, [number uint] patternShift, [object Color] rgba)" " - " "") );
        };
        if (args.Length() != 6)
            return v8_ThrowArgCountException(args.Length(), 6);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point from = v8_ValueToPoint(args[1 -1]);
        if (!v8_ValueIsPoint(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Point", *args[2 -1]);
        pdg::Point to = v8_ValueToPoint(args[2 -1]);
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""thickness"")");
        unsigned long thickness = args[3 -1]->Uint32Value();
        if (!args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""pattern"")");
        unsigned long pattern = args[4 -1]->Uint32Value();
        if (!args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""patternShift"")");
        unsigned long patternShift = args[5 -1]->Uint32Value();
        if (!v8_ValueIsColor(args[6 -1]))
            return v8_ThrowArgTypeException(6, "Color", *args[6 -1]);
        pdg::Color rgba = v8_ValueToColor(args[6 -1]);
        self->drawLineEx(from, to, thickness, pattern, patternShift, rgba);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::FillRectWithGradient(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[object Quad]|[object Rect]} quad, [object Color] startColor, [object Color] endColor)" " - " "") );
        };
        if (args.Length() != 3)
            return v8_ThrowArgCountException(args.Length(), 3);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad quad = v8_ValueToQuad(args[1 -1]);
        if (!v8_ValueIsColor(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Color", *args[2 -1]);
        pdg::Color startColor = v8_ValueToColor(args[2 -1]);
        if (!v8_ValueIsColor(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Color", *args[3 -1]);
        pdg::Color endColor = v8_ValueToColor(args[3 -1]);
        self->fillRectWithGradient(quad, startColor, endColor);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::DrawText(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(string text, {[object Point] location|[object Quad] quad|[object Rect] rect}, [number int] size, [number uint] style = textStyle_Plain, [object Color] rgba = 'black')" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""text"")");
        v8::String::Utf8Value text_Str(args[1 -1]->ToString());
        const char* text = *text_Str;;

        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""size"")");
        long size = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""style"")");
        unsigned long style = (args.Length()<4) ? Graphics::textStyle_Plain : args[4 -1]->Uint32Value();;
        if (args.Length() >= 5 && !v8_ValueIsColor(args[5 -1]))
            return v8_ThrowArgTypeException(5, "Color", *args[5 -1]);
        pdg::Color rgba = (args.Length()<5) ? PDG_BLACK_COLOR : v8_ValueToColor(args[5 -1]);
        if (v8_ValueIsPoint(args[1]))
        {

            pdg::Point loc = v8_ValueToPoint(args[1]);
            self->drawText(text, loc, size, style, rgba);
        }
        else
        {

            if (!v8_ValueIsQuad(args[2 -1]))
                return v8_ThrowArgTypeException(2, "Quad", *args[2 -1]);
            pdg::Quad quad = v8_ValueToQuad(args[2 -1]);
            self->drawText(text, quad, size, style, rgba);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::DrawImage(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({ ([object Image] img, [object Point] loc) | ([object Image] img, [object Quad] quad) | ([object Image] img, [object Rect] rect, [number int] fitType = fit_Fill, boolean clipOverflow = false) })" " - " "") );
        };
        REQUIRE_NATIVE_OBJECT_ARG(1, img, Image);
        ImageStrip* imgStrip = dynamic_cast<ImageStrip*>(img);
        int argAdd = (imgStrip->frames) ? 1 : 0;
        if (args.Length() < 2 + argAdd)
            return v8_ThrowArgCountException(args.Length(), 2 + argAdd, true);
        int frameNum = 0;
        if (args[1]->IsNumber())
        {
            frameNum = args[1]->Int32Value();
        }
        if (v8_ValueIsPoint(args[1 + argAdd]))
        {
            pdg::Point loc = v8_ValueToPoint(args[1 + argAdd]);

            if (imgStrip->frames)
            {
                self->drawImage(imgStrip, frameNum, loc);
            }
            else
            {
                self->drawImage(img, loc);
            }
        }
        else if (args.Length() > 2 + argAdd)
        {
            if (!v8_ValueIsRect(args[2 + argAdd-1]))
                return v8_ThrowArgTypeException(2 + argAdd, "Rect", *args[2 + argAdd-1]);
            pdg::Rect rect = v8_ValueToRect(args[2 + argAdd-1]);
            if (args.Length() >= 3 + argAdd && !args[3 + argAdd-1]->IsNumber())
                return v8_ThrowArgTypeException(3 + argAdd, "a number (""fitType"")");
            long fitType = (args.Length()<3 + argAdd) ? Image::fit_Fill : args[3 + argAdd-1]->Int32Value();;
            if (args.Length() >= 4 + argAdd && !args[4 + argAdd-1]->IsBoolean())
                return v8_ThrowArgTypeException(4 + argAdd, "a boolean (""clipOverflow"")");
            bool clipOverflow = (args.Length()<4 + argAdd) ? false : args[4 + argAdd-1]->BooleanValue();;
            if (imgStrip->frames)
            {
                self->drawImage(imgStrip, frameNum, rect, (Image::FitType)fitType, clipOverflow);
            }
            else
            {
                self->drawImage(img, rect, (Image::FitType)fitType, clipOverflow);
            }
        }
        else
        {

            if (!v8_ValueIsQuad(args[2 + argAdd-1]))
                return v8_ThrowArgTypeException(2 + argAdd, "Quad", *args[2 + argAdd-1]);
            pdg::Quad quad = v8_ValueToQuad(args[2 + argAdd-1]);
            if (imgStrip->frames)
            {
                self->drawImage(imgStrip, frameNum, quad);
            }
            else
            {
                self->drawImage(img, quad);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::DrawTexture(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Image] img, [object Rect] r)" " - " "") );
        };
        REQUIRE_NATIVE_OBJECT_ARG(1, img, Image);
        ImageStrip* imgStrip = dynamic_cast<ImageStrip*>(img);
        int argAdd = (imgStrip->frames) ? 1 : 0;
        if (args.Length() < 2 + argAdd)
            return v8_ThrowArgCountException(args.Length(), 2 + argAdd, true);
        if (!v8_ValueIsRect(args[2 + argAdd-1]))
            return v8_ThrowArgTypeException(2 + argAdd, "Rect", *args[2 + argAdd-1]);
        pdg::Rect r = v8_ValueToRect(args[2 + argAdd-1]);
        int frameNum = 0;
        if (args[1]->IsNumber())
        {
            frameNum = args[1]->Int32Value();
        }
        if (imgStrip->frames)
        {
            self->drawTexture(imgStrip, frameNum, r);
        }
        else
        {
            self->drawTexture(img, r);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::DrawTexturedSphere(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[object Image] img|[object ImageStrip] imgStrip, [number int] frameNum}, [object Point] loc, number radius, number rotation = 0, [object Offset] polarOffsetRadians = Offset(0,0), [object Offset] lightOffsetRadians = Offset(0,0))" " - " "") );
        };
        REQUIRE_NATIVE_OBJECT_ARG(1, img, Image);
        ImageStrip* imgStrip = dynamic_cast<ImageStrip*>(img);
        int argAdd = (imgStrip->frames) ? 1 : 0;
        if (args.Length() < 3 + argAdd)
            return v8_ThrowArgCountException(args.Length(), 3 + argAdd, true);
        if (!v8_ValueIsPoint(args[2 + argAdd-1]))
            return v8_ThrowArgTypeException(2 + argAdd, "Point", *args[2 + argAdd-1]);
        pdg::Point loc = v8_ValueToPoint(args[2 + argAdd-1]);
        if (!args[3 + argAdd-1]->IsNumber())
            return v8_ThrowArgTypeException(3 + argAdd, "a number (""radius"")");
        double radius = args[3 + argAdd-1]->NumberValue();
        if (args.Length() >= 4 + argAdd && !args[4 + argAdd-1]->IsNumber())
            return v8_ThrowArgTypeException(4 + argAdd, "a number (""rotation"")");
        double rotation = (args.Length()<4 + argAdd) ? 0.0f : args[4 + argAdd-1]->NumberValue();;
        if (args.Length() >= 5 + argAdd && !v8_ValueIsOffset(args[5 + argAdd-1]))
            return v8_ThrowArgTypeException(5 + argAdd, "Offset", *args[5 + argAdd-1]);
        pdg::Offset polarOffsetRadians = (args.Length()<5 + argAdd) ? Offset() : v8_ValueToOffset(args[5 + argAdd-1]);
        if (args.Length() >= 6 + argAdd && !v8_ValueIsOffset(args[6 + argAdd-1]))
            return v8_ThrowArgTypeException(6 + argAdd, "Offset", *args[6 + argAdd-1]);
        pdg::Offset lightOffsetRadians = (args.Length()<6 + argAdd) ? Offset() : v8_ValueToOffset(args[6 + argAdd-1]);
        int frameNum = 0;
        if (args[1]->IsNumber())
        {
            frameNum = args[1]->Int32Value();
        }
        if (imgStrip->frames)
        {
            self->drawTexturedSphere(imgStrip, frameNum, loc, radius, rotation, polarOffsetRadians, lightOffsetRadians);
        }
        else
        {
            self->drawTexturedSphere(img, loc, radius, rotation, polarOffsetRadians, lightOffsetRadians);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::GetTextWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "(string text, [number int] size, [number uint] style = textStyle_Plain, [number int] len = -1)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""text"")");
        v8::String::Utf8Value text_Str(args[1 -1]->ToString());
        const char* text = *text_Str;;
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""size"")");
        long size = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""style"")");
        unsigned long style = (args.Length()<3) ? Graphics::textStyle_Plain : args[3 -1]->Uint32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""len"")");
        long len = (args.Length()<4) ? -1 : args[4 -1]->Int32Value();;
        int width = self->getTextWidth(text, size, style, len);
        return scope.Close( v8::Integer::New(width) );
    }

    v8::Handle<v8::Value> PortWrap::GetCurrentFont(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Font]" " function" "([number uint] style = textStyle_Plain)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""style"")");
        unsigned long style = (args.Length()<1) ? Graphics::textStyle_Plain : args[1 -1]->Uint32Value();;
        Font* font = self->getCurrentFont(style);
        if (!font) return scope.Close( v8::Null() );
        if (font->mFontScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = FontWrap::NewFromNative(font);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( font->mFontScriptObj );
        };
    }

    v8::Handle<v8::Value> PortWrap::SetFont(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Font] font = DEFAULT_FONT)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        Font* font = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(1, "an object of type ""Font"" (""font"")");
            }
            else
            {
                v8::Handle<v8::Object> font_ = args[1 -1]->ToObject();
                FontWrap* font__ = jswrap::ObjectWrap::Unwrap<FontWrap>(font_);
                font = font__->getNativeObject();
            }
        };
        self->setFont(font);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::SetFontForStyle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] style, [object Font] font = DEFAULT_FONT)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""style"")");
        unsigned long style = args[1 -1]->Uint32Value();
        Font* font = 0;
        if (args.Length() >= 2)
        {
            if (!args[2 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(2, "an object of type ""Font"" (""font"")");
            }
            else
            {
                v8::Handle<v8::Object> font_ = args[2 -1]->ToObject();
                FontWrap* font__ = jswrap::ObjectWrap::Unwrap<FontWrap>(font_);
                font = font__->getNativeObject();
            }
        };
        self->setFontForStyle(font, style);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::SetFontScalingFactor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number scaleBy)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""scaleBy"")");
        double scaleBy = args[1 -1]->NumberValue();
        self->setFontScalingFactor(scaleBy);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::StartTrackingMouse(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([object Rect] rect)" " - " "NOT IMPLEMENTED") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Rect", *args[1 -1]);
        pdg::Rect rect = v8_ValueToRect(args[1 -1]);
        int trackingRef = self->startTrackingMouse(rect);
        return scope.Close( v8::Integer::New(trackingRef) );
    }

    v8::Handle<v8::Value> PortWrap::StopTrackingMouse(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] trackingRef)" " - " "NOT IMPLEMENTED") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""trackingRef"")");
        long trackingRef = args[1 -1]->Int32Value();
        self->stopTrackingMouse(trackingRef);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::SetCursor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Image] cursorImage, [object Point] hotSpot)" " - " "NOT IMPLEMENTED") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        REQUIRE_NATIVE_OBJECT_ARG(1, cursorImage, Image);
        if (!v8_ValueIsPoint(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Point", *args[2 -1]);
        pdg::Point hotSpot = v8_ValueToPoint(args[2 -1]);
        self->setCursor(cursorImage, hotSpot);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> PortWrap::GetCursor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Image]" " function" "()" " - " "NOT IMPLEMENTED: get the Image that is being used as the cursor") );
        };

        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Image* cursorImage = self->getCursor();
        if (!cursorImage) return scope.Close( v8::Null() );
        if (cursorImage->mImageScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = ImageWrap::NewFromNative(cursorImage);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( cursorImage->mImageScriptObj );
        };
    }

    v8::Handle<v8::Value> PortWrap::ResetCursor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        PortWrap* objWrapper = jswrap::ObjectWrap::Unwrap<PortWrap>(args.This());
        Port* self = dynamic_cast<Port*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "NOT IMPLEMENTED: restore the default system cursor") );
        };

        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->resetCursor();
        return scope.Close( v8::Undefined() );
    }

    void CleanupPortScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                PortWrap* obj__=jswrap::ObjectWrap::Unwrap<PortWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<PortWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Port""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Port""\n";
                }
            }
            else
            {
                Port* obj = dynamic_cast<Port*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Port"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Port" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }
#endif

#ifndef PDG_NO_SOUND

    static bool s_SoundManager_InNewFromNative = false;

    v8::Handle<v8::Value> SoundManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundManagerWrap* objWrapper = new SoundManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> SoundManagerWrap::instance_;
    bool SoundManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> SoundManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    SoundManager* SoundManagerWrap::getSingletonInstance()
    {
        v8::Handle<v8::Object> val =
            GetScriptSingletonInstance()->ToObject();
        SoundManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundManagerWrap>(val);
        return dynamic_cast<SoundManager*>(objWrapper->refPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> SoundManagerWrap::constructorTpl_;

    void SoundManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("SoundManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> SetVolume_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVolume_Tpl =
            v8::FunctionTemplate::New(SetVolume, v8::Handle<v8::Value>(), SetVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setVolume"), SetVolume_Tpl);
        v8::Local<v8::Signature> SetMute_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMute_Tpl =
            v8::FunctionTemplate::New(SetMute, v8::Handle<v8::Value>(), SetMute_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setMute"), SetMute_Tpl);
        target->Set(v8::String::NewSymbol("SoundManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> SoundManagerWrap::SetVolume(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundManagerWrap>(args.This());
        SoundManager* self = dynamic_cast<SoundManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number level)" " - " "0.0 - silent to 1.0 - full volume") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""level"")");
        double level = args[1 -1]->NumberValue();
        self->setVolume(level);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundManagerWrap::SetMute(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundManagerWrap>(args.This());
        SoundManager* self = dynamic_cast<SoundManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean muted)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""muted"")");
        bool muted = args[1 -1]->BooleanValue();
        self->setMute(muted);
        return scope.Close( v8::Undefined() );
    }

    SoundManager* New_SoundManager(const v8::Arguments& args)
    {
        if (s_SoundManager_InNewFromNative) return 0;
        return SoundManager::getSingletonInstance();
    }

    static bool s_Sound_InNewFromNative = false;

    v8::Handle<v8::Value> SoundWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = new SoundWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> SoundWrap::NewFromNative(Sound* nativeObj)
    {
        s_Sound_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(obj);

        nativeObj->mEventEmitterScriptObj = obj; nativeObj->mSoundScriptObj = obj; nativeObj->addRef();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Sound_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> SoundWrap::constructorTpl_;

    void SoundWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Sound"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(AddHandler, v8::Handle<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addHandler"), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(RemoveHandler, v8::Handle<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeHandler"), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(Clear, v8::Handle<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clear"), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(BlockEvent, v8::Handle<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("blockEvent"), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(UnblockEvent, v8::Handle<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unblockEvent"), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetVolume_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetVolume_Tpl =
            v8::FunctionTemplate::New(GetVolume, v8::Handle<v8::Value>(), GetVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Volume"), GetVolume_Tpl);
        v8::Local<v8::Signature> SetVolume_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVolume_Tpl =
            v8::FunctionTemplate::New(SetVolume, v8::Handle<v8::Value>(), SetVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Volume"), SetVolume_Tpl);
        v8::Local<v8::Signature> Play_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Play_Tpl =
            v8::FunctionTemplate::New(Play, v8::Handle<v8::Value>(), Play_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("play"), Play_Tpl);
        v8::Local<v8::Signature> Start_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Start_Tpl =
            v8::FunctionTemplate::New(Start, v8::Handle<v8::Value>(), Start_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("start"), Start_Tpl);
        v8::Local<v8::Signature> Stop_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Stop_Tpl =
            v8::FunctionTemplate::New(Stop, v8::Handle<v8::Value>(), Stop_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stop"), Stop_Tpl);
        v8::Local<v8::Signature> Pause_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Pause_Tpl =
            v8::FunctionTemplate::New(Pause, v8::Handle<v8::Value>(), Pause_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("pause"), Pause_Tpl);
        v8::Local<v8::Signature> Resume_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Resume_Tpl =
            v8::FunctionTemplate::New(Resume, v8::Handle<v8::Value>(), Resume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resume"), Resume_Tpl);
        v8::Local<v8::Signature> IsPaused_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsPaused_Tpl =
            v8::FunctionTemplate::New(IsPaused, v8::Handle<v8::Value>(), IsPaused_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isPaused"), IsPaused_Tpl);
        v8::Local<v8::Signature> SetLooping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetLooping_Tpl =
            v8::FunctionTemplate::New(SetLooping, v8::Handle<v8::Value>(), SetLooping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setLooping"), SetLooping_Tpl);
        v8::Local<v8::Signature> IsLooping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsLooping_Tpl =
            v8::FunctionTemplate::New(IsLooping, v8::Handle<v8::Value>(), IsLooping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isLooping"), IsLooping_Tpl);
        v8::Local<v8::Signature> SetPitch_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetPitch_Tpl =
            v8::FunctionTemplate::New(SetPitch, v8::Handle<v8::Value>(), SetPitch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setPitch"), SetPitch_Tpl);
        v8::Local<v8::Signature> ChangePitch_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangePitch_Tpl =
            v8::FunctionTemplate::New(ChangePitch, v8::Handle<v8::Value>(), ChangePitch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changePitch"), ChangePitch_Tpl);
        v8::Local<v8::Signature> SetOffsetX_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetOffsetX_Tpl =
            v8::FunctionTemplate::New(SetOffsetX, v8::Handle<v8::Value>(), SetOffsetX_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setOffsetX"), SetOffsetX_Tpl);
        v8::Local<v8::Signature> ChangeOffsetX_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeOffsetX_Tpl =
            v8::FunctionTemplate::New(ChangeOffsetX, v8::Handle<v8::Value>(), ChangeOffsetX_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeOffsetX"), ChangeOffsetX_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(FadeOut, v8::Handle<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeOut"), FadeOut_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(FadeIn, v8::Handle<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeIn"), FadeIn_Tpl);
        v8::Local<v8::Signature> ChangeVolume_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeVolume_Tpl =
            v8::FunctionTemplate::New(ChangeVolume, v8::Handle<v8::Value>(), ChangeVolume_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeVolume"), ChangeVolume_Tpl);
        v8::Local<v8::Signature> Skip_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Skip_Tpl =
            v8::FunctionTemplate::New(Skip, v8::Handle<v8::Value>(), Skip_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("skip"), Skip_Tpl);
        v8::Local<v8::Signature> SkipTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SkipTo_Tpl =
            v8::FunctionTemplate::New(SkipTo, v8::Handle<v8::Value>(), SkipTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("skipTo"), SkipTo_Tpl);
        target->Set(v8::String::NewSymbol("Sound"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> SoundWrap::AddHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::RemoveHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                "If the handler is listed multiple times it will only remove it once.\n"
                "NOTE: inType == all_events doesn't work quite like you might expect. If "
                "you have registered a handler for multiple events, but not with all_events, "
                "doing removeHandler(handler, all_events) will do nothing. Basically, "
                "all_events is a special event type that matches all event types when "
                "considering whether to invoke a handler or not.\n"
                "It is safe to call remove handler from within an event handler's handleEvent() call."
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::Clear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "remove all handlers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clear();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::BlockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                "Events that are blocked are NOT cached for later, they are just dropped."
                " \\param inEventType the type of event to block") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::UnblockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                " \\param inEventType the type of event to unblock") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::GetVolume(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theVolume = self->getVolume();
        return scope.Close( v8::Number::New(theVolume) );
    }

    v8::Handle<v8::Value> SoundWrap::SetVolume(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sound" " function" "(number inVolume)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theVolume"")");
        double theVolume = args[1 -1]->NumberValue();

        self->setVolume(theVolume);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SoundWrap::Play(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number vol = 1.0, [number int] offsetX = 0, number pitch = 0, [number uint] fromMs = 0, [number int] lenMs = ENTIRE_LENGTH)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""vol"")");
        double vol = (args.Length()<1) ? 1.0 : args[1 -1]->NumberValue();;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""offsetX"")");
        long offsetX = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""pitch"")");
        double pitch = (args.Length()<3) ? 0.0 : args[3 -1]->NumberValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""fromMs"")");
        unsigned long fromMs = (args.Length()<4) ? 0 : args[4 -1]->Uint32Value();;
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""lenMs"")");
        long lenMs = (args.Length()<5) ? -1 : args[5 -1]->Int32Value();;
        self->play(vol, offsetX, pitch, fromMs, lenMs);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::Start(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->start();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::Stop(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stop();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::Pause(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->pause();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::Resume(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->resume();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::IsPaused(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        bool result = self->isPaused();
        return scope.Close( v8::Boolean::New(result) );
    }

    v8::Handle<v8::Value> SoundWrap::SetLooping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sound" " function" "(boolean loopingOn)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""loopingOn"")");
        bool loopingOn = args[1 -1]->BooleanValue();
        self->setLooping(loopingOn);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SoundWrap::IsLooping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        bool result = self->isLooping();
        return scope.Close( v8::Boolean::New(result) );
    }

    v8::Handle<v8::Value> SoundWrap::SetPitch(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sound" " function" "(number pitchOffset)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""pitchOffset"")");
        double pitchOffset = args[1 -1]->NumberValue();
        self->setPitch(pitchOffset);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SoundWrap::ChangePitch(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number targetOffset, [number int] msDuration, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""targetOffset"")");
        double targetOffset = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changePitch(targetOffset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changePitch(targetOffset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::SetOffsetX(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sound" " function" "([number int] offsetX)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""offsetX"")");
        long offsetX = args[1 -1]->Int32Value();
        self->setOffsetX(offsetX);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SoundWrap::ChangeOffsetX(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] targetOffset, [number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""targetOffset"")");
        long targetOffset = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changePitch(targetOffset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changePitch(targetOffset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::FadeOut(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] fadeMs, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""fadeMs"")");
        unsigned long fadeMs = args[1 -1]->Uint32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(fadeMs, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(fadeMs);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::FadeIn(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] fadeMs, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""fadeMs"")");
        unsigned long fadeMs = args[1 -1]->Uint32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(fadeMs, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(fadeMs);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::ChangeVolume(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number level, [number uint] fadeMs, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""level"")");
        double level = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""fadeMs"")");
        unsigned long fadeMs = args[2 -1]->Uint32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeVolume(level, fadeMs, gEasingFunctions[easing]);
        }
        else
        {
            self->changeVolume(level, fadeMs);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SoundWrap::Skip(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sound" " function" "([number int] skipMilliseconds)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""skipMilliseconds"")");
        long skipMilliseconds = args[1 -1]->Int32Value();
        self->skip(skipMilliseconds);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SoundWrap::SkipTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SoundWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SoundWrap>(args.This());
        Sound* self = dynamic_cast<Sound*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sound" " function" "([number uint] timeMs)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""timeMs"")");
        unsigned long timeMs = args[1 -1]->Uint32Value();
        self->skipTo(timeMs);
        return scope.Close( args.This() );
    }

    void CleanupSoundScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                SoundWrap* obj__=jswrap::ObjectWrap::Unwrap<SoundWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<SoundWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Sound""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Sound""\n";
                }
            }
            else
            {
                Sound* obj = dynamic_cast<Sound*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Sound"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Sound" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    Sound* New_Sound(const v8::Arguments& args)
    {
        if (s_Sound_InNewFromNative) return 0;
        ;
        if (args.Length() < 1)
        {
            return 0;
        }
        else if (!args[0]->IsString())
        {
            s_HaveSavedError = true;
            std::ostringstream excpt_;
            excpt_ << "argument 1 must be a string (filename)";
            s_SavedError = s_SavedError.New(v8::Exception::SyntaxError( v8::String::New(excpt_.str().c_str())));
            return 0;
        }
        else
        {
            v8::String::Utf8Value filename_Str(args[0]->ToString());
            const char* filename = *filename_Str;;
            return Sound::createSoundFromFile(filename);
        }
    }
#endif

    ;
    ;
    ;

    v8::Handle<v8::Value> FileManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        FileManagerWrap* objWrapper = new FileManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> FileManagerWrap::instance_;
    bool FileManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> FileManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    v8::Persistent<v8::FunctionTemplate> FileManagerWrap::constructorTpl_;

    void FileManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("FileManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> FindFirst_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FindFirst_Tpl =
            v8::FunctionTemplate::New(FindFirst, v8::Handle<v8::Value>(), FindFirst_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("findFirst"), FindFirst_Tpl);
        v8::Local<v8::Signature> FindNext_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FindNext_Tpl =
            v8::FunctionTemplate::New(FindNext, v8::Handle<v8::Value>(), FindNext_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("findNext"), FindNext_Tpl);
        v8::Local<v8::Signature> FindClose_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FindClose_Tpl =
            v8::FunctionTemplate::New(FindClose, v8::Handle<v8::Value>(), FindClose_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("findClose"), FindClose_Tpl);
        v8::Local<v8::Signature> GetApplicationDataDirectory_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetApplicationDataDirectory_Tpl =
            v8::FunctionTemplate::New(GetApplicationDataDirectory, v8::Handle<v8::Value>(), GetApplicationDataDirectory_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""ApplicationDataDirectory"), GetApplicationDataDirectory_Tpl);
        v8::Local<v8::Signature> GetApplicationDirectory_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetApplicationDirectory_Tpl =
            v8::FunctionTemplate::New(GetApplicationDirectory, v8::Handle<v8::Value>(), GetApplicationDirectory_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""ApplicationDirectory"), GetApplicationDirectory_Tpl);
        v8::Local<v8::Signature> GetApplicationResourceDirectory_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetApplicationResourceDirectory_Tpl =
            v8::FunctionTemplate::New(GetApplicationResourceDirectory, v8::Handle<v8::Value>(), GetApplicationResourceDirectory_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""ApplicationResourceDirectory"), GetApplicationResourceDirectory_Tpl);
        target->Set(v8::String::NewSymbol("FileManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> FileManagerWrap::FindFirst(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("object" " function" "(string inFindName)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inFindName"")");
        v8::String::Utf8Value inFindName_Str(args[1 -1]->ToString());
        const char* inFindName = *inFindName_Str;;
        FindDataT* ioFindDataPtr = new FindDataT;
        bool found = OS::findFirst(inFindName, *ioFindDataPtr);
        v8::Handle<v8::Object> jsFindData = v8_ObjectCreateEmpty(ioFindDataPtr);
        v8::Local<v8::Value> nodeName = v8::String::New(ioFindDataPtr->nodeName);
        jsFindData->Set(v8::String::NewSymbol("nodeName"), nodeName);
        jsFindData->Set(v8::String::NewSymbol("isDirectory"), v8::Boolean::New(ioFindDataPtr->isDirectory));
        jsFindData->Set(v8::String::NewSymbol("found"), v8::Boolean::New(found));
        return scope.Close( jsFindData );
    }
    v8::Handle<v8::Value> FileManagerWrap::FindNext(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("object" " function" "(object inFindData)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_OBJECT_ARG(1, jsFindData);
        FindDataT* ioFindDataPtr = static_cast<FindDataT*>(jsFindData->GetPointerFromInternalField(0));
        if (!ioFindDataPtr)
        {
            std::ostringstream excpt_;
            excpt_ << "findNext must only be called with the object returned by findFirst";
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str())));
        }
        bool found = OS::findNext(*ioFindDataPtr);
        v8::Local<v8::Value> nodeName = v8::String::New(ioFindDataPtr->nodeName);
        jsFindData->Set(v8::String::NewSymbol("nodeName"), nodeName);
        jsFindData->Set(v8::String::NewSymbol("isDirectory"), v8::Boolean::New(ioFindDataPtr->isDirectory));
        jsFindData->Set(v8::String::NewSymbol("found"), v8::Boolean::New(found));
        return scope.Close( v8::Boolean::New(found) );
    }
    v8::Handle<v8::Value> FileManagerWrap::FindClose(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(object inFindData)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_OBJECT_ARG(1, jsFindData);
        FindDataT* ioFindDataPtr = static_cast<FindDataT*>(jsFindData->GetPointerFromInternalField(0));
        if (!ioFindDataPtr)
        {
            std::ostringstream excpt_;
            excpt_ << "findClose must only be called with the object returned by findFirst";
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str())));
        }
        OS::findClose(*ioFindDataPtr);
        delete ioFindDataPtr;
        return scope.Close( v8::Undefined() );
    }
    v8::Handle<v8::Value> FileManagerWrap::GetApplicationDataDirectory(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        return scope.Close( v8::String::New(OS::getApplicationDataDirectory()) );
    }
    v8::Handle<v8::Value> FileManagerWrap::GetApplicationDirectory(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        return scope.Close( v8::String::New(OS::getApplicationDirectory()) );
    }
    v8::Handle<v8::Value> FileManagerWrap::GetApplicationResourceDirectory(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        return scope.Close( v8::String::New(OS::getApplicationResourceDirectory()) );
    }

    static bool s_TimerManager_InNewFromNative = false;

    v8::Handle<v8::Value> TimerManagerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = new TimerManagerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Persistent<v8::Object> TimerManagerWrap::instance_;
    bool TimerManagerWrap::instanced_ = false;

    v8::Handle<v8::Object> TimerManagerWrap::GetScriptSingletonInstance()
    {
        v8::HandleScope scope;
        if (!instanced_)
        {
            v8::Local<v8::Object> instance =
                constructorTpl_->GetFunction()->NewInstance();
            instance_ = v8::Persistent<v8::Object>::New(instance);
            instanced_ = true;
        }
        return scope.Close(instance_);
    }

    TimerManager* TimerManagerWrap::getSingletonInstance()
    {
        v8::Handle<v8::Object> val =
            GetScriptSingletonInstance()->ToObject();
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(val);
        return dynamic_cast<TimerManager*>(objWrapper->refPtr_);
    }

    v8::Persistent<v8::FunctionTemplate> TimerManagerWrap::constructorTpl_;

    void TimerManagerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("TimerManager"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(AddHandler, v8::Handle<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addHandler"), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(RemoveHandler, v8::Handle<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeHandler"), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(Clear, v8::Handle<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clear"), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(BlockEvent, v8::Handle<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("blockEvent"), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(UnblockEvent, v8::Handle<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unblockEvent"), UnblockEvent_Tpl);
        v8::Local<v8::Signature> StartTimer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartTimer_Tpl =
            v8::FunctionTemplate::New(StartTimer, v8::Handle<v8::Value>(), StartTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startTimer"), StartTimer_Tpl);
        v8::Local<v8::Signature> CancelTimer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CancelTimer_Tpl =
            v8::FunctionTemplate::New(CancelTimer, v8::Handle<v8::Value>(), CancelTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("cancelTimer"), CancelTimer_Tpl);
        v8::Local<v8::Signature> CancelAllTimers_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CancelAllTimers_Tpl =
            v8::FunctionTemplate::New(CancelAllTimers, v8::Handle<v8::Value>(), CancelAllTimers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("cancelAllTimers"), CancelAllTimers_Tpl);
        v8::Local<v8::Signature> DelayTimer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DelayTimer_Tpl =
            v8::FunctionTemplate::New(DelayTimer, v8::Handle<v8::Value>(), DelayTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("delayTimer"), DelayTimer_Tpl);
        v8::Local<v8::Signature> DelayTimerUntil_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DelayTimerUntil_Tpl =
            v8::FunctionTemplate::New(DelayTimerUntil, v8::Handle<v8::Value>(), DelayTimerUntil_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("delayTimerUntil"), DelayTimerUntil_Tpl);
        v8::Local<v8::Signature> Pause_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Pause_Tpl =
            v8::FunctionTemplate::New(Pause, v8::Handle<v8::Value>(), Pause_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("pause"), Pause_Tpl);
        v8::Local<v8::Signature> Unpause_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Unpause_Tpl =
            v8::FunctionTemplate::New(Unpause, v8::Handle<v8::Value>(), Unpause_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unpause"), Unpause_Tpl);
        v8::Local<v8::Signature> IsPaused_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsPaused_Tpl =
            v8::FunctionTemplate::New(IsPaused, v8::Handle<v8::Value>(), IsPaused_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isPaused"), IsPaused_Tpl);
        v8::Local<v8::Signature> PauseTimer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PauseTimer_Tpl =
            v8::FunctionTemplate::New(PauseTimer, v8::Handle<v8::Value>(), PauseTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("pauseTimer"), PauseTimer_Tpl);
        v8::Local<v8::Signature> UnpauseTimer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnpauseTimer_Tpl =
            v8::FunctionTemplate::New(UnpauseTimer, v8::Handle<v8::Value>(), UnpauseTimer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unpauseTimer"), UnpauseTimer_Tpl);
        v8::Local<v8::Signature> IsTimerPaused_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsTimerPaused_Tpl =
            v8::FunctionTemplate::New(IsTimerPaused, v8::Handle<v8::Value>(), IsTimerPaused_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isTimerPaused"), IsTimerPaused_Tpl);
        v8::Local<v8::Signature> GetWhenTimerFiresNext_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWhenTimerFiresNext_Tpl =
            v8::FunctionTemplate::New(GetWhenTimerFiresNext, v8::Handle<v8::Value>(), GetWhenTimerFiresNext_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getWhenTimerFiresNext"), GetWhenTimerFiresNext_Tpl);
        v8::Local<v8::Signature> GetMilliseconds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMilliseconds_Tpl =
            v8::FunctionTemplate::New(GetMilliseconds, v8::Handle<v8::Value>(), GetMilliseconds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getMilliseconds"), GetMilliseconds_Tpl);
        target->Set(v8::String::NewSymbol("TimerManager"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> TimerManagerWrap::AddHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::RemoveHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                "If the handler is listed multiple times it will only remove it once.\n"
                "NOTE: inType == all_events doesn't work quite like you might expect. If "
                "you have registered a handler for multiple events, but not with all_events, "
                "doing removeHandler(handler, all_events) will do nothing. Basically, "
                "all_events is a special event type that matches all event types when "
                "considering whether to invoke a handler or not.\n"
                "It is safe to call remove handler from within an event handler's handleEvent() call."
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::Clear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "remove all handlers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clear();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::BlockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                "Events that are blocked are NOT cached for later, they are just dropped."
                " \\param inEventType the type of event to block") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::UnblockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                " \\param inEventType the type of event to unblock") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::StartTimer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] id, [number uint] delay, boolean oneShot = true)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""delay"")");
        unsigned long delay = args[2 -1]->Uint32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            return v8_ThrowArgTypeException(3, "a boolean (""oneShot"")");
        bool oneShot = (args.Length()<3) ? true : args[3 -1]->BooleanValue();;
        self->startTimer(id, delay, oneShot);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::CancelTimer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] id)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        self->cancelTimer(id);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::CancelAllTimers(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->cancelAllTimers();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::DelayTimer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] id, [number uint] delay)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""delay"")");
        unsigned long delay = args[2 -1]->Uint32Value();
        self->delayTimer(id, delay);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::DelayTimerUntil(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] id, [number uint] msTime)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msTime"")");
        unsigned long msTime = args[2 -1]->Uint32Value();
        self->delayTimerUntil(id, msTime);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::Pause(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->pause();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::Unpause(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->unpause();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::IsPaused(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        bool isPaused = self->isPaused();
        return scope.Close( v8::Boolean::New(isPaused) );
    }

    v8::Handle<v8::Value> TimerManagerWrap::PauseTimer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] id)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        self->pauseTimer(id);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::UnpauseTimer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] id)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        self->unpauseTimer(id);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TimerManagerWrap::IsTimerPaused(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([number int] id)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        bool isPaused = self->isTimerPaused(id);
        return scope.Close( v8::Boolean::New(isPaused) );
    }

    v8::Handle<v8::Value> TimerManagerWrap::GetWhenTimerFiresNext(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TimerManagerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TimerManagerWrap>(args.This());
        TimerManager* self = dynamic_cast<TimerManager*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([number int] id)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        uint32 when = self->getWhenTimerFiresNext(id);
        return scope.Close( v8::Integer::NewFromUnsigned(when) );
    }
    v8::Handle<v8::Value> TimerManagerWrap::GetMilliseconds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        return scope.Close( v8::Integer::NewFromUnsigned(OS::getMilliseconds()) );
    }

    TimerManager* New_TimerManager(const v8::Arguments& args)
    {
        if (s_TimerManager_InNewFromNative) return 0;
        return TimerManager::getSingletonInstance();
    }

    float customEasing0(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(0, ut, b, c, ud);
    }

    float customEasing1(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(1, ut, b, c, ud);
    }

    float customEasing2(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(2, ut, b, c, ud);
    }

    float customEasing3(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(3, ut, b, c, ud);
    }

    float customEasing4(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(4, ut, b, c, ud);
    }

    float customEasing5(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(5, ut, b, c, ud);
    }

    float customEasing6(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(6, ut, b, c, ud);
    }

    float customEasing7(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(7, ut, b, c, ud);
    }

    float customEasing8(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(8, ut, b, c, ud);
    }

    float customEasing9(uint32 ut, float b, float c, uint32 ud)
    {
        return CallScriptEasingFunc(9, ut, b, c, ud);
    }

    static bool s_IAnimationHelper_InNewFromNative = false;

    v8::Handle<v8::Value> IAnimationHelperWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        IAnimationHelperWrap* objWrapper = new IAnimationHelperWrap(args);
        objWrapper->Wrap(args.This());
        IAnimationHelper* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mIAnimationHelperScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> IAnimationHelperWrap::NewFromNative(IAnimationHelper* nativeObj)
    {
        s_IAnimationHelper_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        IAnimationHelperWrap* objWrapper = jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj);

        nativeObj->mIAnimationHelperScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_IAnimationHelper_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> IAnimationHelperWrap::constructorTpl_;

    void IAnimationHelperWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("IAnimationHelper"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        target->Set(v8::String::NewSymbol("IAnimationHelper"), constructorTpl_->GetFunction());
    }

    void CleanupIAnimationHelperScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "IAnimationHelper" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    static bool s_Animated_InNewFromNative = false;

    v8::Handle<v8::Value> AnimatedWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = new AnimatedWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> AnimatedWrap::NewFromNative(Animated* nativeObj)
    {
        s_Animated_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(obj);

        nativeObj->mAnimatedScriptObj = obj;
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Animated_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> AnimatedWrap::constructorTpl_;

    void AnimatedWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Animated"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(GetBoundingBox, v8::Handle<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""BoundingBox"), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(GetRotatedBounds, v8::Handle<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RotatedBounds"), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(GetLocation, v8::Handle<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Location"), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(SetLocation, v8::Handle<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Location"), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(GetSpeed, v8::Handle<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Speed"), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(SetSpeed, v8::Handle<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Speed"), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(GetVelocity, v8::Handle<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Velocity"), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(SetVelocity, v8::Handle<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Velocity"), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(GetWidth, v8::Handle<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Width"), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(SetWidth, v8::Handle<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Width"), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(GetHeight, v8::Handle<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Height"), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(SetHeight, v8::Handle<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Height"), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(GetRotation, v8::Handle<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Rotation"), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(SetRotation, v8::Handle<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Rotation"), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(GetCenterOffset, v8::Handle<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""CenterOffset"), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(SetCenterOffset, v8::Handle<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""CenterOffset"), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(GetSpin, v8::Handle<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Spin"), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(SetSpin, v8::Handle<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Spin"), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(GetMass, v8::Handle<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Mass"), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(SetMass, v8::Handle<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Mass"), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(GetMoveFriction, v8::Handle<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MoveFriction"), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(SetMoveFriction, v8::Handle<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MoveFriction"), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(GetSpinFriction, v8::Handle<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SpinFriction"), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(SetSpinFriction, v8::Handle<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SpinFriction"), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(GetSizeFriction, v8::Handle<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SizeFriction"), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(SetSizeFriction, v8::Handle<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SizeFriction"), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(Move, v8::Handle<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("move"), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(MoveTo, v8::Handle<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveTo"), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(SetVelocityInRadians, v8::Handle<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setVelocityInRadians"), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(GetMovementDirectionInRadians, v8::Handle<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getMovementDirectionInRadians"), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(StopMoving, v8::Handle<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopMoving"), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(Accelerate, v8::Handle<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerate"), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(AccelerateTo, v8::Handle<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerateTo"), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(SetSize, v8::Handle<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSize"), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(Grow, v8::Handle<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("grow"), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(Stretch, v8::Handle<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stretch"), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(StartGrowing, v8::Handle<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startGrowing"), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(StopGrowing, v8::Handle<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopGrowing"), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(StartStretching, v8::Handle<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startStretching"), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(StopStretching, v8::Handle<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopStretching"), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(Resize, v8::Handle<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resize"), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(ResizeTo, v8::Handle<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resizeTo"), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(Rotate, v8::Handle<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotate"), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(RotateTo, v8::Handle<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotateTo"), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(StopSpinning, v8::Handle<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopSpinning"), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(ChangeCenter, v8::Handle<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenter"), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(ChangeCenterTo, v8::Handle<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenterTo"), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(Wait, v8::Handle<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("wait"), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(SetFriction, v8::Handle<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFriction"), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(ApplyForce, v8::Handle<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyForce"), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(ApplyTorque, v8::Handle<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyTorque"), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(StopAllForces, v8::Handle<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopAllForces"), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(AddAnimationHelper, v8::Handle<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addAnimationHelper"), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(RemoveAnimationHelper, v8::Handle<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeAnimationHelper"), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(ClearAnimationHelpers, v8::Handle<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clearAnimationHelpers"), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> Animate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Animate_Tpl =
            v8::FunctionTemplate::New(Animate, v8::Handle<v8::Value>(), Animate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("animate"), Animate_Tpl);
        target->Set(v8::String::NewSymbol("Animated"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> AnimatedWrap::GetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        return scope.Close( v8_MakeJavascriptPoint(theLocation) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "([object Point] inLocation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(args[1 -1]);

        self->setLocation(theLocation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpeed = self->getSpeed();
        return scope.Close( v8::Number::New(theSpeed) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inSpeed)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theWidth = self->getWidth();
        return scope.Close( v8::Number::New(theWidth) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inWidth)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theHeight = self->getHeight();
        return scope.Close( v8::Number::New(theHeight) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inHeight)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theRotation = self->getRotation();
        return scope.Close( v8::Number::New(theRotation) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inRotation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        return scope.Close( v8_MakeJavascriptOffset(theCenterOffset) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "([object Offset] inCenterOffset)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpin = self->getSpin();
        return scope.Close( v8::Number::New(theSpin) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inSpin)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMass = self->getMass();
        return scope.Close( v8::Number::New(theMass) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inMass)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        return scope.Close( v8::Number::New(theMoveFriction) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inMoveFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        return scope.Close( v8::Number::New(theSpinFriction) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inSpinFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        return scope.Close( v8::Number::New(theSizeFriction) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Animated" " function" "(number inSizeFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetBoundingBox(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetRotatedBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> AnimatedWrap::Move(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            delta = v8_ValueToOffset(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::MoveTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(args[0]))
        {
            where = v8_ValueToPoint(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetVelocityInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number speed, number direction)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetMovementDirectionInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        return scope.Close( v8::Number::New(dir) );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "({ ([object Vector] deltaPerSec) | (number deltaXPerSec, number deltaYPerSec) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(args[0]))
        {
            deltaPerSec = v8_ValueToVector(args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::GetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        return scope.Close( v8_MakeJavascriptVector(theVelocity) );
    }

    v8::Handle<v8::Value> AnimatedWrap::StopMoving(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopMoving();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::Accelerate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::AccelerateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number width, number height)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::Grow(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::Stretch(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::StartGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number amountPerSecond)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::StopGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopGrowing();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::StartStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::StopStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopStretching();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::Resize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::ResizeTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::Rotate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::RotateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::StopSpinning(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopSpinning();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::ChangeCenter(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::ChangeCenterTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::Wait(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "([number int] msDuration)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::SetFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number frictionCoefficient)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> AnimatedWrap::ApplyForce(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::ApplyTorque(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::StopAllForces(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopAllForces();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::AddAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        self->mAnimatedScriptObj = v8::Persistent<v8::Object>::New(args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::RemoveAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::ClearAnimationHelpers(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clearAnimationHelpers();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> AnimatedWrap::Animate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        AnimatedWrap* objWrapper = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(args.This());
        Animated* self = dynamic_cast<Animated*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([number int] msElapsed)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msElapsed"")");
        long msElapsed = args[1 -1]->Int32Value();
        bool result = self->animate(msElapsed);
        return scope.Close( v8::Boolean::New(result) );
    }

    void CleanupAnimatedScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                AnimatedWrap* obj__=jswrap::ObjectWrap::Unwrap<AnimatedWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<AnimatedWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Animated""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Animated""\n";
                }
            }
            else
            {
                Animated* obj = dynamic_cast<Animated*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Animated"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Animated" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    Animated* New_Animated(const v8::Arguments& args)
    {
        if (s_Animated_InNewFromNative) return 0;
        return new Animated();
    }

#ifdef PDG_USE_CHIPMUNK_PHYSICS

    static bool s_cpArbiter_InNewFromNative = false;

    v8::Handle<v8::Value> cpArbiterWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpArbiterWrap* objWrapper = new cpArbiterWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> cpArbiterWrap::NewFromNative(cpArbiter* nativeObj)
    {
        s_cpArbiter_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(obj);

        ;
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_cpArbiter_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> cpArbiterWrap::constructorTpl_;

    void cpArbiterWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("CpArbiter"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> IsFirstContact_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsFirstContact_Tpl =
            v8::FunctionTemplate::New(IsFirstContact, v8::Handle<v8::Value>(), IsFirstContact_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isFirstContact"), IsFirstContact_Tpl);
        v8::Local<v8::Signature> GetCount_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCount_Tpl =
            v8::FunctionTemplate::New(GetCount, v8::Handle<v8::Value>(), GetCount_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Count"), GetCount_Tpl);
        v8::Local<v8::Signature> GetNormal_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetNormal_Tpl =
            v8::FunctionTemplate::New(GetNormal, v8::Handle<v8::Value>(), GetNormal_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Normal"), GetNormal_Tpl);
        v8::Local<v8::Signature> GetPoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetPoint_Tpl =
            v8::FunctionTemplate::New(GetPoint, v8::Handle<v8::Value>(), GetPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Point"), GetPoint_Tpl);
        v8::Local<v8::Signature> GetDepth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetDepth_Tpl =
            v8::FunctionTemplate::New(GetDepth, v8::Handle<v8::Value>(), GetDepth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Depth"), GetDepth_Tpl);
        target->Set(v8::String::NewSymbol("CpArbiter"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> cpArbiterWrap::IsFirstContact(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "true if this is the first moment of contact between the objects, false if part of an ongoing collison") );
        };

        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        cpBool isFirst = cpArbiterIsFirstContact(self);
        return scope.Close( v8::Boolean::New(isFirst) );
    }

    v8::Handle<v8::Value> cpArbiterWrap::GetCount(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        int theCount = cpArbiterGetCount(self);
        return scope.Close( v8::Integer::New(theCount) );
    }

    v8::Handle<v8::Value> cpArbiterWrap::GetNormal(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "([number int] i)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""i"")");
        long i = args[1 -1]->Int32Value();

        cpVect normal = cpArbiterGetNormal(self, i);
        pdg::Vector theNormal(normal.x, normal.y);
        return scope.Close( v8_MakeJavascriptVector(theNormal) );
    }

    v8::Handle<v8::Value> cpArbiterWrap::GetPoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "([number int] i)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""i"")");
        long i = args[1 -1]->Int32Value();

        cpVect pt = cpArbiterGetPoint(self, i);
        pdg::Point thePoint(pt.x, pt.y);
        return scope.Close( v8_MakeJavascriptPoint(thePoint) );
    }

    v8::Handle<v8::Value> cpArbiterWrap::GetDepth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpArbiterWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpArbiterWrap>(args.This());
        cpArbiter* self = dynamic_cast<cpArbiter*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([number int] i)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""i"")");
        long i = args[1 -1]->Int32Value();

        cpFloat theDepth = cpArbiterGetDepth(self, i);
        return scope.Close( v8::Number::New(theDepth) );
    }

    static bool s_cpConstraint_InNewFromNative = false;

    v8::Handle<v8::Value> cpConstraintWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = new cpConstraintWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> cpConstraintWrap::NewFromNative(cpConstraint* nativeObj)
    {
        s_cpConstraint_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(obj);

        ;
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_cpConstraint_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> cpConstraintWrap::constructorTpl_;

    void cpConstraintWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("CpConstraint"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> GetType_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetType_Tpl =
            v8::FunctionTemplate::New(GetType, v8::Handle<v8::Value>(), GetType_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Type"), GetType_Tpl);
        v8::Local<v8::Signature> ActivateBodies_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ActivateBodies_Tpl =
            v8::FunctionTemplate::New(ActivateBodies, v8::Handle<v8::Value>(), ActivateBodies_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("activateBodies"), ActivateBodies_Tpl);
        v8::Local<v8::Signature> GetImpulse_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetImpulse_Tpl =
            v8::FunctionTemplate::New(GetImpulse, v8::Handle<v8::Value>(), GetImpulse_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Impulse"), GetImpulse_Tpl);
        v8::Local<v8::Signature> GetMaxForce_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMaxForce_Tpl =
            v8::FunctionTemplate::New(GetMaxForce, v8::Handle<v8::Value>(), GetMaxForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MaxForce"), GetMaxForce_Tpl);
        v8::Local<v8::Signature> SetMaxForce_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMaxForce_Tpl =
            v8::FunctionTemplate::New(SetMaxForce, v8::Handle<v8::Value>(), SetMaxForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MaxForce"), SetMaxForce_Tpl);
        v8::Local<v8::Signature> GetErrorBias_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetErrorBias_Tpl =
            v8::FunctionTemplate::New(GetErrorBias, v8::Handle<v8::Value>(), GetErrorBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""ErrorBias"), GetErrorBias_Tpl);
        v8::Local<v8::Signature> SetErrorBias_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetErrorBias_Tpl =
            v8::FunctionTemplate::New(SetErrorBias, v8::Handle<v8::Value>(), SetErrorBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""ErrorBias"), SetErrorBias_Tpl);
        v8::Local<v8::Signature> GetMaxBias_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMaxBias_Tpl =
            v8::FunctionTemplate::New(GetMaxBias, v8::Handle<v8::Value>(), GetMaxBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MaxBias"), GetMaxBias_Tpl);
        v8::Local<v8::Signature> SetMaxBias_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMaxBias_Tpl =
            v8::FunctionTemplate::New(SetMaxBias, v8::Handle<v8::Value>(), SetMaxBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MaxBias"), SetMaxBias_Tpl);
        v8::Local<v8::Signature> GetSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSprite_Tpl =
            v8::FunctionTemplate::New(GetSprite, v8::Handle<v8::Value>(), GetSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Sprite"), GetSprite_Tpl);
        v8::Local<v8::Signature> GetOtherSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetOtherSprite_Tpl =
            v8::FunctionTemplate::New(GetOtherSprite, v8::Handle<v8::Value>(), GetOtherSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""OtherSprite"), GetOtherSprite_Tpl);
        v8::Local<v8::Signature> GetAnchor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetAnchor_Tpl =
            v8::FunctionTemplate::New(GetAnchor, v8::Handle<v8::Value>(), GetAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Anchor"), GetAnchor_Tpl);
        v8::Local<v8::Signature> SetAnchor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetAnchor_Tpl =
            v8::FunctionTemplate::New(SetAnchor, v8::Handle<v8::Value>(), SetAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Anchor"), SetAnchor_Tpl);
        v8::Local<v8::Signature> GetOtherAnchor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetOtherAnchor_Tpl =
            v8::FunctionTemplate::New(GetOtherAnchor, v8::Handle<v8::Value>(), GetOtherAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""OtherAnchor"), GetOtherAnchor_Tpl);
        v8::Local<v8::Signature> SetOtherAnchor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetOtherAnchor_Tpl =
            v8::FunctionTemplate::New(SetOtherAnchor, v8::Handle<v8::Value>(), SetOtherAnchor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""OtherAnchor"), SetOtherAnchor_Tpl);
        v8::Local<v8::Signature> GetPinDist_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetPinDist_Tpl =
            v8::FunctionTemplate::New(GetPinDist, v8::Handle<v8::Value>(), GetPinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""PinDist"), GetPinDist_Tpl);
        v8::Local<v8::Signature> SetPinDist_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetPinDist_Tpl =
            v8::FunctionTemplate::New(SetPinDist, v8::Handle<v8::Value>(), SetPinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""PinDist"), SetPinDist_Tpl);
        v8::Local<v8::Signature> GetSpringStiffness_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpringStiffness_Tpl =
            v8::FunctionTemplate::New(GetSpringStiffness, v8::Handle<v8::Value>(), GetSpringStiffness_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SpringStiffness"), GetSpringStiffness_Tpl);
        v8::Local<v8::Signature> SetSpringStiffness_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpringStiffness_Tpl =
            v8::FunctionTemplate::New(SetSpringStiffness, v8::Handle<v8::Value>(), SetSpringStiffness_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SpringStiffness"), SetSpringStiffness_Tpl);
        v8::Local<v8::Signature> GetSpringDamping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpringDamping_Tpl =
            v8::FunctionTemplate::New(GetSpringDamping, v8::Handle<v8::Value>(), GetSpringDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SpringDamping"), GetSpringDamping_Tpl);
        v8::Local<v8::Signature> SetSpringDamping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpringDamping_Tpl =
            v8::FunctionTemplate::New(SetSpringDamping, v8::Handle<v8::Value>(), SetSpringDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SpringDamping"), SetSpringDamping_Tpl);
        v8::Local<v8::Signature> GetSlideMinDist_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSlideMinDist_Tpl =
            v8::FunctionTemplate::New(GetSlideMinDist, v8::Handle<v8::Value>(), GetSlideMinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SlideMinDist"), GetSlideMinDist_Tpl);
        v8::Local<v8::Signature> SetSlideMinDist_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSlideMinDist_Tpl =
            v8::FunctionTemplate::New(SetSlideMinDist, v8::Handle<v8::Value>(), SetSlideMinDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SlideMinDist"), SetSlideMinDist_Tpl);
        v8::Local<v8::Signature> GetSlideMaxDist_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSlideMaxDist_Tpl =
            v8::FunctionTemplate::New(GetSlideMaxDist, v8::Handle<v8::Value>(), GetSlideMaxDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SlideMaxDist"), GetSlideMaxDist_Tpl);
        v8::Local<v8::Signature> SetSlideMaxDist_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSlideMaxDist_Tpl =
            v8::FunctionTemplate::New(SetSlideMaxDist, v8::Handle<v8::Value>(), SetSlideMaxDist_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SlideMaxDist"), SetSlideMaxDist_Tpl);
        v8::Local<v8::Signature> GetGrooveStart_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetGrooveStart_Tpl =
            v8::FunctionTemplate::New(GetGrooveStart, v8::Handle<v8::Value>(), GetGrooveStart_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""GrooveStart"), GetGrooveStart_Tpl);
        v8::Local<v8::Signature> SetGrooveStart_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetGrooveStart_Tpl =
            v8::FunctionTemplate::New(SetGrooveStart, v8::Handle<v8::Value>(), SetGrooveStart_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""GrooveStart"), SetGrooveStart_Tpl);
        v8::Local<v8::Signature> GetGrooveEnd_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetGrooveEnd_Tpl =
            v8::FunctionTemplate::New(GetGrooveEnd, v8::Handle<v8::Value>(), GetGrooveEnd_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""GrooveEnd"), GetGrooveEnd_Tpl);
        v8::Local<v8::Signature> SetGrooveEnd_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetGrooveEnd_Tpl =
            v8::FunctionTemplate::New(SetGrooveEnd, v8::Handle<v8::Value>(), SetGrooveEnd_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""GrooveEnd"), SetGrooveEnd_Tpl);
        v8::Local<v8::Signature> GetSpringRestLength_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpringRestLength_Tpl =
            v8::FunctionTemplate::New(GetSpringRestLength, v8::Handle<v8::Value>(), GetSpringRestLength_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SpringRestLength"), GetSpringRestLength_Tpl);
        v8::Local<v8::Signature> SetSpringRestLength_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpringRestLength_Tpl =
            v8::FunctionTemplate::New(SetSpringRestLength, v8::Handle<v8::Value>(), SetSpringRestLength_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SpringRestLength"), SetSpringRestLength_Tpl);
        v8::Local<v8::Signature> GetRotarySpringRestAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotarySpringRestAngle_Tpl =
            v8::FunctionTemplate::New(GetRotarySpringRestAngle, v8::Handle<v8::Value>(), GetRotarySpringRestAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RotarySpringRestAngle"), GetRotarySpringRestAngle_Tpl);
        v8::Local<v8::Signature> SetRotarySpringRestAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRotarySpringRestAngle_Tpl =
            v8::FunctionTemplate::New(SetRotarySpringRestAngle, v8::Handle<v8::Value>(), SetRotarySpringRestAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""RotarySpringRestAngle"), SetRotarySpringRestAngle_Tpl);
        v8::Local<v8::Signature> GetMinAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMinAngle_Tpl =
            v8::FunctionTemplate::New(GetMinAngle, v8::Handle<v8::Value>(), GetMinAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MinAngle"), GetMinAngle_Tpl);
        v8::Local<v8::Signature> SetMinAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMinAngle_Tpl =
            v8::FunctionTemplate::New(SetMinAngle, v8::Handle<v8::Value>(), SetMinAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MinAngle"), SetMinAngle_Tpl);
        v8::Local<v8::Signature> GetMaxAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMaxAngle_Tpl =
            v8::FunctionTemplate::New(GetMaxAngle, v8::Handle<v8::Value>(), GetMaxAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MaxAngle"), GetMaxAngle_Tpl);
        v8::Local<v8::Signature> SetMaxAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMaxAngle_Tpl =
            v8::FunctionTemplate::New(SetMaxAngle, v8::Handle<v8::Value>(), SetMaxAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MaxAngle"), SetMaxAngle_Tpl);
        v8::Local<v8::Signature> GetRatchetAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRatchetAngle_Tpl =
            v8::FunctionTemplate::New(GetRatchetAngle, v8::Handle<v8::Value>(), GetRatchetAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RatchetAngle"), GetRatchetAngle_Tpl);
        v8::Local<v8::Signature> SetRatchetAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRatchetAngle_Tpl =
            v8::FunctionTemplate::New(SetRatchetAngle, v8::Handle<v8::Value>(), SetRatchetAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""RatchetAngle"), SetRatchetAngle_Tpl);
        v8::Local<v8::Signature> GetRatchetPhase_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRatchetPhase_Tpl =
            v8::FunctionTemplate::New(GetRatchetPhase, v8::Handle<v8::Value>(), GetRatchetPhase_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RatchetPhase"), GetRatchetPhase_Tpl);
        v8::Local<v8::Signature> SetRatchetPhase_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRatchetPhase_Tpl =
            v8::FunctionTemplate::New(SetRatchetPhase, v8::Handle<v8::Value>(), SetRatchetPhase_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""RatchetPhase"), SetRatchetPhase_Tpl);
        v8::Local<v8::Signature> GetRatchetInterval_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRatchetInterval_Tpl =
            v8::FunctionTemplate::New(GetRatchetInterval, v8::Handle<v8::Value>(), GetRatchetInterval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RatchetInterval"), GetRatchetInterval_Tpl);
        v8::Local<v8::Signature> SetRatchetInterval_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRatchetInterval_Tpl =
            v8::FunctionTemplate::New(SetRatchetInterval, v8::Handle<v8::Value>(), SetRatchetInterval_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""RatchetInterval"), SetRatchetInterval_Tpl);
        v8::Local<v8::Signature> GetGearRatio_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetGearRatio_Tpl =
            v8::FunctionTemplate::New(GetGearRatio, v8::Handle<v8::Value>(), GetGearRatio_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""GearRatio"), GetGearRatio_Tpl);
        v8::Local<v8::Signature> SetGearRatio_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetGearRatio_Tpl =
            v8::FunctionTemplate::New(SetGearRatio, v8::Handle<v8::Value>(), SetGearRatio_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""GearRatio"), SetGearRatio_Tpl);
        v8::Local<v8::Signature> GetGearInitialAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetGearInitialAngle_Tpl =
            v8::FunctionTemplate::New(GetGearInitialAngle, v8::Handle<v8::Value>(), GetGearInitialAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""GearInitialAngle"), GetGearInitialAngle_Tpl);
        v8::Local<v8::Signature> SetGearInitialAngle_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetGearInitialAngle_Tpl =
            v8::FunctionTemplate::New(SetGearInitialAngle, v8::Handle<v8::Value>(), SetGearInitialAngle_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""GearInitialAngle"), SetGearInitialAngle_Tpl);
        v8::Local<v8::Signature> GetMotorSpinRate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMotorSpinRate_Tpl =
            v8::FunctionTemplate::New(GetMotorSpinRate, v8::Handle<v8::Value>(), GetMotorSpinRate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MotorSpinRate"), GetMotorSpinRate_Tpl);
        v8::Local<v8::Signature> SetMotorSpinRate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMotorSpinRate_Tpl =
            v8::FunctionTemplate::New(SetMotorSpinRate, v8::Handle<v8::Value>(), SetMotorSpinRate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MotorSpinRate"), SetMotorSpinRate_Tpl);
        target->Set(v8::String::NewSymbol("CpConstraint"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> cpConstraintWrap::GetType(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("string" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        const char* theType = (const char*)cpConstraintGetUserData(self);
        return scope.Close( v8::String::New(theType) );
    };

    v8::Handle<v8::Value> cpConstraintWrap::GetImpulse(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theImpulse = cpConstraintGetImpulse(self);
        return scope.Close( v8::Number::New(theImpulse) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetMaxForce(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMaxForce = cpConstraintGetMaxForce(self);
        return scope.Close( v8::Number::New(theMaxForce) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetMaxForce(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inMaxForce)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMaxForce"")");
        double theMaxForce = args[1 -1]->NumberValue();

        cpConstraintSetMaxForce(self, theMaxForce);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetErrorBias(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theErrorBias = cpConstraintGetErrorBias(self);
        return scope.Close( v8::Number::New(theErrorBias) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetErrorBias(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inErrorBias)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theErrorBias"")");
        double theErrorBias = args[1 -1]->NumberValue();

        cpConstraintSetErrorBias(self, theErrorBias);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetMaxBias(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMaxBias = cpConstraintGetMaxBias(self);
        return scope.Close( v8::Number::New(theMaxBias) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetMaxBias(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inMaxBias)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMaxBias"")");
        double theMaxBias = args[1 -1]->NumberValue();

        cpConstraintSetMaxBias(self, theMaxBias);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::ActivateBodies(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        cpConstraintActivateBodies(self);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        cpBody* body = cpConstraintGetA(self);
        Sprite* sprite = (Sprite*) cpBodyGetUserData(body);
        if (!sprite) return scope.Close( v8::Null() );
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(sprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( sprite->mSpriteScriptObj );
        };
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetOtherSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);
        ;
        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        cpBody* body = cpConstraintGetB(self);
        Sprite* otherSprite = (Sprite*) cpBodyGetUserData(body);
        if (!otherSprite) return scope.Close( v8::Null() );
        if (otherSprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(otherSprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( otherSprite->mSpriteScriptObj );
        };
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetAnchor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        cpVect anchor;
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            anchor = cpPinJointGetAnchr1(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            anchor = cpSlideJointGetAnchr1(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            anchor = cpPivotJointGetAnchr1(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            anchor = cpDampedSpringGetAnchr1(self);
        }
        else
        {
            return scope.Close( v8::Undefined() );
        }
        pdg::Offset theAnchor(anchor.x, anchor.y);
        return scope.Close( v8_MakeJavascriptOffset(theAnchor) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetAnchor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "([object Offset] inAnchor)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theAnchor = v8_ValueToOffset(args[1 -1]);

        cpVect anchor = cpv(theAnchor.x, theAnchor.y);
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            cpPinJointSetAnchr1(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            cpSlideJointSetAnchr1(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            cpPivotJointSetAnchr1(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetAnchr1(self, anchor);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setAnchor() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetOtherAnchor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        cpVect anchor;
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            anchor = cpPinJointGetAnchr2(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            anchor = cpSlideJointGetAnchr2(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            anchor = cpPivotJointGetAnchr2(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") == 0)
        {
            anchor = cpGrooveJointGetAnchr2(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            anchor = cpDampedSpringGetAnchr2(self);
        }
        else
        {
            return scope.Close( v8::Undefined() );
        }
        pdg::Offset theOtherAnchor(anchor.x, anchor.y);
        return scope.Close( v8_MakeJavascriptOffset(theOtherAnchor) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetOtherAnchor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "([object Offset] inOtherAnchor)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theOtherAnchor = v8_ValueToOffset(args[1 -1]);

        cpVect anchor = cpv(theOtherAnchor.x, theOtherAnchor.y);
        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") == 0)
        {
            cpPinJointSetAnchr2(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") == 0)
        {
            cpSlideJointSetAnchr2(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "PivotJoint") == 0)
        {
            cpPivotJointSetAnchr2(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") == 0)
        {
            cpGrooveJointSetAnchr2(self, anchor);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetAnchr2(self, anchor);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setOtherAnchor() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetPinDist(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat thePinDist = cpPinJointGetDist(self);
        return scope.Close( v8::Number::New(thePinDist) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetPinDist(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inPinDist)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""thePinDist"")");
        double thePinDist = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "PinJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "PinDist" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpPinJointSetDist(self, thePinDist);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetSlideMinDist(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theSlideMinDist = cpSlideJointGetMin(self);
        return scope.Close( v8::Number::New(theSlideMinDist) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetSlideMinDist(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inSlideMinDist)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSlideMinDist"")");
        double theSlideMinDist = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "SlideMinDist" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpSlideJointSetMin(self, theSlideMinDist);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetSlideMaxDist(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theSlideMaxDist = cpSlideJointGetMax(self);
        return scope.Close( v8::Number::New(theSlideMaxDist) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetSlideMaxDist(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inSlideMaxDist)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSlideMaxDist"")");
        double theSlideMaxDist = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SlideJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "SlideMaxDist" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpSlideJointSetMax(self, theSlideMaxDist);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetGrooveStart(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpVect v = cpGrooveJointGetGrooveA(self);
        pdg::Offset theGrooveStart(v.x, v.y);
        return scope.Close( v8_MakeJavascriptOffset(theGrooveStart) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetGrooveStart(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "([object Offset] inGrooveStart)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theGrooveStart = v8_ValueToOffset(args[1 -1]);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GrooveStart" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpGrooveJointSetGrooveA(self, cpv(theGrooveStart.x, theGrooveStart.y));
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetGrooveEnd(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpVect v = cpGrooveJointGetGrooveB(self);
        pdg::Offset theGrooveEnd(v.x, v.y);
        return scope.Close( v8_MakeJavascriptOffset(theGrooveEnd) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetGrooveEnd(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "([object Offset] inGrooveEnd)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theGrooveEnd = v8_ValueToOffset(args[1 -1]);

        if (strcmp((const char*)cpConstraintGetUserData(self), "GrooveJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GrooveEnd" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpGrooveJointSetGrooveB(self, cpv(theGrooveEnd.x, theGrooveEnd.y));
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetSpringRestLength(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theSpringRestLength = cpDampedSpringGetRestLength(self);
        return scope.Close( v8::Number::New(theSpringRestLength) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetSpringRestLength(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inSpringRestLength)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpringRestLength"")");
        double theSpringRestLength = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "SpringRestLength" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpDampedSpringSetRestLength(self, theSpringRestLength);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetRotarySpringRestAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theRotarySpringRestAngle = cpDampedRotarySpringGetRestAngle(self);
        return scope.Close( v8::Number::New(theRotarySpringRestAngle) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetRotarySpringRestAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inRotarySpringRestAngle)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRotarySpringRestAngle"")");
        double theRotarySpringRestAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RotarySpringRestAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpDampedRotarySpringSetRestAngle(self, theRotarySpringRestAngle);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetMinAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theMinAngle = cpRotaryLimitJointGetMin(self);
        return scope.Close( v8::Number::New(theMinAngle) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetMinAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inMinAngle)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMinAngle"")");
        double theMinAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "MinAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpRotaryLimitJointSetMin(self, theMinAngle);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetMaxAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theMaxAngle = cpRotaryLimitJointGetMax(self);
        return scope.Close( v8::Number::New(theMaxAngle) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetMaxAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inMaxAngle)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMaxAngle"")");
        double theMaxAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "RotaryLimit") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "MaxAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpRotaryLimitJointSetMax(self, theMaxAngle);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetRatchetAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theRatchetAngle = cpRatchetJointGetAngle(self);
        return scope.Close( v8::Number::New(theRatchetAngle) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetRatchetAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inRatchetAngle)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRatchetAngle"")");
        double theRatchetAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RatchetAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpRatchetJointSetAngle(self, theRatchetAngle);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetRatchetPhase(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theRatchetPhase = cpRatchetJointGetPhase(self);
        return scope.Close( v8::Number::New(theRatchetPhase) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetRatchetPhase(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inRatchetPhase)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRatchetPhase"")");
        double theRatchetPhase = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RatchetPhase" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpRatchetJointSetPhase(self, theRatchetPhase);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetRatchetInterval(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theRatchetInterval = cpRatchetJointGetRatchet(self);
        return scope.Close( v8::Number::New(theRatchetInterval) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetRatchetInterval(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inRatchetInterval)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRatchetInterval"")");
        double theRatchetInterval = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Ratchet") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "RatchetInterval" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpRatchetJointSetRatchet(self, theRatchetInterval);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetGearRatio(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theGearRatio = cpGearJointGetRatio(self);
        return scope.Close( v8::Number::New(theGearRatio) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetGearRatio(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inGearRatio)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theGearRatio"")");
        double theGearRatio = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GearRatio" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpGearJointSetRatio(self, theGearRatio);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetGearInitialAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theGearInitialAngle = cpGearJointGetPhase(self);
        return scope.Close( v8::Number::New(theGearInitialAngle) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetGearInitialAngle(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inGearInitialAngle)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theGearInitialAngle"")");
        double theGearInitialAngle = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Gear") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "GearInitialAngle" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpGearJointSetPhase(self, theGearInitialAngle);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetMotorSpinRate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        if (strcmp((const char*)cpConstraintGetUserData(self), "Motor") != 0)
        {
            return scope.Close( v8::Undefined() );
        };
        cpFloat theMotorSpinRate = cpSimpleMotorGetRate(self);
        return scope.Close( v8::Number::New(theMotorSpinRate) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetMotorSpinRate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inMotorSpinRate)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMotorSpinRate"")");
        double theMotorSpinRate = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "Motor") != 0)
        {
            std::ostringstream msg;
            msg << "cpConstraint.set" "MotorSpinRate" "() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        cpSimpleMotorSetRate(self, theMotorSpinRate);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetSpringStiffness(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        cpFloat theSpringStiffness;
        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            theSpringStiffness = cpDampedSpringGetStiffness(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            theSpringStiffness = cpDampedRotarySpringGetStiffness(self);
        }
        else
        {
            return scope.Close( v8::Undefined() );
        };
        return scope.Close( v8::Number::New(theSpringStiffness) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetSpringStiffness(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inSpringStiffness)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpringStiffness"")");
        double theSpringStiffness = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetStiffness(self, theSpringStiffness);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            cpDampedRotarySpringSetStiffness(self, theSpringStiffness);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setSpringStiffness() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpConstraintWrap::GetSpringDamping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        cpFloat theSpringDamping;
        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            theSpringDamping = cpDampedSpringGetDamping(self);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            theSpringDamping = cpDampedRotarySpringGetDamping(self);
        }
        else
        {
            return scope.Close( v8::Undefined() );
        };
        return scope.Close( v8::Number::New(theSpringDamping) );
    }

    v8::Handle<v8::Value> cpConstraintWrap::SetSpringDamping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpConstraintWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpConstraintWrap>(args.This());
        cpConstraint* self = dynamic_cast<cpConstraint*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpConstraint" " function" "(number inSpringDamping)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpringDamping"")");
        double theSpringDamping = args[1 -1]->NumberValue();

        if (strcmp((const char*)cpConstraintGetUserData(self), "SpringJoint") == 0)
        {
            cpDampedSpringSetDamping(self, theSpringDamping);
        }
        else if (strcmp((const char*)cpConstraintGetUserData(self), "RotarySpring") == 0)
        {
            cpDampedRotarySpringSetDamping(self, theSpringDamping);
        }
        else
        {
            std::ostringstream msg;
            msg << "cpConstraint.setSpringDamping() not valid for constraint type "
                << (const char*)cpConstraintGetUserData(self);
            std::ostringstream excpt_;
            excpt_ << msg.str().c_str();
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str()))) ;
        };
        return scope.Close( args.This() );
    }

    static bool s_cpSpace_InNewFromNative = false;

    v8::Handle<v8::Value> cpSpaceWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = new cpSpaceWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> cpSpaceWrap::NewFromNative(cpSpace* nativeObj)
    {
        s_cpSpace_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(obj);

        ;
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_cpSpace_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> cpSpaceWrap::constructorTpl_;

    void cpSpaceWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("CpSpace"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> UseSpatialHash_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UseSpatialHash_Tpl =
            v8::FunctionTemplate::New(UseSpatialHash, v8::Handle<v8::Value>(), UseSpatialHash_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("useSpatialHash"), UseSpatialHash_Tpl);
        v8::Local<v8::Signature> ReindexStatic_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ReindexStatic_Tpl =
            v8::FunctionTemplate::New(ReindexStatic, v8::Handle<v8::Value>(), ReindexStatic_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("reindexStatic"), ReindexStatic_Tpl);
        v8::Local<v8::Signature> Step_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Step_Tpl =
            v8::FunctionTemplate::New(Step, v8::Handle<v8::Value>(), Step_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("step"), Step_Tpl);
        v8::Local<v8::Signature> GetIdleSpeedThreshold_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetIdleSpeedThreshold_Tpl =
            v8::FunctionTemplate::New(GetIdleSpeedThreshold, v8::Handle<v8::Value>(), GetIdleSpeedThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""IdleSpeedThreshold"), GetIdleSpeedThreshold_Tpl);
        v8::Local<v8::Signature> SetIdleSpeedThreshold_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetIdleSpeedThreshold_Tpl =
            v8::FunctionTemplate::New(SetIdleSpeedThreshold, v8::Handle<v8::Value>(), SetIdleSpeedThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""IdleSpeedThreshold"), SetIdleSpeedThreshold_Tpl);
        v8::Local<v8::Signature> GetSleepTimeThreshold_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSleepTimeThreshold_Tpl =
            v8::FunctionTemplate::New(GetSleepTimeThreshold, v8::Handle<v8::Value>(), GetSleepTimeThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SleepTimeThreshold"), GetSleepTimeThreshold_Tpl);
        v8::Local<v8::Signature> SetSleepTimeThreshold_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSleepTimeThreshold_Tpl =
            v8::FunctionTemplate::New(SetSleepTimeThreshold, v8::Handle<v8::Value>(), SetSleepTimeThreshold_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SleepTimeThreshold"), SetSleepTimeThreshold_Tpl);
        v8::Local<v8::Signature> GetCollisionSlop_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCollisionSlop_Tpl =
            v8::FunctionTemplate::New(GetCollisionSlop, v8::Handle<v8::Value>(), GetCollisionSlop_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""CollisionSlop"), GetCollisionSlop_Tpl);
        v8::Local<v8::Signature> SetCollisionSlop_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCollisionSlop_Tpl =
            v8::FunctionTemplate::New(SetCollisionSlop, v8::Handle<v8::Value>(), SetCollisionSlop_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""CollisionSlop"), SetCollisionSlop_Tpl);
        v8::Local<v8::Signature> GetCollisionBias_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCollisionBias_Tpl =
            v8::FunctionTemplate::New(GetCollisionBias, v8::Handle<v8::Value>(), GetCollisionBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""CollisionBias"), GetCollisionBias_Tpl);
        v8::Local<v8::Signature> SetCollisionBias_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCollisionBias_Tpl =
            v8::FunctionTemplate::New(SetCollisionBias, v8::Handle<v8::Value>(), SetCollisionBias_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""CollisionBias"), SetCollisionBias_Tpl);
        v8::Local<v8::Signature> GetCollisionPersistence_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCollisionPersistence_Tpl =
            v8::FunctionTemplate::New(GetCollisionPersistence, v8::Handle<v8::Value>(), GetCollisionPersistence_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""CollisionPersistence"), GetCollisionPersistence_Tpl);
        v8::Local<v8::Signature> SetCollisionPersistence_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCollisionPersistence_Tpl =
            v8::FunctionTemplate::New(SetCollisionPersistence, v8::Handle<v8::Value>(), SetCollisionPersistence_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""CollisionPersistence"), SetCollisionPersistence_Tpl);
        v8::Local<v8::Signature> GetEnableContactGraph_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetEnableContactGraph_Tpl =
            v8::FunctionTemplate::New(GetEnableContactGraph, v8::Handle<v8::Value>(), GetEnableContactGraph_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""EnableContactGraph"), GetEnableContactGraph_Tpl);
        v8::Local<v8::Signature> SetEnableContactGraph_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetEnableContactGraph_Tpl =
            v8::FunctionTemplate::New(SetEnableContactGraph, v8::Handle<v8::Value>(), SetEnableContactGraph_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""EnableContactGraph"), SetEnableContactGraph_Tpl);
        target->Set(v8::String::NewSymbol("CpSpace"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> cpSpaceWrap::UseSpatialHash(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number dim, [number int] count)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""dim"")");
        double dim = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""count"")");
        long count = args[2 -1]->Int32Value();
        cpSpaceUseSpatialHash(self, dim, count);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::ReindexStatic(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        cpSpaceReindexStatic(self);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::Step(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number dt)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""dt"")");
        double dt = args[1 -1]->NumberValue();
        cpSpaceStep(self, dt);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::GetIdleSpeedThreshold(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theIdleSpeedThreshold = cpSpaceGetIdleSpeedThreshold(self);
        return scope.Close( v8::Number::New(theIdleSpeedThreshold) );
    }

    v8::Handle<v8::Value> cpSpaceWrap::SetIdleSpeedThreshold(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpSpace" " function" "(number inIdleSpeedThreshold)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theIdleSpeedThreshold"")");
        double theIdleSpeedThreshold = args[1 -1]->NumberValue();

        cpSpaceSetIdleSpeedThreshold(self, theIdleSpeedThreshold);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::GetSleepTimeThreshold(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSleepTimeThreshold = cpSpaceGetSleepTimeThreshold(self);
        return scope.Close( v8::Number::New(theSleepTimeThreshold) );
    }

    v8::Handle<v8::Value> cpSpaceWrap::SetSleepTimeThreshold(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpSpace" " function" "(number inSleepTimeThreshold)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSleepTimeThreshold"")");
        double theSleepTimeThreshold = args[1 -1]->NumberValue();

        cpSpaceSetSleepTimeThreshold(self, theSleepTimeThreshold);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::GetCollisionSlop(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theCollisionSlop = cpSpaceGetCollisionSlop(self);
        return scope.Close( v8::Number::New(theCollisionSlop) );
    }

    v8::Handle<v8::Value> cpSpaceWrap::SetCollisionSlop(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpSpace" " function" "(number inCollisionSlop)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theCollisionSlop"")");
        double theCollisionSlop = args[1 -1]->NumberValue();

        cpSpaceSetCollisionSlop(self, theCollisionSlop);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::GetCollisionBias(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theCollisionBias = cpSpaceGetCollisionBias(self);
        return scope.Close( v8::Number::New(theCollisionBias) );
    }

    v8::Handle<v8::Value> cpSpaceWrap::SetCollisionBias(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpSpace" " function" "(number inCollisionBias)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theCollisionBias"")");
        double theCollisionBias = args[1 -1]->NumberValue();

        cpSpaceSetCollisionBias(self, theCollisionBias);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::GetCollisionPersistence(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theCollisionPersistence = cpSpaceGetCollisionPersistence(self);
        return scope.Close( v8::Number::New(theCollisionPersistence) );
    }

    v8::Handle<v8::Value> cpSpaceWrap::SetCollisionPersistence(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpSpace" " function" "(number inCollisionPersistence)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theCollisionPersistence"")");
        double theCollisionPersistence = args[1 -1]->NumberValue();

        cpSpaceSetCollisionPersistence(self, theCollisionPersistence);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> cpSpaceWrap::GetEnableContactGraph(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        bool theEnableContactGraph = cpSpaceGetEnableContactGraph(self);
        return scope.Close( v8::Boolean::New(theEnableContactGraph) );
    }

    v8::Handle<v8::Value> cpSpaceWrap::SetEnableContactGraph(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        cpSpaceWrap* objWrapper = jswrap::ObjectWrap::Unwrap<cpSpaceWrap>(args.This());
        cpSpace* self = dynamic_cast<cpSpace*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("cpSpace" " function" "(boolean inEnableContactGraph)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""theEnableContactGraph"")");
        bool theEnableContactGraph = args[1 -1]->BooleanValue();

        cpSpaceSetEnableContactGraph(self, theEnableContactGraph);
        return scope.Close( args.This() );
    }
#endif

    static bool s_ISpriteCollideHelper_InNewFromNative = false;

    v8::Handle<v8::Value> ISpriteCollideHelperWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ISpriteCollideHelperWrap* objWrapper = new ISpriteCollideHelperWrap(args);
        objWrapper->Wrap(args.This());
        ISpriteCollideHelper* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mISpriteCollideHelperScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> ISpriteCollideHelperWrap::NewFromNative(ISpriteCollideHelper* nativeObj)
    {
        s_ISpriteCollideHelper_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        ISpriteCollideHelperWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ISpriteCollideHelperWrap>(obj);

        nativeObj->mISpriteCollideHelperScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_ISpriteCollideHelper_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> ISpriteCollideHelperWrap::constructorTpl_;

    void ISpriteCollideHelperWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("ISpriteCollideHelper"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        target->Set(v8::String::NewSymbol("ISpriteCollideHelper"), constructorTpl_->GetFunction());
    }

    void CleanupISpriteCollideHelperScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteCollideHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<ISpriteCollideHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ISpriteCollideHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""ISpriteCollideHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""ISpriteCollideHelper""\n";
                }
            }
            else
            {
                ISpriteCollideHelper* obj = dynamic_cast<ISpriteCollideHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""ISpriteCollideHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "ISpriteCollideHelper" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

#ifndef PDG_NO_GUI

    static bool s_ISpriteDrawHelper_InNewFromNative = false;

    v8::Handle<v8::Value> ISpriteDrawHelperWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        ISpriteDrawHelperWrap* objWrapper = new ISpriteDrawHelperWrap(args);
        objWrapper->Wrap(args.This());
        ISpriteDrawHelper* nativeObj = objWrapper->getNativeObject();
        if (nativeObj) nativeObj->mISpriteDrawHelperScriptObj = v8::Persistent<v8::Object>::New(args.This());
        objWrapper->Ref();
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> ISpriteDrawHelperWrap::NewFromNative(ISpriteDrawHelper* nativeObj)
    {
        s_ISpriteDrawHelper_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        ISpriteDrawHelperWrap* objWrapper = jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(obj);

        nativeObj->mISpriteDrawHelperScriptObj = v8::Persistent<v8::Object>::New(obj);
        objWrapper->Ref();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_ISpriteDrawHelper_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> ISpriteDrawHelperWrap::constructorTpl_;

    void ISpriteDrawHelperWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("ISpriteDrawHelper"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        target->Set(v8::String::NewSymbol("ISpriteDrawHelper"), constructorTpl_->GetFunction());
    }

    void CleanupISpriteDrawHelperScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteDrawHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""ISpriteDrawHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""ISpriteDrawHelper""\n";
                }
            }
            else
            {
                ISpriteDrawHelper* obj = dynamic_cast<ISpriteDrawHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""ISpriteDrawHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "ISpriteDrawHelper" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }
#endif

    static const char* sPinJointStr = "PinJoint";
    static const char* sSlideJointStr = "SlideJoint";
    static const char* sPivotJointStr = "PivotJoint";
    static const char* sGrooveJointStr = "GrooveJoint";
    static const char* sSpringJointStr = "SpringJoint";
    static const char* sRotarySpringStr = "RotarySpring";
    static const char* sRotaryLimitStr = "RotaryLimit";
    static const char* sRatchetStr = "Ratchet";
    static const char* sGearStr = "Gear";
    static const char* sMotorStr = "Motor";

    static bool s_Sprite_InNewFromNative = false;

    v8::Handle<v8::Value> SpriteWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = new SpriteWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> SpriteWrap::NewFromNative(Sprite* nativeObj)
    {
        s_Sprite_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(obj);

        nativeObj->mEventEmitterScriptObj = obj; nativeObj->mAnimatedScriptObj = obj; nativeObj->mSpriteScriptObj = obj; nativeObj->mISerializableScriptObj = obj; nativeObj->addRef();
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_Sprite_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> SpriteWrap::constructorTpl_;

    void SpriteWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("Sprite"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(AddHandler, v8::Handle<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addHandler"), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(RemoveHandler, v8::Handle<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeHandler"), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(Clear, v8::Handle<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clear"), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(BlockEvent, v8::Handle<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("blockEvent"), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(UnblockEvent, v8::Handle<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unblockEvent"), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(GetBoundingBox, v8::Handle<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""BoundingBox"), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(GetRotatedBounds, v8::Handle<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RotatedBounds"), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(GetLocation, v8::Handle<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Location"), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(SetLocation, v8::Handle<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Location"), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(GetSpeed, v8::Handle<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Speed"), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(SetSpeed, v8::Handle<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Speed"), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(GetVelocity, v8::Handle<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Velocity"), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(SetVelocity, v8::Handle<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Velocity"), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(GetWidth, v8::Handle<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Width"), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(SetWidth, v8::Handle<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Width"), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(GetHeight, v8::Handle<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Height"), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(SetHeight, v8::Handle<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Height"), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(GetRotation, v8::Handle<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Rotation"), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(SetRotation, v8::Handle<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Rotation"), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(GetCenterOffset, v8::Handle<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""CenterOffset"), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(SetCenterOffset, v8::Handle<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""CenterOffset"), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(GetSpin, v8::Handle<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Spin"), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(SetSpin, v8::Handle<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Spin"), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(GetMass, v8::Handle<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Mass"), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(SetMass, v8::Handle<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Mass"), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(GetMoveFriction, v8::Handle<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MoveFriction"), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(SetMoveFriction, v8::Handle<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MoveFriction"), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(GetSpinFriction, v8::Handle<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SpinFriction"), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(SetSpinFriction, v8::Handle<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SpinFriction"), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(GetSizeFriction, v8::Handle<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SizeFriction"), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(SetSizeFriction, v8::Handle<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SizeFriction"), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(Move, v8::Handle<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("move"), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(MoveTo, v8::Handle<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveTo"), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(SetVelocityInRadians, v8::Handle<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setVelocityInRadians"), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(GetMovementDirectionInRadians, v8::Handle<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getMovementDirectionInRadians"), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(StopMoving, v8::Handle<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopMoving"), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(Accelerate, v8::Handle<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerate"), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(AccelerateTo, v8::Handle<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerateTo"), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(SetSize, v8::Handle<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSize"), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(Grow, v8::Handle<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("grow"), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(Stretch, v8::Handle<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stretch"), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(StartGrowing, v8::Handle<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startGrowing"), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(StopGrowing, v8::Handle<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopGrowing"), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(StartStretching, v8::Handle<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startStretching"), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(StopStretching, v8::Handle<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopStretching"), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(Resize, v8::Handle<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resize"), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(ResizeTo, v8::Handle<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resizeTo"), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(Rotate, v8::Handle<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotate"), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(RotateTo, v8::Handle<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotateTo"), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(StopSpinning, v8::Handle<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopSpinning"), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(ChangeCenter, v8::Handle<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenter"), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(ChangeCenterTo, v8::Handle<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenterTo"), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(Wait, v8::Handle<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("wait"), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(SetFriction, v8::Handle<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFriction"), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(ApplyForce, v8::Handle<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyForce"), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(ApplyTorque, v8::Handle<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyTorque"), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(StopAllForces, v8::Handle<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopAllForces"), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(AddAnimationHelper, v8::Handle<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addAnimationHelper"), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(RemoveAnimationHelper, v8::Handle<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeAnimationHelper"), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(ClearAnimationHelpers, v8::Handle<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clearAnimationHelpers"), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> GetMyClassTag_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMyClassTag_Tpl =
            v8::FunctionTemplate::New(GetMyClassTag, v8::Handle<v8::Value>(), GetMyClassTag_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MyClassTag"), GetMyClassTag_Tpl);
        v8::Local<v8::Signature> GetSerializedSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSerializedSize_Tpl =
            v8::FunctionTemplate::New(GetSerializedSize, v8::Handle<v8::Value>(), GetSerializedSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SerializedSize"), GetSerializedSize_Tpl);
        v8::Local<v8::Signature> Serialize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_Tpl =
            v8::FunctionTemplate::New(Serialize, v8::Handle<v8::Value>(), Serialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize"), Serialize_Tpl);
        v8::Local<v8::Signature> Deserialize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_Tpl =
            v8::FunctionTemplate::New(Deserialize, v8::Handle<v8::Value>(), Deserialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize"), Deserialize_Tpl);
        v8::Local<v8::Signature> GetFrameRotatedBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFrameRotatedBounds_Tpl =
            v8::FunctionTemplate::New(GetFrameRotatedBounds, v8::Handle<v8::Value>(), GetFrameRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getFrameRotatedBounds"), GetFrameRotatedBounds_Tpl);
        v8::Local<v8::Signature> SetFrame_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFrame_Tpl =
            v8::FunctionTemplate::New(SetFrame, v8::Handle<v8::Value>(), SetFrame_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFrame"), SetFrame_Tpl);
        v8::Local<v8::Signature> GetCurrentFrame_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCurrentFrame_Tpl =
            v8::FunctionTemplate::New(GetCurrentFrame, v8::Handle<v8::Value>(), GetCurrentFrame_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getCurrentFrame"), GetCurrentFrame_Tpl);
        v8::Local<v8::Signature> GetFrameCount_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFrameCount_Tpl =
            v8::FunctionTemplate::New(GetFrameCount, v8::Handle<v8::Value>(), GetFrameCount_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getFrameCount"), GetFrameCount_Tpl);
        v8::Local<v8::Signature> StartFrameAnimation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartFrameAnimation_Tpl =
            v8::FunctionTemplate::New(StartFrameAnimation, v8::Handle<v8::Value>(), StartFrameAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startFrameAnimation"), StartFrameAnimation_Tpl);
        v8::Local<v8::Signature> StopFrameAnimation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopFrameAnimation_Tpl =
            v8::FunctionTemplate::New(StopFrameAnimation, v8::Handle<v8::Value>(), StopFrameAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopFrameAnimation"), StopFrameAnimation_Tpl);
        v8::Local<v8::Signature> SetWantsAnimLoopEvents_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWantsAnimLoopEvents_Tpl =
            v8::FunctionTemplate::New(SetWantsAnimLoopEvents, v8::Handle<v8::Value>(), SetWantsAnimLoopEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setWantsAnimLoopEvents"), SetWantsAnimLoopEvents_Tpl);
        v8::Local<v8::Signature> SetWantsAnimEndEvents_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWantsAnimEndEvents_Tpl =
            v8::FunctionTemplate::New(SetWantsAnimEndEvents, v8::Handle<v8::Value>(), SetWantsAnimEndEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setWantsAnimEndEvents"), SetWantsAnimEndEvents_Tpl);
        v8::Local<v8::Signature> SetWantsCollideWallEvents_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWantsCollideWallEvents_Tpl =
            v8::FunctionTemplate::New(SetWantsCollideWallEvents, v8::Handle<v8::Value>(), SetWantsCollideWallEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setWantsCollideWallEvents"), SetWantsCollideWallEvents_Tpl);
        v8::Local<v8::Signature> AddFramesImage_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddFramesImage_Tpl =
            v8::FunctionTemplate::New(AddFramesImage, v8::Handle<v8::Value>(), AddFramesImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addFramesImage"), AddFramesImage_Tpl);
#ifdef PDG_SCML_SUPPORT
        v8::Local<v8::Signature> HasAnimation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> HasAnimation_Tpl =
            v8::FunctionTemplate::New(HasAnimation, v8::Handle<v8::Value>(), HasAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("hasAnimation"), HasAnimation_Tpl);
        v8::Local<v8::Signature> StartAnimation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartAnimation_Tpl =
            v8::FunctionTemplate::New(StartAnimation, v8::Handle<v8::Value>(), StartAnimation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startAnimation"), StartAnimation_Tpl);
        v8::Local<v8::Signature> SetEntityScale_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetEntityScale_Tpl =
            v8::FunctionTemplate::New(SetEntityScale, v8::Handle<v8::Value>(), SetEntityScale_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setEntityScale"), SetEntityScale_Tpl);
#endif
        v8::Local<v8::Signature> ChangeFramesImage_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeFramesImage_Tpl =
            v8::FunctionTemplate::New(ChangeFramesImage, v8::Handle<v8::Value>(), ChangeFramesImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeFramesImage"), ChangeFramesImage_Tpl);
        v8::Local<v8::Signature> OffsetFrameCenters_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> OffsetFrameCenters_Tpl =
            v8::FunctionTemplate::New(OffsetFrameCenters, v8::Handle<v8::Value>(), OffsetFrameCenters_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("offsetFrameCenters"), OffsetFrameCenters_Tpl);
        v8::Local<v8::Signature> GetFrameCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFrameCenterOffset_Tpl =
            v8::FunctionTemplate::New(GetFrameCenterOffset, v8::Handle<v8::Value>(), GetFrameCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getFrameCenterOffset"), GetFrameCenterOffset_Tpl);
        v8::Local<v8::Signature> SetOpacity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetOpacity_Tpl =
            v8::FunctionTemplate::New(SetOpacity, v8::Handle<v8::Value>(), SetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setOpacity"), SetOpacity_Tpl);
        v8::Local<v8::Signature> GetOpacity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetOpacity_Tpl =
            v8::FunctionTemplate::New(GetOpacity, v8::Handle<v8::Value>(), GetOpacity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getOpacity"), GetOpacity_Tpl);
        v8::Local<v8::Signature> FadeTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeTo_Tpl =
            v8::FunctionTemplate::New(FadeTo, v8::Handle<v8::Value>(), FadeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeTo"), FadeTo_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(FadeIn, v8::Handle<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeIn"), FadeIn_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(FadeOut, v8::Handle<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeOut"), FadeOut_Tpl);
        v8::Local<v8::Signature> IsBehind_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsBehind_Tpl =
            v8::FunctionTemplate::New(IsBehind, v8::Handle<v8::Value>(), IsBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isBehind"), IsBehind_Tpl);
        v8::Local<v8::Signature> GetZOrder_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetZOrder_Tpl =
            v8::FunctionTemplate::New(GetZOrder, v8::Handle<v8::Value>(), GetZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getZOrder"), GetZOrder_Tpl);
        v8::Local<v8::Signature> MoveBehind_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveBehind_Tpl =
            v8::FunctionTemplate::New(MoveBehind, v8::Handle<v8::Value>(), MoveBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveBehind"), MoveBehind_Tpl);
        v8::Local<v8::Signature> MoveInFrontOf_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveInFrontOf_Tpl =
            v8::FunctionTemplate::New(MoveInFrontOf, v8::Handle<v8::Value>(), MoveInFrontOf_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveInFrontOf"), MoveInFrontOf_Tpl);
        v8::Local<v8::Signature> MoveToFront_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveToFront_Tpl =
            v8::FunctionTemplate::New(MoveToFront, v8::Handle<v8::Value>(), MoveToFront_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveToFront"), MoveToFront_Tpl);
        v8::Local<v8::Signature> MoveToBack_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveToBack_Tpl =
            v8::FunctionTemplate::New(MoveToBack, v8::Handle<v8::Value>(), MoveToBack_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveToBack"), MoveToBack_Tpl);
        v8::Local<v8::Signature> EnableCollisions_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> EnableCollisions_Tpl =
            v8::FunctionTemplate::New(EnableCollisions, v8::Handle<v8::Value>(), EnableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("enableCollisions"), EnableCollisions_Tpl);
        v8::Local<v8::Signature> DisableCollisions_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DisableCollisions_Tpl =
            v8::FunctionTemplate::New(DisableCollisions, v8::Handle<v8::Value>(), DisableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("disableCollisions"), DisableCollisions_Tpl);
        v8::Local<v8::Signature> SetCollisionRadius_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCollisionRadius_Tpl =
            v8::FunctionTemplate::New(SetCollisionRadius, v8::Handle<v8::Value>(), SetCollisionRadius_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setCollisionRadius"), SetCollisionRadius_Tpl);
        v8::Local<v8::Signature> GetCollisionRadius_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCollisionRadius_Tpl =
            v8::FunctionTemplate::New(GetCollisionRadius, v8::Handle<v8::Value>(), GetCollisionRadius_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getCollisionRadius"), GetCollisionRadius_Tpl);
        v8::Local<v8::Signature> UseCollisionMask_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UseCollisionMask_Tpl =
            v8::FunctionTemplate::New(UseCollisionMask, v8::Handle<v8::Value>(), UseCollisionMask_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("useCollisionMask"), UseCollisionMask_Tpl);
        v8::Local<v8::Signature> SetCollisionHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCollisionHelper_Tpl =
            v8::FunctionTemplate::New(SetCollisionHelper, v8::Handle<v8::Value>(), SetCollisionHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setCollisionHelper"), SetCollisionHelper_Tpl);
        v8::Local<v8::Signature> SetElasticity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetElasticity_Tpl =
            v8::FunctionTemplate::New(SetElasticity, v8::Handle<v8::Value>(), SetElasticity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setElasticity"), SetElasticity_Tpl);
        v8::Local<v8::Signature> GetElasticity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetElasticity_Tpl =
            v8::FunctionTemplate::New(GetElasticity, v8::Handle<v8::Value>(), GetElasticity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getElasticity"), GetElasticity_Tpl);
        v8::Local<v8::Signature> GetLayer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetLayer_Tpl =
            v8::FunctionTemplate::New(GetLayer, v8::Handle<v8::Value>(), GetLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getLayer"), GetLayer_Tpl);
#ifndef PDG_NO_GUI
        v8::Local<v8::Signature> SetDrawHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetDrawHelper_Tpl =
            v8::FunctionTemplate::New(SetDrawHelper, v8::Handle<v8::Value>(), SetDrawHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setDrawHelper"), SetDrawHelper_Tpl);
        v8::Local<v8::Signature> SetPostDrawHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetPostDrawHelper_Tpl =
            v8::FunctionTemplate::New(SetPostDrawHelper, v8::Handle<v8::Value>(), SetPostDrawHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setPostDrawHelper"), SetPostDrawHelper_Tpl);
        v8::Local<v8::Signature> SetWantsMouseOverEvents_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWantsMouseOverEvents_Tpl =
            v8::FunctionTemplate::New(SetWantsMouseOverEvents, v8::Handle<v8::Value>(), SetWantsMouseOverEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setWantsMouseOverEvents"), SetWantsMouseOverEvents_Tpl);
        v8::Local<v8::Signature> SetWantsClickEvents_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWantsClickEvents_Tpl =
            v8::FunctionTemplate::New(SetWantsClickEvents, v8::Handle<v8::Value>(), SetWantsClickEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setWantsClickEvents"), SetWantsClickEvents_Tpl);
        v8::Local<v8::Signature> SetMouseDetectMode_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMouseDetectMode_Tpl =
            v8::FunctionTemplate::New(SetMouseDetectMode, v8::Handle<v8::Value>(), SetMouseDetectMode_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setMouseDetectMode"), SetMouseDetectMode_Tpl);
        v8::Local<v8::Signature> SetWantsOffscreenEvents_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWantsOffscreenEvents_Tpl =
            v8::FunctionTemplate::New(SetWantsOffscreenEvents, v8::Handle<v8::Value>(), SetWantsOffscreenEvents_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setWantsOffscreenEvents"), SetWantsOffscreenEvents_Tpl);
#endif
#ifdef PDG_USE_CHIPMUNK_PHYSICS
        v8::Local<v8::Signature> MakeStatic_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MakeStatic_Tpl =
            v8::FunctionTemplate::New(MakeStatic, v8::Handle<v8::Value>(), MakeStatic_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("makeStatic"), MakeStatic_Tpl);
        v8::Local<v8::Signature> GetFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetFriction_Tpl =
            v8::FunctionTemplate::New(GetFriction, v8::Handle<v8::Value>(), GetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getFriction"), GetFriction_Tpl);
        v8::Local<v8::Signature> SetCollideGroup_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCollideGroup_Tpl =
            v8::FunctionTemplate::New(SetCollideGroup, v8::Handle<v8::Value>(), SetCollideGroup_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setCollideGroup"), SetCollideGroup_Tpl);
        v8::Local<v8::Signature> GetCollideGroup_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCollideGroup_Tpl =
            v8::FunctionTemplate::New(GetCollideGroup, v8::Handle<v8::Value>(), GetCollideGroup_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getCollideGroup"), GetCollideGroup_Tpl);
        v8::Local<v8::Signature> PinJoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PinJoint_Tpl =
            v8::FunctionTemplate::New(PinJoint, v8::Handle<v8::Value>(), PinJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("pinJoint"), PinJoint_Tpl);
        v8::Local<v8::Signature> SlideJoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SlideJoint_Tpl =
            v8::FunctionTemplate::New(SlideJoint, v8::Handle<v8::Value>(), SlideJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("slideJoint"), SlideJoint_Tpl);
        v8::Local<v8::Signature> PivotJoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PivotJoint_Tpl =
            v8::FunctionTemplate::New(PivotJoint, v8::Handle<v8::Value>(), PivotJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("pivotJoint"), PivotJoint_Tpl);
        v8::Local<v8::Signature> GrooveJoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GrooveJoint_Tpl =
            v8::FunctionTemplate::New(GrooveJoint, v8::Handle<v8::Value>(), GrooveJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("grooveJoint"), GrooveJoint_Tpl);
        v8::Local<v8::Signature> SpringJoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SpringJoint_Tpl =
            v8::FunctionTemplate::New(SpringJoint, v8::Handle<v8::Value>(), SpringJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("springJoint"), SpringJoint_Tpl);
        v8::Local<v8::Signature> RotarySpring_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RotarySpring_Tpl =
            v8::FunctionTemplate::New(RotarySpring, v8::Handle<v8::Value>(), RotarySpring_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotarySpring"), RotarySpring_Tpl);
        v8::Local<v8::Signature> RotaryLimit_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RotaryLimit_Tpl =
            v8::FunctionTemplate::New(RotaryLimit, v8::Handle<v8::Value>(), RotaryLimit_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotaryLimit"), RotaryLimit_Tpl);
        v8::Local<v8::Signature> Ratchet_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Ratchet_Tpl =
            v8::FunctionTemplate::New(Ratchet, v8::Handle<v8::Value>(), Ratchet_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("ratchet"), Ratchet_Tpl);
        v8::Local<v8::Signature> Gear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Gear_Tpl =
            v8::FunctionTemplate::New(Gear, v8::Handle<v8::Value>(), Gear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("gear"), Gear_Tpl);
        v8::Local<v8::Signature> Motor_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Motor_Tpl =
            v8::FunctionTemplate::New(Motor, v8::Handle<v8::Value>(), Motor_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("motor"), Motor_Tpl);
        v8::Local<v8::Signature> RemoveJoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveJoint_Tpl =
            v8::FunctionTemplate::New(RemoveJoint, v8::Handle<v8::Value>(), RemoveJoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeJoint"), RemoveJoint_Tpl);
        v8::Local<v8::Signature> Disconnect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Disconnect_Tpl =
            v8::FunctionTemplate::New(Disconnect, v8::Handle<v8::Value>(), Disconnect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("disconnect"), Disconnect_Tpl);
        v8::Local<v8::Signature> MakeJointBreakable_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MakeJointBreakable_Tpl =
            v8::FunctionTemplate::New(MakeJointBreakable, v8::Handle<v8::Value>(), MakeJointBreakable_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("makeJointBreakable"), MakeJointBreakable_Tpl);
        v8::Local<v8::Signature> MakeJointUnbreakable_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MakeJointUnbreakable_Tpl =
            v8::FunctionTemplate::New(MakeJointUnbreakable, v8::Handle<v8::Value>(), MakeJointUnbreakable_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("makeJointUnbreakable"), MakeJointUnbreakable_Tpl);
#endif
        target->Set(v8::String::NewSymbol("Sprite"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> SpriteWrap::AddHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::RemoveHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                "If the handler is listed multiple times it will only remove it once.\n"
                "NOTE: inType == all_events doesn't work quite like you might expect. If "
                "you have registered a handler for multiple events, but not with all_events, "
                "doing removeHandler(handler, all_events) will do nothing. Basically, "
                "all_events is a special event type that matches all event types when "
                "considering whether to invoke a handler or not.\n"
                "It is safe to call remove handler from within an event handler's handleEvent() call."
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Clear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "remove all handlers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clear();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::BlockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                "Events that are blocked are NOT cached for later, they are just dropped."
                " \\param inEventType the type of event to block") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::UnblockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                " \\param inEventType the type of event to unblock") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        return scope.Close( v8_MakeJavascriptPoint(theLocation) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "([object Point] inLocation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(args[1 -1]);

        self->setLocation(theLocation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpeed = self->getSpeed();
        return scope.Close( v8::Number::New(theSpeed) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inSpeed)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theWidth = self->getWidth();
        return scope.Close( v8::Number::New(theWidth) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inWidth)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theHeight = self->getHeight();
        return scope.Close( v8::Number::New(theHeight) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inHeight)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theRotation = self->getRotation();
        return scope.Close( v8::Number::New(theRotation) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inRotation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        return scope.Close( v8_MakeJavascriptOffset(theCenterOffset) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "([object Offset] inCenterOffset)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpin = self->getSpin();
        return scope.Close( v8::Number::New(theSpin) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inSpin)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMass = self->getMass();
        return scope.Close( v8::Number::New(theMass) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inMass)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        return scope.Close( v8::Number::New(theMoveFriction) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inMoveFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        return scope.Close( v8::Number::New(theSpinFriction) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inSpinFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        return scope.Close( v8::Number::New(theSizeFriction) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Sprite" " function" "(number inSizeFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetBoundingBox(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> SpriteWrap::GetRotatedBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> SpriteWrap::Move(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            delta = v8_ValueToOffset(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::MoveTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(args[0]))
        {
            where = v8_ValueToPoint(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetVelocityInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number speed, number direction)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetMovementDirectionInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        return scope.Close( v8::Number::New(dir) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "({ ([object Vector] deltaPerSec) | (number deltaXPerSec, number deltaYPerSec) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(args[0]))
        {
            deltaPerSec = v8_ValueToVector(args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        return scope.Close( v8_MakeJavascriptVector(theVelocity) );
    }

    v8::Handle<v8::Value> SpriteWrap::StopMoving(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopMoving();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Accelerate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::AccelerateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number width, number height)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::Grow(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Stretch(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::StartGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number amountPerSecond)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::StopGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopGrowing();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::StartStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::StopStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopStretching();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Resize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::ResizeTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Rotate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::RotateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::StopSpinning(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopSpinning();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::ChangeCenter(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::ChangeCenterTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Wait(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "([number int] msDuration)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number frictionCoefficient)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::ApplyForce(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::ApplyTorque(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::StopAllForces(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopAllForces();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::AddAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        self->mAnimatedScriptObj = v8::Persistent<v8::Object>::New(args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::RemoveAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::ClearAnimationHelpers(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clearAnimationHelpers();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetMyClassTag(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        uint32 theMyClassTag = self->getMyClassTag();
        return scope.Close( v8::Integer::NewFromUnsigned(theMyClassTag) );
    }

    v8::Handle<v8::Value> SpriteWrap::GetSerializedSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR [number uint]" " function" "([object Serializer] serializer)" " - " "get size of this object's data for the given stream") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, serializer, Serializer);
        uint32 dataSize = self->getSerializedSize(serializer);
        return scope.Close( v8::Integer::NewFromUnsigned(dataSize) );
    }

    v8::Handle<v8::Value> SpriteWrap::Serialize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "([object Serializer] serializer)" " - " "write this object's data into the given stream") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, serializer, Serializer);
        self->serialize(serializer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Deserialize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "([object Deserializer] deserializer)" " - " "read this object's data from the given stream") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, deserializer, Deserializer);
        try
        {
            self->deserialize(deserializer);
            return scope.Close( v8::Undefined() );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(sync_error& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(unknown_object& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

    v8::Handle<v8::Value> SpriteWrap::GetFrameRotatedBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "([number int] frame)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""frame"")");
        long frame = args[1 -1]->Int32Value();
        pdg::RotatedRect r = self->getFrameRotatedBounds(frame);
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetFrame(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([number int] frame)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""frame"")");
        long frame = args[1 -1]->Int32Value();
        self->setFrame(frame);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetCurrentFrame(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "which frame of animation the sprite is currently showing") );
        };

        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        int frame = self->getCurrentFrame();
        return scope.Close( v8::Integer::New(frame) );
    }

    v8::Handle<v8::Value> SpriteWrap::GetFrameCount(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "total number of frames of animation for this sprite") );
        };

        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        int count = self->getFrameCount();
        return scope.Close( v8::Integer::New(count) );
    }

    v8::Handle<v8::Value> SpriteWrap::StartFrameAnimation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number fps, [number int] startingFrame = start_FromFirstFrame, [number int] numFrames = all_Frames, [number int] animateFlags = animate_Looping)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""fps"")");
        double fps = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""startingFrame"")");
        long startingFrame = (args.Length()<2) ? Sprite::start_FromFirstFrame : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""numFrames"")");
        long numFrames = (args.Length()<3) ? Sprite::all_Frames : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""animateFlags"")");
        long animateFlags = (args.Length()<4) ? Sprite::animate_Looping : args[4 -1]->Int32Value();;
        self->startFrameAnimation(fps, startingFrame, numFrames, animateFlags);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::StopFrameAnimation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopFrameAnimation();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetWantsAnimLoopEvents(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "(boolean wantsThem = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        bool wanted = self->setWantsAnimLoopEvents(wantsThem);
        return scope.Close( v8::Boolean::New(wanted) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetWantsAnimEndEvents(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "(boolean wantsThem = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        bool wanted = self->setWantsAnimEndEvents(wantsThem);
        return scope.Close( v8::Boolean::New(wanted) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetWantsCollideWallEvents(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsCollideWallEvents(wantsThem);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::AddFramesImage(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Image] image, [number int] startingFrame = start_FromFirstFrame, [number int] numFrames = all_Frames)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, image, Image);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""startingFrame"")");
        long startingFrame = (args.Length()<2) ? Sprite::start_FromFirstFrame : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""numFrames"")");
        long numFrames = (args.Length()<3) ? Sprite::all_Frames : args[3 -1]->Int32Value();;
        self->addFramesImage(image, startingFrame, numFrames);
        return scope.Close( v8::Undefined() );
    }
#ifdef PDG_SCML_SUPPORT

    v8::Handle<v8::Value> SpriteWrap::HasAnimation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "({ [number int] animationId | string animationName })" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        bool hasIt = false;
        if (args[0]->IsString())
        {
            if (!args[1 -1]->IsString())
                return v8_ThrowArgTypeException(1, "a string  (""animationName"")");
            v8::String::Utf8Value animationName_Str(args[1 -1]->ToString());
            const char* animationName = *animationName_Str;;
            hasIt = self->hasAnimation(animationName);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""animationId"")");
            unsigned long animationId = args[1 -1]->Uint32Value();
            hasIt = self->hasAnimation(animationId);
        }
        return scope.Close( v8::Boolean::New(hasIt) );
    }

    v8::Handle<v8::Value> SpriteWrap::StartAnimation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({ [number int] animationId | string animationName })" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (args[0]->IsString())
        {
            if (!args[1 -1]->IsString())
                return v8_ThrowArgTypeException(1, "a string  (""animationName"")");
            v8::String::Utf8Value animationName_Str(args[1 -1]->ToString());
            const char* animationName = *animationName_Str;;
            self->startAnimation(animationName);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""animationId"")");
            unsigned long animationId = args[1 -1]->Uint32Value();
            self->startAnimation(animationId);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetEntityScale(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(number xScale, number yScale)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""xScale"")");
        double xScale = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""yScale"")");
        double yScale = args[2 -1]->NumberValue();
        self->setEntityScale(xScale, yScale);
        return scope.Close( args.This() );
    }
#endif
#ifndef PDG_NO_GUI

    v8::Handle<v8::Value> SpriteWrap::SetWantsOffscreenEvents(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(boolean wantsThem = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setWantsOffscreenEvents(wantsThem);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetDrawHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object ISpriteDrawHelper] helper)" " - " "") );
        };
        self->mSpriteScriptObj = v8::Persistent<v8::Object>::New(args.This());
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_OR_NULL_ARG(1, helper, ISpriteDrawHelper);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteDrawHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""ISpriteDrawHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""ISpriteDrawHelper""\n";
                }
            }
            else
            {
                ISpriteDrawHelper* obj = dynamic_cast<ISpriteDrawHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""ISpriteDrawHelper"" ("<<(void*)obj<<")\n";
            }
        } )
            self->setDrawHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetPostDrawHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object ISpriteDrawHelper] helper)" " - " "") );
        };
        self->mSpriteScriptObj = v8::Persistent<v8::Object>::New(args.This());
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_OR_NULL_ARG(1, helper, ISpriteDrawHelper);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteDrawHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ISpriteDrawHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""ISpriteDrawHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""ISpriteDrawHelper""\n";
                }
            }
            else
            {
                ISpriteDrawHelper* obj = dynamic_cast<ISpriteDrawHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""ISpriteDrawHelper"" ("<<(void*)obj<<")\n";
            }
        } )
            self->setPostDrawHelper(helper);
        return scope.Close( v8::Undefined() );
    }
#endif

    v8::Handle<v8::Value> SpriteWrap::ChangeFramesImage(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Image] oldImage, [object Image] newImage)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        REQUIRE_NATIVE_OBJECT_ARG(1, oldImage, Image);
        REQUIRE_NATIVE_OBJECT_ARG(2, newImage, Image);
        self->changeFramesImage(oldImage, newImage);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::OffsetFrameCenters(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] offsetX, [number int] offsetY, [object Image] image = null, [number int] startingFrame = start_FromFirstFrame, [number int] numFrames = all_Frames)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""offsetX"")");
        long offsetX = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""offsetY"")");
        long offsetY = args[2 -1]->Int32Value();
        Image* image = 0;
        if (args.Length() >= 3)
        {
            if (!args[3 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(3, "an object of type ""Image"" (""image"")");
            }
            else
            {
                v8::Handle<v8::Object> image_ = args[3 -1]->ToObject();
                ImageWrap* image__ = jswrap::ObjectWrap::Unwrap<ImageWrap>(image_);
                image = image__->getNativeObject();
            }
        };
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""startingFrame"")");
        long startingFrame = (args.Length()<4) ? Sprite::start_FromFirstFrame : args[4 -1]->Int32Value();;
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""numFrames"")");
        long numFrames = (args.Length()<5) ? Sprite::all_Frames : args[5 -1]->Int32Value();;
        self->offsetFrameCenters(offsetX, offsetY, image, startingFrame, numFrames);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetFrameCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("Offset" " function" "([object Image] image = null, [number int] frameNum = 0)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        Image* image = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(1, "an object of type ""Image"" (""image"")");
            }
            else
            {
                v8::Handle<v8::Object> image_ = args[1 -1]->ToObject();
                ImageWrap* image__ = jswrap::ObjectWrap::Unwrap<ImageWrap>(image_);
                image = image__->getNativeObject();
            }
        };
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""frameNum"")");
        long frameNum = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        int offsetX;
        int offsetY;
        self->getFrameCenterOffset(offsetX, offsetY, image, frameNum);
        pdg::Offset offset(offsetX, offsetY);
        return scope.Close( v8_MakeJavascriptOffset(offset) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetOpacity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(number opacity)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""opacity"")");
        double opacity = args[1 -1]->NumberValue();
        self->setOpacity(opacity);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetOpacity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float opacity = self->getOpacity();
        return scope.Close( v8::Number::New(opacity) );
    }

    v8::Handle<v8::Value> SpriteWrap::FadeTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number targetOpacity, [number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""targetOpacity"")");
        double targetOpacity = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeTo(targetOpacity, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeTo(targetOpacity, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::FadeIn(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::FadeOut(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::IsBehind(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([object Sprite] sprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        bool behind = self->isBehind(sprite);
        return scope.Close( v8::Boolean::New(behind) );
    }

    v8::Handle<v8::Value> SpriteWrap::GetZOrder(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[number int]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        int zorder = self->getZOrder();
        return scope.Close( v8::Integer::New(zorder) );
    }

    v8::Handle<v8::Value> SpriteWrap::MoveBehind(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([object Sprite] sprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        self->moveBehind(sprite);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::MoveInFrontOf(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([object Sprite] sprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        self->moveInFrontOf(sprite);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::MoveToFront(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "put this sprite in front of all others in its layer") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->moveToFront();
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::MoveToBack(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "put this sprite behind all others in its layer") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->moveToBack();
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::EnableCollisions(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([number int] collisionType = collide_AlphaChannel)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""collisionType"")");
        long collisionType = (args.Length()<1) ? Sprite::collide_AlphaChannel : args[1 -1]->Int32Value();;
        self->enableCollisions(collisionType);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::DisableCollisions(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->disableCollisions();
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetCollisionRadius(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(number pixelRadius)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""pixelRadius"")");
        double pixelRadius = args[1 -1]->NumberValue();
        self->setCollisionRadius(pixelRadius);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetCollisionRadius(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float radius = self->getCollisionRadius();
        return scope.Close( v8::Number::New(radius) );
    }

    v8::Handle<v8::Value> SpriteWrap::UseCollisionMask(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Image] frameImage, [object Image] maskImage)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        REQUIRE_NATIVE_OBJECT_ARG(1, frameImage, Image);
        REQUIRE_NATIVE_OBJECT_ARG(2, maskImage, Image);
        self->useCollisionMask(frameImage, maskImage);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetCollisionHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object ISpriteCollideHelper] helper)" " - " "") );
        };
        self->mSpriteScriptObj = v8::Persistent<v8::Object>::New(args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                ISpriteCollideHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<ISpriteCollideHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<ISpriteCollideHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""ISpriteCollideHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""ISpriteCollideHelper""\n";
                }
            }
            else
            {
                ISpriteCollideHelper* obj = dynamic_cast<ISpriteCollideHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""ISpriteCollideHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, helper, ISpriteCollideHelper);
        self->setCollisionHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::SetElasticity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(number elasticity)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""elasticity"")");
        double elasticity = args[1 -1]->NumberValue();
        self->setElasticity(elasticity);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetElasticity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float elasticity = self->getElasticity();
        return scope.Close( v8::Number::New(elasticity) );
    }
#ifndef PDG_NO_GUI

    v8::Handle<v8::Value> SpriteWrap::SetWantsMouseOverEvents(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "(boolean wantsThem = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        bool wanted = self->setWantsMouseOverEvents(wantsThem);
        return scope.Close( v8::Boolean::New(wanted) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetWantsClickEvents(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "(boolean wantsThem = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""wantsThem"")");
        bool wantsThem = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        bool wanted = self->setWantsClickEvents(wantsThem);
        return scope.Close( v8::Boolean::New(wanted) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetMouseDetectMode(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([number int] collisionType = collide_BoundingBox)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""collisionType"")");
        long collisionType = (args.Length()<1) ? Sprite::collide_BoundingBox : args[1 -1]->Int32Value();;
        int oldMode = self->setMouseDetectMode(collisionType);
        return scope.Close( v8::Integer::New(oldMode) );
    }
#endif

    v8::Handle<v8::Value> SpriteWrap::GetLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object SpriteLayer]" " function" "()" " - " "get the layer that contains this sprite") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        SpriteLayer* layer = self->getLayer();
        if (!layer) return scope.Close( v8::Null() );
        if (layer->mSpriteLayerScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteLayerWrap::NewFromNative(layer);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( layer->mSpriteLayerScriptObj );
        };
    }
#ifdef PDG_USE_CHIPMUNK_PHYSICS

    v8::Handle<v8::Value> SpriteWrap::MakeStatic(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->makeStatic();
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float friction = self->getFriction();
        return scope.Close( v8::Number::New(friction) );
    }

    v8::Handle<v8::Value> SpriteWrap::SetCollideGroup(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([number int] group)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""group"")");
        long group = args[1 -1]->Int32Value();
        self->setCollideGroup(group);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteWrap::GetCollideGroup(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        long group = self->getCollideGroup();
        return scope.Close( v8::Integer::New(group) );
    }

    v8::Handle<v8::Value> SpriteWrap::PinJoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Offset] anchor, [object Sprite] otherSprite, [object Offset] otherAnchor, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset anchor = v8_ValueToOffset(args[1 -1]);
        REQUIRE_NATIVE_OBJECT_ARG(2, otherSprite, Sprite);
        if (!v8_ValueIsOffset(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Offset", *args[3 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(args[3 -1]);
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->pinJoint(anchor, otherSprite, otherAnchor, breakingForce);
        cpConstraintSetUserData(joint, (void*)sPinJointStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::SlideJoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Offset] anchor, [object Sprite] otherSprite, [object Offset] otherAnchor, number minDist, number maxDist, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 5)
            return v8_ThrowArgCountException(args.Length(), 5, true);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset anchor = v8_ValueToOffset(args[1 -1]);
        REQUIRE_NATIVE_OBJECT_ARG(2, otherSprite, Sprite);
        if (!v8_ValueIsOffset(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Offset", *args[3 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(args[3 -1]);
        if (!args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""minDist"")");
        double minDist = args[4 -1]->NumberValue();
        if (!args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""maxDist"")");
        double maxDist = args[5 -1]->NumberValue();
        if (args.Length() >= 6 && !args[6 -1]->IsNumber())
            return v8_ThrowArgTypeException(6, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<6) ? 0.0f : args[6 -1]->NumberValue();;
        cpConstraint* joint = self->slideJoint(anchor, otherSprite, otherAnchor, minDist, maxDist, breakingForce);
        cpConstraintSetUserData(joint, (void*)sSlideJointStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::PivotJoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Sprite] otherSprite, [object Point] pivot, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherSprite, Sprite);
        if (!v8_ValueIsPoint(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Point", *args[2 -1]);
        pdg::Point pivot = v8_ValueToPoint(args[2 -1]);
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<3) ? 0.0f : args[3 -1]->NumberValue();;
        cpConstraint* joint = self->pivotJoint(otherSprite, pivot, breakingForce);
        cpConstraintSetUserData(joint, (void*)sPivotJointStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::GrooveJoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Offset] grooveStart, [object Offset] grooveEnd, [object Sprite] otherSprite, [object Offset] otherAnchor, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 4)
            return v8_ThrowArgCountException(args.Length(), 4, true);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset grooveStart = v8_ValueToOffset(args[1 -1]);
        if (!v8_ValueIsOffset(args[2 -1]))
            return v8_ThrowArgTypeException(2, "Offset", *args[2 -1]);
        pdg::Offset grooveEnd = v8_ValueToOffset(args[2 -1]);
        REQUIRE_NATIVE_OBJECT_ARG(3, otherSprite, Sprite);
        if (!v8_ValueIsOffset(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Offset", *args[4 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(args[4 -1]);
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<5) ? 0.0f : args[5 -1]->NumberValue();;
        cpConstraint* joint = self->grooveJoint(grooveStart, grooveEnd, otherSprite, otherAnchor, breakingForce);
        cpConstraintSetUserData(joint, (void*)sGrooveJointStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::SpringJoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Offset] anchor, [object Sprite] otherSprite, [object Offset] otherAnchor, number restLength, number stiffness, number damping, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 6)
            return v8_ThrowArgCountException(args.Length(), 6, true);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset anchor = v8_ValueToOffset(args[1 -1]);
        REQUIRE_NATIVE_OBJECT_ARG(2, otherSprite, Sprite);
        if (!v8_ValueIsOffset(args[3 -1]))
            return v8_ThrowArgTypeException(3, "Offset", *args[3 -1]);
        pdg::Offset otherAnchor = v8_ValueToOffset(args[3 -1]);
        if (!args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""restLength"")");
        double restLength = args[4 -1]->NumberValue();
        if (!args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""stiffness"")");
        double stiffness = args[5 -1]->NumberValue();
        if (!args[6 -1]->IsNumber())
            return v8_ThrowArgTypeException(6, "a number (""damping"")");
        double damping = args[6 -1]->NumberValue();
        if (args.Length() >= 7 && !args[7 -1]->IsNumber())
            return v8_ThrowArgTypeException(7, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<7) ? 0.0f : args[7 -1]->NumberValue();;
        cpConstraint* joint = self->springJoint(anchor, otherSprite, otherAnchor, restLength, stiffness, damping, breakingForce);
        cpConstraintSetUserData(joint, (void*)sSpringJointStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::RotarySpring(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Sprite] otherSprite, number restAngle, number stiffness, number damping, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 4)
            return v8_ThrowArgCountException(args.Length(), 4, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""restAngle"")");
        double restAngle = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""stiffness"")");
        double stiffness = args[3 -1]->NumberValue();
        if (!args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""damping"")");
        double damping = args[4 -1]->NumberValue();
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<5) ? 0.0f : args[5 -1]->NumberValue();;
        cpConstraint* joint = self->rotarySpring(otherSprite, restAngle, stiffness, damping, breakingForce);
        cpConstraintSetUserData(joint, (void*)sRotarySpringStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::RotaryLimit(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Sprite] otherSprite, number minAngle, number maxAngle, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""minAngle"")");
        double minAngle = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""maxAngle"")");
        double maxAngle = args[3 -1]->NumberValue();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->rotaryLimit(otherSprite, minAngle, maxAngle, breakingForce);
        cpConstraintSetUserData(joint, (void*)sRotaryLimitStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::Ratchet(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Sprite] otherSprite, number rachetInterval, number phase, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""rachetInterval"")");
        double rachetInterval = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""phase"")");
        double phase = (args.Length()<3) ? 0.0f : args[3 -1]->NumberValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->ratchet(otherSprite, rachetInterval, phase, breakingForce);
        cpConstraintSetUserData(joint, (void*)sRatchetStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::Gear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Sprite] otherSprite, number gearRatio, number initialAngle = 0, number breakingForce = 0)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""gearRatio"")");
        double gearRatio = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""initialAngle"")");
        double initialAngle = (args.Length()<3) ? 0.0f : args[3 -1]->NumberValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""breakingForce"")");
        double breakingForce = (args.Length()<4) ? 0.0f : args[4 -1]->NumberValue();;
        cpConstraint* joint = self->gear(otherSprite, gearRatio, initialAngle, breakingForce);
        cpConstraintSetUserData(joint, (void*)sGearStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::Motor(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpConstraint]" " function" "([object Sprite] otherSprite, number spin, number maxTorque = INFINITY)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherSprite, Sprite);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""spin"")");
        double spin = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""maxTorque"")");
        double maxTorque = (args.Length()<3) ? std::numeric_limits<float>::infinity() : args[3 -1]->NumberValue();;
        cpConstraint* joint = self->motor(otherSprite, spin, maxTorque);
        cpConstraintSetUserData(joint, (void*)sMotorStr);
        if (!joint) return scope.Close( v8::Null() );
        return scope.Close( cpConstraintWrap::NewFromNative(joint) );;
    }

    v8::Handle<v8::Value> SpriteWrap::RemoveJoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object CpConstraint] joint)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, joint, cpConstraint);
        self->removeJoint(joint);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::Disconnect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Sprite] otherSprite)" " - " "") );
        };
        Sprite* otherSprite = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(1, "an object of type ""Sprite"" (""otherSprite"")");
            }
            else
            {
                v8::Handle<v8::Object> otherSprite_ = args[1 -1]->ToObject();
                SpriteWrap* otherSprite__ = jswrap::ObjectWrap::Unwrap<SpriteWrap>(otherSprite_);
                otherSprite = otherSprite__->getNativeObject();
            }
        };
        self->disconnect(otherSprite);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::MakeJointBreakable(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object CpConstraint] joint, number breakingForce)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        REQUIRE_NATIVE_OBJECT_ARG(1, joint, cpConstraint);
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""breakingForce"")");
        double breakingForce = args[2 -1]->NumberValue();
        self->makeJointBreakable(joint, breakingForce);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteWrap::MakeJointUnbreakable(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteWrap>(args.This());
        Sprite* self = dynamic_cast<Sprite*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object CpConstraint] joint)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, joint, cpConstraint);
        self->makeJointUnbreakable(joint);
        return scope.Close( v8::Undefined() );
    }
#endif

    void CleanupSpriteScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                SpriteWrap* obj__=jswrap::ObjectWrap::Unwrap<SpriteWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<SpriteWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""Sprite""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""Sprite""\n";
                }
            }
            else
            {
                Sprite* obj = dynamic_cast<Sprite*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""Sprite"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "Sprite" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    Sprite* New_Sprite(const v8::Arguments& args)
    {
        if (s_Sprite_InNewFromNative) return 0;
        return new Sprite();
    }

    static bool s_SpriteLayer_InNewFromNative = false;

    v8::Handle<v8::Value> SpriteLayerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = new SpriteLayerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> SpriteLayerWrap::NewFromNative(SpriteLayer* nativeObj)
    {
        s_SpriteLayer_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(obj);

        nativeObj->mEventEmitterScriptObj = obj; nativeObj->mAnimatedScriptObj = obj; nativeObj->mSpriteLayerScriptObj = obj;
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_SpriteLayer_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> SpriteLayerWrap::constructorTpl_;

    void SpriteLayerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("SpriteLayer"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(AddHandler, v8::Handle<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addHandler"), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(RemoveHandler, v8::Handle<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeHandler"), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(Clear, v8::Handle<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clear"), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(BlockEvent, v8::Handle<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("blockEvent"), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(UnblockEvent, v8::Handle<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unblockEvent"), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(GetBoundingBox, v8::Handle<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""BoundingBox"), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(GetRotatedBounds, v8::Handle<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RotatedBounds"), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(GetLocation, v8::Handle<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Location"), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(SetLocation, v8::Handle<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Location"), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(GetSpeed, v8::Handle<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Speed"), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(SetSpeed, v8::Handle<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Speed"), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(GetVelocity, v8::Handle<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Velocity"), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(SetVelocity, v8::Handle<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Velocity"), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(GetWidth, v8::Handle<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Width"), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(SetWidth, v8::Handle<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Width"), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(GetHeight, v8::Handle<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Height"), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(SetHeight, v8::Handle<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Height"), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(GetRotation, v8::Handle<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Rotation"), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(SetRotation, v8::Handle<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Rotation"), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(GetCenterOffset, v8::Handle<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""CenterOffset"), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(SetCenterOffset, v8::Handle<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""CenterOffset"), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(GetSpin, v8::Handle<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Spin"), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(SetSpin, v8::Handle<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Spin"), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(GetMass, v8::Handle<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Mass"), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(SetMass, v8::Handle<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Mass"), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(GetMoveFriction, v8::Handle<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MoveFriction"), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(SetMoveFriction, v8::Handle<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MoveFriction"), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(GetSpinFriction, v8::Handle<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SpinFriction"), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(SetSpinFriction, v8::Handle<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SpinFriction"), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(GetSizeFriction, v8::Handle<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SizeFriction"), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(SetSizeFriction, v8::Handle<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SizeFriction"), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(Move, v8::Handle<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("move"), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(MoveTo, v8::Handle<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveTo"), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(SetVelocityInRadians, v8::Handle<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setVelocityInRadians"), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(GetMovementDirectionInRadians, v8::Handle<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getMovementDirectionInRadians"), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(StopMoving, v8::Handle<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopMoving"), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(Accelerate, v8::Handle<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerate"), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(AccelerateTo, v8::Handle<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerateTo"), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(SetSize, v8::Handle<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSize"), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(Grow, v8::Handle<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("grow"), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(Stretch, v8::Handle<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stretch"), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(StartGrowing, v8::Handle<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startGrowing"), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(StopGrowing, v8::Handle<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopGrowing"), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(StartStretching, v8::Handle<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startStretching"), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(StopStretching, v8::Handle<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopStretching"), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(Resize, v8::Handle<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resize"), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(ResizeTo, v8::Handle<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resizeTo"), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(Rotate, v8::Handle<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotate"), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(RotateTo, v8::Handle<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotateTo"), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(StopSpinning, v8::Handle<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopSpinning"), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(ChangeCenter, v8::Handle<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenter"), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(ChangeCenterTo, v8::Handle<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenterTo"), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(Wait, v8::Handle<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("wait"), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(SetFriction, v8::Handle<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFriction"), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(ApplyForce, v8::Handle<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyForce"), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(ApplyTorque, v8::Handle<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyTorque"), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(StopAllForces, v8::Handle<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopAllForces"), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(AddAnimationHelper, v8::Handle<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addAnimationHelper"), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(RemoveAnimationHelper, v8::Handle<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeAnimationHelper"), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(ClearAnimationHelpers, v8::Handle<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clearAnimationHelpers"), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> GetMyClassTag_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMyClassTag_Tpl =
            v8::FunctionTemplate::New(GetMyClassTag, v8::Handle<v8::Value>(), GetMyClassTag_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MyClassTag"), GetMyClassTag_Tpl);
        v8::Local<v8::Signature> GetSerializedSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSerializedSize_Tpl =
            v8::FunctionTemplate::New(GetSerializedSize, v8::Handle<v8::Value>(), GetSerializedSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SerializedSize"), GetSerializedSize_Tpl);
        v8::Local<v8::Signature> Serialize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Serialize_Tpl =
            v8::FunctionTemplate::New(Serialize, v8::Handle<v8::Value>(), Serialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("serialize"), Serialize_Tpl);
        v8::Local<v8::Signature> Deserialize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Deserialize_Tpl =
            v8::FunctionTemplate::New(Deserialize, v8::Handle<v8::Value>(), Deserialize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("deserialize"), Deserialize_Tpl);
        v8::Local<v8::Signature> SetSerializationFlags_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSerializationFlags_Tpl =
            v8::FunctionTemplate::New(SetSerializationFlags, v8::Handle<v8::Value>(), SetSerializationFlags_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSerializationFlags"), SetSerializationFlags_Tpl);
        v8::Local<v8::Signature> StartAnimations_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartAnimations_Tpl =
            v8::FunctionTemplate::New(StartAnimations, v8::Handle<v8::Value>(), StartAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startAnimations"), StartAnimations_Tpl);
        v8::Local<v8::Signature> StopAnimations_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopAnimations_Tpl =
            v8::FunctionTemplate::New(StopAnimations, v8::Handle<v8::Value>(), StopAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopAnimations"), StopAnimations_Tpl);
        v8::Local<v8::Signature> Hide_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Hide_Tpl =
            v8::FunctionTemplate::New(Hide, v8::Handle<v8::Value>(), Hide_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("hide"), Hide_Tpl);
        v8::Local<v8::Signature> Show_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Show_Tpl =
            v8::FunctionTemplate::New(Show, v8::Handle<v8::Value>(), Show_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("show"), Show_Tpl);
        v8::Local<v8::Signature> IsHidden_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsHidden_Tpl =
            v8::FunctionTemplate::New(IsHidden, v8::Handle<v8::Value>(), IsHidden_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isHidden"), IsHidden_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(FadeIn, v8::Handle<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeIn"), FadeIn_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(FadeOut, v8::Handle<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeOut"), FadeOut_Tpl);
        v8::Local<v8::Signature> MoveBehind_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveBehind_Tpl =
            v8::FunctionTemplate::New(MoveBehind, v8::Handle<v8::Value>(), MoveBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveBehind"), MoveBehind_Tpl);
        v8::Local<v8::Signature> MoveInFrontOf_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveInFrontOf_Tpl =
            v8::FunctionTemplate::New(MoveInFrontOf, v8::Handle<v8::Value>(), MoveInFrontOf_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveInFrontOf"), MoveInFrontOf_Tpl);
        v8::Local<v8::Signature> MoveToFront_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveToFront_Tpl =
            v8::FunctionTemplate::New(MoveToFront, v8::Handle<v8::Value>(), MoveToFront_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveToFront"), MoveToFront_Tpl);
        v8::Local<v8::Signature> MoveToBack_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveToBack_Tpl =
            v8::FunctionTemplate::New(MoveToBack, v8::Handle<v8::Value>(), MoveToBack_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveToBack"), MoveToBack_Tpl);
        v8::Local<v8::Signature> GetZOrder_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetZOrder_Tpl =
            v8::FunctionTemplate::New(GetZOrder, v8::Handle<v8::Value>(), GetZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getZOrder"), GetZOrder_Tpl);
        v8::Local<v8::Signature> MoveWith_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveWith_Tpl =
            v8::FunctionTemplate::New(MoveWith, v8::Handle<v8::Value>(), MoveWith_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveWith"), MoveWith_Tpl);
        v8::Local<v8::Signature> FindSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FindSprite_Tpl =
            v8::FunctionTemplate::New(FindSprite, v8::Handle<v8::Value>(), FindSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("findSprite"), FindSprite_Tpl);
        v8::Local<v8::Signature> GetNthSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetNthSprite_Tpl =
            v8::FunctionTemplate::New(GetNthSprite, v8::Handle<v8::Value>(), GetNthSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getNthSprite"), GetNthSprite_Tpl);
        v8::Local<v8::Signature> GetSpriteZOrder_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpriteZOrder_Tpl =
            v8::FunctionTemplate::New(GetSpriteZOrder, v8::Handle<v8::Value>(), GetSpriteZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getSpriteZOrder"), GetSpriteZOrder_Tpl);
        v8::Local<v8::Signature> IsSpriteBehind_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsSpriteBehind_Tpl =
            v8::FunctionTemplate::New(IsSpriteBehind, v8::Handle<v8::Value>(), IsSpriteBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isSpriteBehind"), IsSpriteBehind_Tpl);
        v8::Local<v8::Signature> HasSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> HasSprite_Tpl =
            v8::FunctionTemplate::New(HasSprite, v8::Handle<v8::Value>(), HasSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("hasSprite"), HasSprite_Tpl);
        v8::Local<v8::Signature> AddSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddSprite_Tpl =
            v8::FunctionTemplate::New(AddSprite, v8::Handle<v8::Value>(), AddSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addSprite"), AddSprite_Tpl);
        v8::Local<v8::Signature> RemoveSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveSprite_Tpl =
            v8::FunctionTemplate::New(RemoveSprite, v8::Handle<v8::Value>(), RemoveSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeSprite"), RemoveSprite_Tpl);
        v8::Local<v8::Signature> RemoveAllSprites_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveAllSprites_Tpl =
            v8::FunctionTemplate::New(RemoveAllSprites, v8::Handle<v8::Value>(), RemoveAllSprites_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeAllSprites"), RemoveAllSprites_Tpl);
        v8::Local<v8::Signature> EnableCollisions_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> EnableCollisions_Tpl =
            v8::FunctionTemplate::New(EnableCollisions, v8::Handle<v8::Value>(), EnableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("enableCollisions"), EnableCollisions_Tpl);
        v8::Local<v8::Signature> DisableCollisions_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DisableCollisions_Tpl =
            v8::FunctionTemplate::New(DisableCollisions, v8::Handle<v8::Value>(), DisableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("disableCollisions"), DisableCollisions_Tpl);
        v8::Local<v8::Signature> EnableCollisionsWithLayer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> EnableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(EnableCollisionsWithLayer, v8::Handle<v8::Value>(), EnableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("enableCollisionsWithLayer"), EnableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> DisableCollisionsWithLayer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DisableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(DisableCollisionsWithLayer, v8::Handle<v8::Value>(), DisableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("disableCollisionsWithLayer"), DisableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> CreateSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateSprite_Tpl =
            v8::FunctionTemplate::New(CreateSprite, v8::Handle<v8::Value>(), CreateSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createSprite"), CreateSprite_Tpl);
#ifndef PDG_NO_GUI
        v8::Local<v8::Signature> GetSpritePort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpritePort_Tpl =
            v8::FunctionTemplate::New(GetSpritePort, v8::Handle<v8::Value>(), GetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getSpritePort"), GetSpritePort_Tpl);
        v8::Local<v8::Signature> SetSpritePort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpritePort_Tpl =
            v8::FunctionTemplate::New(SetSpritePort, v8::Handle<v8::Value>(), SetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSpritePort"), SetSpritePort_Tpl);
        v8::Local<v8::Signature> SetOrigin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetOrigin_Tpl =
            v8::FunctionTemplate::New(SetOrigin, v8::Handle<v8::Value>(), SetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setOrigin"), SetOrigin_Tpl);
        v8::Local<v8::Signature> GetOrigin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetOrigin_Tpl =
            v8::FunctionTemplate::New(GetOrigin, v8::Handle<v8::Value>(), GetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getOrigin"), GetOrigin_Tpl);
        v8::Local<v8::Signature> SetAutoCenter_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetAutoCenter_Tpl =
            v8::FunctionTemplate::New(SetAutoCenter, v8::Handle<v8::Value>(), SetAutoCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setAutoCenter"), SetAutoCenter_Tpl);
        v8::Local<v8::Signature> SetFixedMoveAxis_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFixedMoveAxis_Tpl =
            v8::FunctionTemplate::New(SetFixedMoveAxis, v8::Handle<v8::Value>(), SetFixedMoveAxis_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFixedMoveAxis"), SetFixedMoveAxis_Tpl);
        v8::Local<v8::Signature> SetZoom_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetZoom_Tpl =
            v8::FunctionTemplate::New(SetZoom, v8::Handle<v8::Value>(), SetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setZoom"), SetZoom_Tpl);
        v8::Local<v8::Signature> GetZoom_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetZoom_Tpl =
            v8::FunctionTemplate::New(GetZoom, v8::Handle<v8::Value>(), GetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getZoom"), GetZoom_Tpl);
        v8::Local<v8::Signature> ZoomTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ZoomTo_Tpl =
            v8::FunctionTemplate::New(ZoomTo, v8::Handle<v8::Value>(), ZoomTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("zoomTo"), ZoomTo_Tpl);
        v8::Local<v8::Signature> Zoom_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Zoom_Tpl =
            v8::FunctionTemplate::New(Zoom, v8::Handle<v8::Value>(), Zoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("zoom"), Zoom_Tpl);
        v8::Local<v8::Signature> LayerToPortPoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortPoint_Tpl =
            v8::FunctionTemplate::New(LayerToPortPoint, v8::Handle<v8::Value>(), LayerToPortPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortPoint"), LayerToPortPoint_Tpl);
        v8::Local<v8::Signature> LayerToPortOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortOffset_Tpl =
            v8::FunctionTemplate::New(LayerToPortOffset, v8::Handle<v8::Value>(), LayerToPortOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortOffset"), LayerToPortOffset_Tpl);
        v8::Local<v8::Signature> LayerToPortVector_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortVector_Tpl =
            v8::FunctionTemplate::New(LayerToPortVector, v8::Handle<v8::Value>(), LayerToPortVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortVector"), LayerToPortVector_Tpl);
        v8::Local<v8::Signature> LayerToPortRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortRect_Tpl =
            v8::FunctionTemplate::New(LayerToPortRect, v8::Handle<v8::Value>(), LayerToPortRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortRect"), LayerToPortRect_Tpl);
        v8::Local<v8::Signature> LayerToPortQuad_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortQuad_Tpl =
            v8::FunctionTemplate::New(LayerToPortQuad, v8::Handle<v8::Value>(), LayerToPortQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortQuad"), LayerToPortQuad_Tpl);
        v8::Local<v8::Signature> PortToLayerPoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerPoint_Tpl =
            v8::FunctionTemplate::New(PortToLayerPoint, v8::Handle<v8::Value>(), PortToLayerPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerPoint"), PortToLayerPoint_Tpl);
        v8::Local<v8::Signature> PortToLayerOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerOffset_Tpl =
            v8::FunctionTemplate::New(PortToLayerOffset, v8::Handle<v8::Value>(), PortToLayerOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerOffset"), PortToLayerOffset_Tpl);
        v8::Local<v8::Signature> PortToLayerVector_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerVector_Tpl =
            v8::FunctionTemplate::New(PortToLayerVector, v8::Handle<v8::Value>(), PortToLayerVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerVector"), PortToLayerVector_Tpl);
        v8::Local<v8::Signature> PortToLayerRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerRect_Tpl =
            v8::FunctionTemplate::New(PortToLayerRect, v8::Handle<v8::Value>(), PortToLayerRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerRect"), PortToLayerRect_Tpl);
        v8::Local<v8::Signature> PortToLayerQuad_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerQuad_Tpl =
            v8::FunctionTemplate::New(PortToLayerQuad, v8::Handle<v8::Value>(), PortToLayerQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerQuad"), PortToLayerQuad_Tpl);
#endif
#ifdef PDG_USE_CHIPMUNK_PHYSICS
        v8::Local<v8::Signature> SetGravity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetGravity_Tpl =
            v8::FunctionTemplate::New(SetGravity, v8::Handle<v8::Value>(), SetGravity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setGravity"), SetGravity_Tpl);
        v8::Local<v8::Signature> SetUseChipmunkPhysics_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetUseChipmunkPhysics_Tpl =
            v8::FunctionTemplate::New(SetUseChipmunkPhysics, v8::Handle<v8::Value>(), SetUseChipmunkPhysics_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setUseChipmunkPhysics"), SetUseChipmunkPhysics_Tpl);
        v8::Local<v8::Signature> SetStaticLayer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetStaticLayer_Tpl =
            v8::FunctionTemplate::New(SetStaticLayer, v8::Handle<v8::Value>(), SetStaticLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setStaticLayer"), SetStaticLayer_Tpl);
        v8::Local<v8::Signature> SetKeepGravityDownward_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetKeepGravityDownward_Tpl =
            v8::FunctionTemplate::New(SetKeepGravityDownward, v8::Handle<v8::Value>(), SetKeepGravityDownward_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setKeepGravityDownward"), SetKeepGravityDownward_Tpl);
        v8::Local<v8::Signature> SetDamping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetDamping_Tpl =
            v8::FunctionTemplate::New(SetDamping, v8::Handle<v8::Value>(), SetDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setDamping"), SetDamping_Tpl);
        v8::Local<v8::Signature> GetSpace_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpace_Tpl =
            v8::FunctionTemplate::New(GetSpace, v8::Handle<v8::Value>(), GetSpace_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getSpace"), GetSpace_Tpl);
#endif
#ifdef PDG_SCML_SUPPORT
        v8::Local<v8::Signature> CreateSpriteFromSCML_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateSpriteFromSCML_Tpl =
            v8::FunctionTemplate::New(CreateSpriteFromSCML, v8::Handle<v8::Value>(), CreateSpriteFromSCML_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createSpriteFromSCML"), CreateSpriteFromSCML_Tpl);
        v8::Local<v8::Signature> CreateSpriteFromSCMLFile_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateSpriteFromSCMLFile_Tpl =
            v8::FunctionTemplate::New(CreateSpriteFromSCMLFile, v8::Handle<v8::Value>(), CreateSpriteFromSCMLFile_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createSpriteFromSCMLFile"), CreateSpriteFromSCMLFile_Tpl);
        v8::Local<v8::Signature> CreateSpriteFromSCMLEntity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateSpriteFromSCMLEntity_Tpl =
            v8::FunctionTemplate::New(CreateSpriteFromSCMLEntity, v8::Handle<v8::Value>(), CreateSpriteFromSCMLEntity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createSpriteFromSCMLEntity"), CreateSpriteFromSCMLEntity_Tpl);
#endif
        target->Set(v8::String::NewSymbol("SpriteLayer"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> SpriteLayerWrap::AddHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::RemoveHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                "If the handler is listed multiple times it will only remove it once.\n"
                "NOTE: inType == all_events doesn't work quite like you might expect. If "
                "you have registered a handler for multiple events, but not with all_events, "
                "doing removeHandler(handler, all_events) will do nothing. Basically, "
                "all_events is a special event type that matches all event types when "
                "considering whether to invoke a handler or not.\n"
                "It is safe to call remove handler from within an event handler's handleEvent() call."
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Clear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "remove all handlers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clear();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::BlockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                "Events that are blocked are NOT cached for later, they are just dropped."
                " \\param inEventType the type of event to block") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::UnblockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                " \\param inEventType the type of event to unblock") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        return scope.Close( v8_MakeJavascriptPoint(theLocation) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "([object Point] inLocation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(args[1 -1]);

        self->setLocation(theLocation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpeed = self->getSpeed();
        return scope.Close( v8::Number::New(theSpeed) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inSpeed)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theWidth = self->getWidth();
        return scope.Close( v8::Number::New(theWidth) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inWidth)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theHeight = self->getHeight();
        return scope.Close( v8::Number::New(theHeight) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inHeight)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theRotation = self->getRotation();
        return scope.Close( v8::Number::New(theRotation) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inRotation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        return scope.Close( v8_MakeJavascriptOffset(theCenterOffset) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "([object Offset] inCenterOffset)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpin = self->getSpin();
        return scope.Close( v8::Number::New(theSpin) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inSpin)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMass = self->getMass();
        return scope.Close( v8::Number::New(theMass) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inMass)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        return scope.Close( v8::Number::New(theMoveFriction) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inMoveFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        return scope.Close( v8::Number::New(theSpinFriction) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inSpinFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        return scope.Close( v8::Number::New(theSizeFriction) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("SpriteLayer" " function" "(number inSizeFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetBoundingBox(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetRotatedBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Move(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            delta = v8_ValueToOffset(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::MoveTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(args[0]))
        {
            where = v8_ValueToPoint(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetVelocityInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number speed, number direction)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetMovementDirectionInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        return scope.Close( v8::Number::New(dir) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "({ ([object Vector] deltaPerSec) | (number deltaXPerSec, number deltaYPerSec) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(args[0]))
        {
            deltaPerSec = v8_ValueToVector(args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        return scope.Close( v8_MakeJavascriptVector(theVelocity) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StopMoving(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopMoving();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Accelerate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::AccelerateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number width, number height)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Grow(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Stretch(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StartGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number amountPerSecond)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StopGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopGrowing();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StartStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StopStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopStretching();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Resize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::ResizeTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Rotate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::RotateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StopSpinning(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopSpinning();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::ChangeCenter(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::ChangeCenterTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Wait(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "([number int] msDuration)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number frictionCoefficient)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::ApplyForce(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::ApplyTorque(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StopAllForces(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopAllForces();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::AddAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        self->mAnimatedScriptObj = v8::Persistent<v8::Object>::New(args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::RemoveAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::ClearAnimationHelpers(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clearAnimationHelpers();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetMyClassTag(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        uint32 theMyClassTag = self->getMyClassTag();
        return scope.Close( v8::Integer::NewFromUnsigned(theMyClassTag) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetSerializedSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR [number uint]" " function" "([object Serializer] serializer)" " - " "get size of this object's data for the given stream") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, serializer, Serializer);
        uint32 dataSize = self->getSerializedSize(serializer);
        return scope.Close( v8::Integer::NewFromUnsigned(dataSize) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Serialize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "([object Serializer] serializer)" " - " "write this object's data into the given stream") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, serializer, Serializer);
        self->serialize(serializer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Deserialize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("CR undefined" " function" "([object Deserializer] deserializer)" " - " "read this object's data from the given stream") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, deserializer, Deserializer);
        try
        {
            self->deserialize(deserializer);
            return scope.Close( v8::Undefined() );
        }
        catch(out_of_data& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(bad_tag& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(sync_error& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
        catch(unknown_object& e)
        {
            std::ostringstream excpt_;
            excpt_ << e.what();
            return v8::ThrowException( v8::Exception::Error( v8::String::New(excpt_.str().c_str())));
        }
    }

#ifndef PDG_NO_GUI

    v8::Handle<v8::Value> SpriteLayerWrap::GetSpritePort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Port]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Port* port = self->getSpritePort();
        if (!port) return scope.Close( v8::Null() );
        if (port->mPortScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = PortWrap::NewFromNative(port);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( port->mPortScriptObj );
        };
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetSpritePort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Port] port)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, port, Port);
        self->setSpritePort(port);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetOrigin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] origin)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point origin = v8_ValueToPoint(args[1 -1]);
        self->setOrigin(origin);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetOrigin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()" " - " "get the point in the layer that is drawn at 0,0 in the port") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Point p = self->getOrigin();
        return scope.Close( v8_MakeJavascriptPoint(p) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetAutoCenter(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean autoCenter = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""autoCenter"")");
        bool autoCenter = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setAutoCenter(autoCenter);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetFixedMoveAxis(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean fixedAxis = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""fixedAxis"")");
        bool fixedAxis = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setFixedMoveAxis(fixedAxis);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetZoom(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number zoomLevel)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        self->setZoom(zoomLevel);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetZoom(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "get the current zoom factor") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float zoom = self->getZoom();
        return scope.Close( v8::Number::New(zoom) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::ZoomTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number zoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(args[5 -1]))
            return v8_ThrowArgTypeException(5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoomTo(zoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoomTo(zoomLevel, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Zoom(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaZoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaZoomLevel"")");
        double deltaZoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(args[5 -1]))
            return v8_ThrowArgTypeException(5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoom(deltaZoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoom(deltaZoomLevel, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::LayerToPortPoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "([object Point] p)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(args[1 -1]);
        Point out = self->layerToPort(p);
        return scope.Close( v8_MakeJavascriptPoint(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::LayerToPortOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "([object Offset] o)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(args[1 -1]);
        Offset out = self->layerToPort(o);
        return scope.Close( v8_MakeJavascriptOffset(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::LayerToPortVector(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "([object Vector] v)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(args[1 -1]);
        Vector out = self->layerToPort(v);
        return scope.Close( v8_MakeJavascriptVector(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::LayerToPortRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "([object Rect] r)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsRotatedRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(args[1 -1]);
        RotatedRect out = self->layerToPort(r);
        return scope.Close( v8_MakeJavascriptRect(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::LayerToPortQuad(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Quad]" " function" "([object Quad] q)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(args[1 -1]);
        Quad out = self->layerToPort(q);
        return scope.Close( v8_MakeJavascriptQuad(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::PortToLayerPoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "([object Point] p)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(args[1 -1]);
        Point out = self->portToLayer(p);
        return scope.Close( v8_MakeJavascriptPoint(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::PortToLayerOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "([object Offset] o)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(args[1 -1]);
        Offset out = self->portToLayer(o);
        return scope.Close( v8_MakeJavascriptOffset(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::PortToLayerVector(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "([object Vector] v)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(args[1 -1]);
        Vector out = self->portToLayer(v);
        return scope.Close( v8_MakeJavascriptVector(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::PortToLayerRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "([object Rect] r)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsRotatedRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(args[1 -1]);
        RotatedRect out = self->portToLayer(r);
        return scope.Close( v8_MakeJavascriptRect(out) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::PortToLayerQuad(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Quad]" " function" "([object Quad] q)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(args[1 -1]);
        Quad out = self->portToLayer(q);
        return scope.Close( v8_MakeJavascriptQuad(out) );
    }
#endif

    v8::Handle<v8::Value> SpriteLayerWrap::SetSerializationFlags(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object SpriteLayer]" " function" "([number uint] flags)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""flags"")");
        unsigned long flags = args[1 -1]->Uint32Value();
        self->setSerializationFlags(flags);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StartAnimations(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->startAnimations();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::StopAnimations(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopAnimations();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Hide(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->hide();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::Show(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->show();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::IsHidden(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        bool hidden = self->isHidden();
        return scope.Close( v8::Boolean::New(hidden) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::FadeIn(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::FadeOut(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::MoveBehind(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] layer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveBehind(layer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::MoveInFrontOf(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] layer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveInFrontOf(layer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::MoveToFront(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "move this layer in front of all other layers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->moveToFront();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::MoveToBack(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "move this layer behind all other layers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->moveToBack();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::MoveWith(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("" " function" "([object SpriteLayer] layer, number moveRatio = 1.0, number zoomRatio = 1.0 )" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, layer, SpriteLayer);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""moveRatio"")");
        double moveRatio = (args.Length()<2) ? 1.0f : args[2 -1]->NumberValue();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""zoomRatio"")");
        double zoomRatio = (args.Length()<3) ? 1.0f : args[3 -1]->NumberValue();;
        self->moveWith(layer, moveRatio, zoomRatio);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::IsSpriteBehind(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([object Sprite] sprite, [object Sprite] otherSprite)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        REQUIRE_NATIVE_OBJECT_ARG(2, otherSprite, Sprite);
        bool behind = self->isSpriteBehind(sprite, otherSprite);
        return scope.Close( v8::Boolean::New(behind) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetZOrder(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[number int]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        int zorder = self->getZOrder();
        return scope.Close( v8::Integer::New(zorder) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetSpriteZOrder(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[number int]" " function" "([object Sprite] sprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        int zorder = self->getSpriteZOrder(sprite);
        return scope.Close( v8::Integer::New(zorder) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::FindSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([number int] id)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        Sprite* sprite = self->findSprite(id);
        if (!sprite) return scope.Close( v8::Null() );
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(sprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( sprite->mSpriteScriptObj );
        };
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetNthSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([number int] index)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""index"")");
        long index = args[1 -1]->Int32Value();
        Sprite* sprite = self->getNthSprite(index);
        if (!sprite) return scope.Close( v8::Null() );
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(sprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( sprite->mSpriteScriptObj );
        };
    }

    v8::Handle<v8::Value> SpriteLayerWrap::HasSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([object Sprite] sprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        bool found = self->hasSprite(sprite);
        return scope.Close( v8::Boolean::New(found) );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::AddSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Sprite] newSprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, newSprite, Sprite);
        self->addSprite(newSprite);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::RemoveSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Sprite] oldSprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, oldSprite, Sprite);
        self->removeSprite(oldSprite);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::RemoveAllSprites(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->removeAllSprites();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::EnableCollisions(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->enableCollisions();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::DisableCollisions(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->disableCollisions();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::EnableCollisionsWithLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->enableCollisionsWithLayer(otherLayer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::DisableCollisionsWithLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->disableCollisionsWithLayer(otherLayer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::CreateSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Sprite* sprite = self->createSprite();
        if (!sprite) return scope.Close( v8::Null() );
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(sprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( sprite->mSpriteScriptObj );
        };
    }

#ifdef PDG_USE_CHIPMUNK_PHYSICS

    v8::Handle<v8::Value> SpriteLayerWrap::SetKeepGravityDownward(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean keepItDownward = true)" " - " "") );
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setKeepGravityDownward(keepItDownward);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetGravity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number gravity, boolean keepItDownward = true)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""gravity"")");
        double gravity = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsBoolean())
            return v8_ThrowArgTypeException(2, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<2) ? true : args[2 -1]->BooleanValue();;
        self->setGravity(gravity, keepItDownward);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetDamping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number damping)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""damping"")");
        double damping = args[1 -1]->NumberValue();
        self->setDamping(damping);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetStaticLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean isStatic = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""isStatic"")");
        bool isStatic = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setStaticLayer(isStatic);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::SetUseChipmunkPhysics(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean useIt = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""useIt"")");
        bool useIt = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setUseChipmunkPhysics(useIt);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> SpriteLayerWrap::GetSpace(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpSpace]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        cpSpace* space = self->getSpace();
        if (!space) return scope.Close( v8::Null() );
        return scope.Close( cpSpaceWrap::NewFromNative(space) );;
    }
#endif

    v8::Handle<v8::Value> SpriteLayerWrap::CreateSpriteFromSCML(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(string inSCML, string inEntityName = null)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inSCML"")");
        v8::String::Utf8Value inSCML_Str(args[1 -1]->ToString());
        const char* inSCML = *inSCML_Str;;
        const char* inEntityName = 0;
        if (args.Length() >= 2 && args[1]->IsString())
        {
            if (!args[2 -1]->IsString())
                return v8_ThrowArgTypeException(2, "a string  (""entityName"")");
            v8::String::Utf8Value entityName_Str(args[2 -1]->ToString());
            const char* entityName = *entityName_Str;;
            inEntityName = entityName;
        }
        Sprite* sprite = self->createSpriteFromSCML(inSCML, inEntityName);
        if (!sprite) return scope.Close( v8::Null() );
        return scope.Close( SpriteWrap::NewFromNative(sprite) );;
    }

    v8::Handle<v8::Value> SpriteLayerWrap::CreateSpriteFromSCMLFile(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(string inFileName, string inEntityName = null)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inFileName"")");
        v8::String::Utf8Value inFileName_Str(args[1 -1]->ToString());
        const char* inFileName = *inFileName_Str;;
        const char* inEntityName = 0;
        if (args.Length() >= 2 && args[1]->IsString())
        {
            if (!args[2 -1]->IsString())
                return v8_ThrowArgTypeException(2, "a string  (""entityName"")");
            v8::String::Utf8Value entityName_Str(args[2 -1]->ToString());
            const char* entityName = *entityName_Str;;
            inEntityName = entityName;
        }
        Sprite* sprite = self->createSpriteFromSCMLFile(inFileName, inEntityName);
        if (!sprite) return scope.Close( v8::Null() );
        return scope.Close( SpriteWrap::NewFromNative(sprite) );;
    }

    v8::Handle<v8::Value> SpriteLayerWrap::CreateSpriteFromSCMLEntity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        SpriteLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(args.This());
        SpriteLayer* self = dynamic_cast<SpriteLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "(string inEntityName)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""inEntityName"")");
        v8::String::Utf8Value inEntityName_Str(args[1 -1]->ToString());
        const char* inEntityName = *inEntityName_Str;;
        Sprite* sprite = self->createSpriteFromSCMLEntity(inEntityName);
        if (!sprite) return scope.Close( v8::Null() );
        return scope.Close( SpriteWrap::NewFromNative(sprite) );;
    }

    void CleanupSpriteLayerScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                SpriteLayerWrap* obj__=jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<SpriteLayerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""SpriteLayer""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""SpriteLayer""\n";
                }
            }
            else
            {
                SpriteLayer* obj = dynamic_cast<SpriteLayer*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""SpriteLayer"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "SpriteLayer" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    SpriteLayer* New_SpriteLayer(const v8::Arguments& args)
    {
        if (s_SpriteLayer_InNewFromNative) return 0;
#ifndef PDG_NO_GUI
        Port* port = GraphicsManager::getSingletonInstance()->getMainPort();
        return createSpriteLayer(port);
#else
        return createSpriteLayer();
#endif
    }

    v8::Handle<v8::Value> CreateSpriteLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object SpriteLayer]" " function" "([object Port] port = null)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
#ifndef PDG_NO_GUI
        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Handle<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap<PortWrap>(port_);
                port = port__->getNativeObject();
            }
        };
        SpriteLayer* layer = createSpriteLayer(port);
#else
        SpriteLayer* layer = createSpriteLayer();
#endif
        if (!layer) return scope.Close( v8::Null() );
        if (layer->mSpriteLayerScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteLayerWrap::NewFromNative(layer);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( layer->mSpriteLayerScriptObj );
        };
    }

    v8::Handle<v8::Value> CreateSpriteLayerFromSCMLFile(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object SpriteLayer]" " function" "(string layerSCMLFilename, bool addSprites = true, [object Port] port = null)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsString())
            return v8_ThrowArgTypeException(1, "a string  (""layerSCMLFilename"")");
        v8::String::Utf8Value layerSCMLFilename_Str(args[1 -1]->ToString());
        const char* layerSCMLFilename = *layerSCMLFilename_Str;;
        if (args.Length() >= 2 && !args[2 -1]->IsBoolean())
            return v8_ThrowArgTypeException(2, "a boolean (""addSprites"")");
        bool addSprites = (args.Length()<2) ? true : args[2 -1]->BooleanValue();;
#ifndef PDG_NO_GUI
        Port* port = 0;
        if (args.Length() >= 3)
        {
            if (!args[3 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(3, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Handle<v8::Object> port_ = args[3 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap<PortWrap>(port_);
                port = port__->getNativeObject();
            }
        };
        SpriteLayer* layer = createSpriteLayerFromSCMLFile(layerSCMLFilename, addSprites, port);
#else
        SpriteLayer* layer = createSpriteLayerFromSCMLFile(layerSCMLFilename, addSprites);
#endif
        if (!layer) return scope.Close( v8::Null() );
        if (layer->mSpriteLayerScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteLayerWrap::NewFromNative(layer);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( layer->mSpriteLayerScriptObj );
        };
    }

    v8::Handle<v8::Value> CleanupSpriteLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] layer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, layer, SpriteLayer);
        cleanupSpriteLayer(layer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> CreateTileLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object TileLayer]" " function" "([object Port] port = null)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
#ifndef PDG_NO_GUI
        Port* port = 0;
        if (args.Length() >= 1)
        {
            if (!args[1 -1]->IsObject())
            {
                return v8_ThrowArgTypeException(1, "an object of type ""Port"" (""port"")");
            }
            else
            {
                v8::Handle<v8::Object> port_ = args[1 -1]->ToObject();
                PortWrap* port__ = jswrap::ObjectWrap::Unwrap<PortWrap>(port_);
                port = port__->getNativeObject();
            }
        };
        TileLayer* layer = createTileLayer(port);
#else
        TileLayer* layer = createTileLayer();
#endif
        if (!layer) return scope.Close( v8::Null() );
        if (layer->mTileLayerScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = TileLayerWrap::NewFromNative(layer);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( layer->mTileLayerScriptObj );
        };
    }

    ;
    ;

    static bool s_TileLayer_InNewFromNative = false;

    v8::Handle<v8::Value> TileLayerWrap::New(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = new TileLayerWrap(args);
        objWrapper->Wrap(args.This());
        ;
        if (s_HaveSavedError)
        {
            s_HaveSavedError = false;
            return v8::ThrowException(s_SavedError);
        };
        return args.This();
    }

    v8::Handle<v8::Value> TileLayerWrap::NewFromNative(TileLayer* nativeObj)
    {
        s_TileLayer_InNewFromNative = true;
        v8::HandleScope scope;
        v8::Local<v8::Object> instance =
            constructorTpl_->GetFunction()->NewInstance();
        v8::Persistent<v8::Object> obj =
            v8::Persistent<v8::Object>::New(instance);
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(obj);

        nativeObj->mEventEmitterScriptObj = obj; nativeObj->mAnimatedScriptObj = obj; nativeObj->mSpriteLayerScriptObj = obj; nativeObj->mTileLayerScriptObj = obj;
        DEBUG_ASSERT(objWrapper->refPtr_ == 0, "NewFromNative() already have native object!");
        if (objWrapper->refPtr_) delete objWrapper->refPtr_;
        objWrapper->refPtr_ = nativeObj;
        s_TileLayer_InNewFromNative = false;
        return scope.Close(obj);
    }

    v8::Persistent<v8::FunctionTemplate> TileLayerWrap::constructorTpl_;

    void TileLayerWrap::Init(v8::Handle<v8::Object> target)
    {

        v8::Local<v8::FunctionTemplate> t = v8::FunctionTemplate::New(New);
        t->InstanceTemplate()->SetInternalFieldCount(1);
        t->SetClassName(v8::String::NewSymbol("TileLayer"));
        constructorTpl_ = v8::Persistent<v8::FunctionTemplate>::New(t);
        v8::Local<v8::Signature> AddHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddHandler_Tpl =
            v8::FunctionTemplate::New(AddHandler, v8::Handle<v8::Value>(), AddHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addHandler"), AddHandler_Tpl);
        v8::Local<v8::Signature> RemoveHandler_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveHandler_Tpl =
            v8::FunctionTemplate::New(RemoveHandler, v8::Handle<v8::Value>(), RemoveHandler_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeHandler"), RemoveHandler_Tpl);
        v8::Local<v8::Signature> Clear_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Clear_Tpl =
            v8::FunctionTemplate::New(Clear, v8::Handle<v8::Value>(), Clear_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clear"), Clear_Tpl);
        v8::Local<v8::Signature> BlockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> BlockEvent_Tpl =
            v8::FunctionTemplate::New(BlockEvent, v8::Handle<v8::Value>(), BlockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("blockEvent"), BlockEvent_Tpl);
        v8::Local<v8::Signature> UnblockEvent_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> UnblockEvent_Tpl =
            v8::FunctionTemplate::New(UnblockEvent, v8::Handle<v8::Value>(), UnblockEvent_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("unblockEvent"), UnblockEvent_Tpl);
        v8::Local<v8::Signature> GetBoundingBox_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetBoundingBox_Tpl =
            v8::FunctionTemplate::New(GetBoundingBox, v8::Handle<v8::Value>(), GetBoundingBox_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""BoundingBox"), GetBoundingBox_Tpl);
        v8::Local<v8::Signature> GetRotatedBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotatedBounds_Tpl =
            v8::FunctionTemplate::New(GetRotatedBounds, v8::Handle<v8::Value>(), GetRotatedBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""RotatedBounds"), GetRotatedBounds_Tpl);
        v8::Local<v8::Signature> GetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetLocation_Tpl =
            v8::FunctionTemplate::New(GetLocation, v8::Handle<v8::Value>(), GetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Location"), GetLocation_Tpl);
        v8::Local<v8::Signature> SetLocation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetLocation_Tpl =
            v8::FunctionTemplate::New(SetLocation, v8::Handle<v8::Value>(), SetLocation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Location"), SetLocation_Tpl);
        v8::Local<v8::Signature> GetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpeed_Tpl =
            v8::FunctionTemplate::New(GetSpeed, v8::Handle<v8::Value>(), GetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Speed"), GetSpeed_Tpl);
        v8::Local<v8::Signature> SetSpeed_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpeed_Tpl =
            v8::FunctionTemplate::New(SetSpeed, v8::Handle<v8::Value>(), SetSpeed_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Speed"), SetSpeed_Tpl);
        v8::Local<v8::Signature> GetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetVelocity_Tpl =
            v8::FunctionTemplate::New(GetVelocity, v8::Handle<v8::Value>(), GetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Velocity"), GetVelocity_Tpl);
        v8::Local<v8::Signature> SetVelocity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocity_Tpl =
            v8::FunctionTemplate::New(SetVelocity, v8::Handle<v8::Value>(), SetVelocity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Velocity"), SetVelocity_Tpl);
        v8::Local<v8::Signature> GetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWidth_Tpl =
            v8::FunctionTemplate::New(GetWidth, v8::Handle<v8::Value>(), GetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Width"), GetWidth_Tpl);
        v8::Local<v8::Signature> SetWidth_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWidth_Tpl =
            v8::FunctionTemplate::New(SetWidth, v8::Handle<v8::Value>(), SetWidth_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Width"), SetWidth_Tpl);
        v8::Local<v8::Signature> GetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetHeight_Tpl =
            v8::FunctionTemplate::New(GetHeight, v8::Handle<v8::Value>(), GetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Height"), GetHeight_Tpl);
        v8::Local<v8::Signature> SetHeight_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetHeight_Tpl =
            v8::FunctionTemplate::New(SetHeight, v8::Handle<v8::Value>(), SetHeight_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Height"), SetHeight_Tpl);
        v8::Local<v8::Signature> GetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetRotation_Tpl =
            v8::FunctionTemplate::New(GetRotation, v8::Handle<v8::Value>(), GetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Rotation"), GetRotation_Tpl);
        v8::Local<v8::Signature> SetRotation_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetRotation_Tpl =
            v8::FunctionTemplate::New(SetRotation, v8::Handle<v8::Value>(), SetRotation_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Rotation"), SetRotation_Tpl);
        v8::Local<v8::Signature> GetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetCenterOffset_Tpl =
            v8::FunctionTemplate::New(GetCenterOffset, v8::Handle<v8::Value>(), GetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""CenterOffset"), GetCenterOffset_Tpl);
        v8::Local<v8::Signature> SetCenterOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetCenterOffset_Tpl =
            v8::FunctionTemplate::New(SetCenterOffset, v8::Handle<v8::Value>(), SetCenterOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""CenterOffset"), SetCenterOffset_Tpl);
        v8::Local<v8::Signature> GetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpin_Tpl =
            v8::FunctionTemplate::New(GetSpin, v8::Handle<v8::Value>(), GetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Spin"), GetSpin_Tpl);
        v8::Local<v8::Signature> SetSpin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpin_Tpl =
            v8::FunctionTemplate::New(SetSpin, v8::Handle<v8::Value>(), SetSpin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Spin"), SetSpin_Tpl);
        v8::Local<v8::Signature> GetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMass_Tpl =
            v8::FunctionTemplate::New(GetMass, v8::Handle<v8::Value>(), GetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""Mass"), GetMass_Tpl);
        v8::Local<v8::Signature> SetMass_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMass_Tpl =
            v8::FunctionTemplate::New(SetMass, v8::Handle<v8::Value>(), SetMass_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""Mass"), SetMass_Tpl);
        v8::Local<v8::Signature> GetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMoveFriction_Tpl =
            v8::FunctionTemplate::New(GetMoveFriction, v8::Handle<v8::Value>(), GetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""MoveFriction"), GetMoveFriction_Tpl);
        v8::Local<v8::Signature> SetMoveFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetMoveFriction_Tpl =
            v8::FunctionTemplate::New(SetMoveFriction, v8::Handle<v8::Value>(), SetMoveFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""MoveFriction"), SetMoveFriction_Tpl);
        v8::Local<v8::Signature> GetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpinFriction_Tpl =
            v8::FunctionTemplate::New(GetSpinFriction, v8::Handle<v8::Value>(), GetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SpinFriction"), GetSpinFriction_Tpl);
        v8::Local<v8::Signature> SetSpinFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpinFriction_Tpl =
            v8::FunctionTemplate::New(SetSpinFriction, v8::Handle<v8::Value>(), SetSpinFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SpinFriction"), SetSpinFriction_Tpl);
        v8::Local<v8::Signature> GetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSizeFriction_Tpl =
            v8::FunctionTemplate::New(GetSizeFriction, v8::Handle<v8::Value>(), GetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("get""SizeFriction"), GetSizeFriction_Tpl);
        v8::Local<v8::Signature> SetSizeFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSizeFriction_Tpl =
            v8::FunctionTemplate::New(SetSizeFriction, v8::Handle<v8::Value>(), SetSizeFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("set""SizeFriction"), SetSizeFriction_Tpl);
        v8::Local<v8::Signature> Move_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Move_Tpl =
            v8::FunctionTemplate::New(Move, v8::Handle<v8::Value>(), Move_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("move"), Move_Tpl);
        v8::Local<v8::Signature> MoveTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveTo_Tpl =
            v8::FunctionTemplate::New(MoveTo, v8::Handle<v8::Value>(), MoveTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveTo"), MoveTo_Tpl);
        v8::Local<v8::Signature> SetVelocityInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetVelocityInRadians_Tpl =
            v8::FunctionTemplate::New(SetVelocityInRadians, v8::Handle<v8::Value>(), SetVelocityInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setVelocityInRadians"), SetVelocityInRadians_Tpl);
        v8::Local<v8::Signature> GetMovementDirectionInRadians_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMovementDirectionInRadians_Tpl =
            v8::FunctionTemplate::New(GetMovementDirectionInRadians, v8::Handle<v8::Value>(), GetMovementDirectionInRadians_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getMovementDirectionInRadians"), GetMovementDirectionInRadians_Tpl);
        v8::Local<v8::Signature> StopMoving_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopMoving_Tpl =
            v8::FunctionTemplate::New(StopMoving, v8::Handle<v8::Value>(), StopMoving_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopMoving"), StopMoving_Tpl);
        v8::Local<v8::Signature> Accelerate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Accelerate_Tpl =
            v8::FunctionTemplate::New(Accelerate, v8::Handle<v8::Value>(), Accelerate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerate"), Accelerate_Tpl);
        v8::Local<v8::Signature> AccelerateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AccelerateTo_Tpl =
            v8::FunctionTemplate::New(AccelerateTo, v8::Handle<v8::Value>(), AccelerateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("accelerateTo"), AccelerateTo_Tpl);
        v8::Local<v8::Signature> SetSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSize_Tpl =
            v8::FunctionTemplate::New(SetSize, v8::Handle<v8::Value>(), SetSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSize"), SetSize_Tpl);
        v8::Local<v8::Signature> Grow_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Grow_Tpl =
            v8::FunctionTemplate::New(Grow, v8::Handle<v8::Value>(), Grow_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("grow"), Grow_Tpl);
        v8::Local<v8::Signature> Stretch_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Stretch_Tpl =
            v8::FunctionTemplate::New(Stretch, v8::Handle<v8::Value>(), Stretch_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stretch"), Stretch_Tpl);
        v8::Local<v8::Signature> StartGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartGrowing_Tpl =
            v8::FunctionTemplate::New(StartGrowing, v8::Handle<v8::Value>(), StartGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startGrowing"), StartGrowing_Tpl);
        v8::Local<v8::Signature> StopGrowing_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopGrowing_Tpl =
            v8::FunctionTemplate::New(StopGrowing, v8::Handle<v8::Value>(), StopGrowing_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopGrowing"), StopGrowing_Tpl);
        v8::Local<v8::Signature> StartStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartStretching_Tpl =
            v8::FunctionTemplate::New(StartStretching, v8::Handle<v8::Value>(), StartStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startStretching"), StartStretching_Tpl);
        v8::Local<v8::Signature> StopStretching_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopStretching_Tpl =
            v8::FunctionTemplate::New(StopStretching, v8::Handle<v8::Value>(), StopStretching_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopStretching"), StopStretching_Tpl);
        v8::Local<v8::Signature> Resize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Resize_Tpl =
            v8::FunctionTemplate::New(Resize, v8::Handle<v8::Value>(), Resize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resize"), Resize_Tpl);
        v8::Local<v8::Signature> ResizeTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ResizeTo_Tpl =
            v8::FunctionTemplate::New(ResizeTo, v8::Handle<v8::Value>(), ResizeTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("resizeTo"), ResizeTo_Tpl);
        v8::Local<v8::Signature> Rotate_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Rotate_Tpl =
            v8::FunctionTemplate::New(Rotate, v8::Handle<v8::Value>(), Rotate_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotate"), Rotate_Tpl);
        v8::Local<v8::Signature> RotateTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RotateTo_Tpl =
            v8::FunctionTemplate::New(RotateTo, v8::Handle<v8::Value>(), RotateTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("rotateTo"), RotateTo_Tpl);
        v8::Local<v8::Signature> StopSpinning_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopSpinning_Tpl =
            v8::FunctionTemplate::New(StopSpinning, v8::Handle<v8::Value>(), StopSpinning_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopSpinning"), StopSpinning_Tpl);
        v8::Local<v8::Signature> ChangeCenter_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenter_Tpl =
            v8::FunctionTemplate::New(ChangeCenter, v8::Handle<v8::Value>(), ChangeCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenter"), ChangeCenter_Tpl);
        v8::Local<v8::Signature> ChangeCenterTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ChangeCenterTo_Tpl =
            v8::FunctionTemplate::New(ChangeCenterTo, v8::Handle<v8::Value>(), ChangeCenterTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("changeCenterTo"), ChangeCenterTo_Tpl);
        v8::Local<v8::Signature> Wait_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Wait_Tpl =
            v8::FunctionTemplate::New(Wait, v8::Handle<v8::Value>(), Wait_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("wait"), Wait_Tpl);
        v8::Local<v8::Signature> SetFriction_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFriction_Tpl =
            v8::FunctionTemplate::New(SetFriction, v8::Handle<v8::Value>(), SetFriction_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFriction"), SetFriction_Tpl);
        v8::Local<v8::Signature> ApplyForce_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyForce_Tpl =
            v8::FunctionTemplate::New(ApplyForce, v8::Handle<v8::Value>(), ApplyForce_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyForce"), ApplyForce_Tpl);
        v8::Local<v8::Signature> ApplyTorque_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ApplyTorque_Tpl =
            v8::FunctionTemplate::New(ApplyTorque, v8::Handle<v8::Value>(), ApplyTorque_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("applyTorque"), ApplyTorque_Tpl);
        v8::Local<v8::Signature> StopAllForces_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopAllForces_Tpl =
            v8::FunctionTemplate::New(StopAllForces, v8::Handle<v8::Value>(), StopAllForces_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopAllForces"), StopAllForces_Tpl);
        v8::Local<v8::Signature> AddAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddAnimationHelper_Tpl =
            v8::FunctionTemplate::New(AddAnimationHelper, v8::Handle<v8::Value>(), AddAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addAnimationHelper"), AddAnimationHelper_Tpl);
        v8::Local<v8::Signature> RemoveAnimationHelper_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveAnimationHelper_Tpl =
            v8::FunctionTemplate::New(RemoveAnimationHelper, v8::Handle<v8::Value>(), RemoveAnimationHelper_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeAnimationHelper"), RemoveAnimationHelper_Tpl);
        v8::Local<v8::Signature> ClearAnimationHelpers_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ClearAnimationHelpers_Tpl =
            v8::FunctionTemplate::New(ClearAnimationHelpers, v8::Handle<v8::Value>(), ClearAnimationHelpers_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("clearAnimationHelpers"), ClearAnimationHelpers_Tpl);
        v8::Local<v8::Signature> SetSerializationFlags_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSerializationFlags_Tpl =
            v8::FunctionTemplate::New(SetSerializationFlags, v8::Handle<v8::Value>(), SetSerializationFlags_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSerializationFlags"), SetSerializationFlags_Tpl);
        v8::Local<v8::Signature> StartAnimations_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StartAnimations_Tpl =
            v8::FunctionTemplate::New(StartAnimations, v8::Handle<v8::Value>(), StartAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("startAnimations"), StartAnimations_Tpl);
        v8::Local<v8::Signature> StopAnimations_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> StopAnimations_Tpl =
            v8::FunctionTemplate::New(StopAnimations, v8::Handle<v8::Value>(), StopAnimations_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("stopAnimations"), StopAnimations_Tpl);
        v8::Local<v8::Signature> Hide_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Hide_Tpl =
            v8::FunctionTemplate::New(Hide, v8::Handle<v8::Value>(), Hide_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("hide"), Hide_Tpl);
        v8::Local<v8::Signature> Show_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Show_Tpl =
            v8::FunctionTemplate::New(Show, v8::Handle<v8::Value>(), Show_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("show"), Show_Tpl);
        v8::Local<v8::Signature> IsHidden_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsHidden_Tpl =
            v8::FunctionTemplate::New(IsHidden, v8::Handle<v8::Value>(), IsHidden_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isHidden"), IsHidden_Tpl);
        v8::Local<v8::Signature> FadeIn_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeIn_Tpl =
            v8::FunctionTemplate::New(FadeIn, v8::Handle<v8::Value>(), FadeIn_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeIn"), FadeIn_Tpl);
        v8::Local<v8::Signature> FadeOut_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FadeOut_Tpl =
            v8::FunctionTemplate::New(FadeOut, v8::Handle<v8::Value>(), FadeOut_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("fadeOut"), FadeOut_Tpl);
        v8::Local<v8::Signature> MoveBehind_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveBehind_Tpl =
            v8::FunctionTemplate::New(MoveBehind, v8::Handle<v8::Value>(), MoveBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveBehind"), MoveBehind_Tpl);
        v8::Local<v8::Signature> MoveInFrontOf_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveInFrontOf_Tpl =
            v8::FunctionTemplate::New(MoveInFrontOf, v8::Handle<v8::Value>(), MoveInFrontOf_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveInFrontOf"), MoveInFrontOf_Tpl);
        v8::Local<v8::Signature> MoveToFront_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveToFront_Tpl =
            v8::FunctionTemplate::New(MoveToFront, v8::Handle<v8::Value>(), MoveToFront_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveToFront"), MoveToFront_Tpl);
        v8::Local<v8::Signature> MoveToBack_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveToBack_Tpl =
            v8::FunctionTemplate::New(MoveToBack, v8::Handle<v8::Value>(), MoveToBack_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveToBack"), MoveToBack_Tpl);
        v8::Local<v8::Signature> GetZOrder_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetZOrder_Tpl =
            v8::FunctionTemplate::New(GetZOrder, v8::Handle<v8::Value>(), GetZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getZOrder"), GetZOrder_Tpl);
        v8::Local<v8::Signature> MoveWith_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> MoveWith_Tpl =
            v8::FunctionTemplate::New(MoveWith, v8::Handle<v8::Value>(), MoveWith_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("moveWith"), MoveWith_Tpl);
        v8::Local<v8::Signature> FindSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> FindSprite_Tpl =
            v8::FunctionTemplate::New(FindSprite, v8::Handle<v8::Value>(), FindSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("findSprite"), FindSprite_Tpl);
        v8::Local<v8::Signature> GetNthSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetNthSprite_Tpl =
            v8::FunctionTemplate::New(GetNthSprite, v8::Handle<v8::Value>(), GetNthSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getNthSprite"), GetNthSprite_Tpl);
        v8::Local<v8::Signature> GetSpriteZOrder_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpriteZOrder_Tpl =
            v8::FunctionTemplate::New(GetSpriteZOrder, v8::Handle<v8::Value>(), GetSpriteZOrder_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getSpriteZOrder"), GetSpriteZOrder_Tpl);
        v8::Local<v8::Signature> IsSpriteBehind_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> IsSpriteBehind_Tpl =
            v8::FunctionTemplate::New(IsSpriteBehind, v8::Handle<v8::Value>(), IsSpriteBehind_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("isSpriteBehind"), IsSpriteBehind_Tpl);
        v8::Local<v8::Signature> HasSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> HasSprite_Tpl =
            v8::FunctionTemplate::New(HasSprite, v8::Handle<v8::Value>(), HasSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("hasSprite"), HasSprite_Tpl);
        v8::Local<v8::Signature> AddSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> AddSprite_Tpl =
            v8::FunctionTemplate::New(AddSprite, v8::Handle<v8::Value>(), AddSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("addSprite"), AddSprite_Tpl);
        v8::Local<v8::Signature> RemoveSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveSprite_Tpl =
            v8::FunctionTemplate::New(RemoveSprite, v8::Handle<v8::Value>(), RemoveSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeSprite"), RemoveSprite_Tpl);
        v8::Local<v8::Signature> RemoveAllSprites_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> RemoveAllSprites_Tpl =
            v8::FunctionTemplate::New(RemoveAllSprites, v8::Handle<v8::Value>(), RemoveAllSprites_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("removeAllSprites"), RemoveAllSprites_Tpl);
        v8::Local<v8::Signature> EnableCollisions_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> EnableCollisions_Tpl =
            v8::FunctionTemplate::New(EnableCollisions, v8::Handle<v8::Value>(), EnableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("enableCollisions"), EnableCollisions_Tpl);
        v8::Local<v8::Signature> DisableCollisions_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DisableCollisions_Tpl =
            v8::FunctionTemplate::New(DisableCollisions, v8::Handle<v8::Value>(), DisableCollisions_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("disableCollisions"), DisableCollisions_Tpl);
        v8::Local<v8::Signature> EnableCollisionsWithLayer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> EnableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(EnableCollisionsWithLayer, v8::Handle<v8::Value>(), EnableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("enableCollisionsWithLayer"), EnableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> DisableCollisionsWithLayer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DisableCollisionsWithLayer_Tpl =
            v8::FunctionTemplate::New(DisableCollisionsWithLayer, v8::Handle<v8::Value>(), DisableCollisionsWithLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("disableCollisionsWithLayer"), DisableCollisionsWithLayer_Tpl);
        v8::Local<v8::Signature> CreateSprite_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CreateSprite_Tpl =
            v8::FunctionTemplate::New(CreateSprite, v8::Handle<v8::Value>(), CreateSprite_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("createSprite"), CreateSprite_Tpl);
#ifndef PDG_NO_GUI
        v8::Local<v8::Signature> GetSpritePort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpritePort_Tpl =
            v8::FunctionTemplate::New(GetSpritePort, v8::Handle<v8::Value>(), GetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getSpritePort"), GetSpritePort_Tpl);
        v8::Local<v8::Signature> SetSpritePort_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetSpritePort_Tpl =
            v8::FunctionTemplate::New(SetSpritePort, v8::Handle<v8::Value>(), SetSpritePort_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setSpritePort"), SetSpritePort_Tpl);
        v8::Local<v8::Signature> SetOrigin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetOrigin_Tpl =
            v8::FunctionTemplate::New(SetOrigin, v8::Handle<v8::Value>(), SetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setOrigin"), SetOrigin_Tpl);
        v8::Local<v8::Signature> GetOrigin_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetOrigin_Tpl =
            v8::FunctionTemplate::New(GetOrigin, v8::Handle<v8::Value>(), GetOrigin_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getOrigin"), GetOrigin_Tpl);
        v8::Local<v8::Signature> SetAutoCenter_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetAutoCenter_Tpl =
            v8::FunctionTemplate::New(SetAutoCenter, v8::Handle<v8::Value>(), SetAutoCenter_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setAutoCenter"), SetAutoCenter_Tpl);
        v8::Local<v8::Signature> SetFixedMoveAxis_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetFixedMoveAxis_Tpl =
            v8::FunctionTemplate::New(SetFixedMoveAxis, v8::Handle<v8::Value>(), SetFixedMoveAxis_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setFixedMoveAxis"), SetFixedMoveAxis_Tpl);
        v8::Local<v8::Signature> SetZoom_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetZoom_Tpl =
            v8::FunctionTemplate::New(SetZoom, v8::Handle<v8::Value>(), SetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setZoom"), SetZoom_Tpl);
        v8::Local<v8::Signature> GetZoom_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetZoom_Tpl =
            v8::FunctionTemplate::New(GetZoom, v8::Handle<v8::Value>(), GetZoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getZoom"), GetZoom_Tpl);
        v8::Local<v8::Signature> ZoomTo_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> ZoomTo_Tpl =
            v8::FunctionTemplate::New(ZoomTo, v8::Handle<v8::Value>(), ZoomTo_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("zoomTo"), ZoomTo_Tpl);
        v8::Local<v8::Signature> Zoom_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> Zoom_Tpl =
            v8::FunctionTemplate::New(Zoom, v8::Handle<v8::Value>(), Zoom_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("zoom"), Zoom_Tpl);
        v8::Local<v8::Signature> LayerToPortPoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortPoint_Tpl =
            v8::FunctionTemplate::New(LayerToPortPoint, v8::Handle<v8::Value>(), LayerToPortPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortPoint"), LayerToPortPoint_Tpl);
        v8::Local<v8::Signature> LayerToPortOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortOffset_Tpl =
            v8::FunctionTemplate::New(LayerToPortOffset, v8::Handle<v8::Value>(), LayerToPortOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortOffset"), LayerToPortOffset_Tpl);
        v8::Local<v8::Signature> LayerToPortVector_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortVector_Tpl =
            v8::FunctionTemplate::New(LayerToPortVector, v8::Handle<v8::Value>(), LayerToPortVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortVector"), LayerToPortVector_Tpl);
        v8::Local<v8::Signature> LayerToPortRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortRect_Tpl =
            v8::FunctionTemplate::New(LayerToPortRect, v8::Handle<v8::Value>(), LayerToPortRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortRect"), LayerToPortRect_Tpl);
        v8::Local<v8::Signature> LayerToPortQuad_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LayerToPortQuad_Tpl =
            v8::FunctionTemplate::New(LayerToPortQuad, v8::Handle<v8::Value>(), LayerToPortQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("layerToPortQuad"), LayerToPortQuad_Tpl);
        v8::Local<v8::Signature> PortToLayerPoint_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerPoint_Tpl =
            v8::FunctionTemplate::New(PortToLayerPoint, v8::Handle<v8::Value>(), PortToLayerPoint_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerPoint"), PortToLayerPoint_Tpl);
        v8::Local<v8::Signature> PortToLayerOffset_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerOffset_Tpl =
            v8::FunctionTemplate::New(PortToLayerOffset, v8::Handle<v8::Value>(), PortToLayerOffset_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerOffset"), PortToLayerOffset_Tpl);
        v8::Local<v8::Signature> PortToLayerVector_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerVector_Tpl =
            v8::FunctionTemplate::New(PortToLayerVector, v8::Handle<v8::Value>(), PortToLayerVector_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerVector"), PortToLayerVector_Tpl);
        v8::Local<v8::Signature> PortToLayerRect_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerRect_Tpl =
            v8::FunctionTemplate::New(PortToLayerRect, v8::Handle<v8::Value>(), PortToLayerRect_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerRect"), PortToLayerRect_Tpl);
        v8::Local<v8::Signature> PortToLayerQuad_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> PortToLayerQuad_Tpl =
            v8::FunctionTemplate::New(PortToLayerQuad, v8::Handle<v8::Value>(), PortToLayerQuad_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("portToLayerQuad"), PortToLayerQuad_Tpl);
#endif
#ifdef PDG_USE_CHIPMUNK_PHYSICS
        v8::Local<v8::Signature> SetGravity_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetGravity_Tpl =
            v8::FunctionTemplate::New(SetGravity, v8::Handle<v8::Value>(), SetGravity_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setGravity"), SetGravity_Tpl);
        v8::Local<v8::Signature> SetUseChipmunkPhysics_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetUseChipmunkPhysics_Tpl =
            v8::FunctionTemplate::New(SetUseChipmunkPhysics, v8::Handle<v8::Value>(), SetUseChipmunkPhysics_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setUseChipmunkPhysics"), SetUseChipmunkPhysics_Tpl);
        v8::Local<v8::Signature> SetStaticLayer_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetStaticLayer_Tpl =
            v8::FunctionTemplate::New(SetStaticLayer, v8::Handle<v8::Value>(), SetStaticLayer_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setStaticLayer"), SetStaticLayer_Tpl);
        v8::Local<v8::Signature> SetKeepGravityDownward_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetKeepGravityDownward_Tpl =
            v8::FunctionTemplate::New(SetKeepGravityDownward, v8::Handle<v8::Value>(), SetKeepGravityDownward_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setKeepGravityDownward"), SetKeepGravityDownward_Tpl);
        v8::Local<v8::Signature> SetDamping_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetDamping_Tpl =
            v8::FunctionTemplate::New(SetDamping, v8::Handle<v8::Value>(), SetDamping_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setDamping"), SetDamping_Tpl);
        v8::Local<v8::Signature> GetSpace_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetSpace_Tpl =
            v8::FunctionTemplate::New(GetSpace, v8::Handle<v8::Value>(), GetSpace_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getSpace"), GetSpace_Tpl);
#endif
        v8::Local<v8::Signature> SetWorldSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetWorldSize_Tpl =
            v8::FunctionTemplate::New(SetWorldSize, v8::Handle<v8::Value>(), SetWorldSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setWorldSize"), SetWorldSize_Tpl);
        v8::Local<v8::Signature> GetWorldSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWorldSize_Tpl =
            v8::FunctionTemplate::New(GetWorldSize, v8::Handle<v8::Value>(), GetWorldSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getWorldSize"), GetWorldSize_Tpl);
        v8::Local<v8::Signature> GetWorldBounds_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetWorldBounds_Tpl =
            v8::FunctionTemplate::New(GetWorldBounds, v8::Handle<v8::Value>(), GetWorldBounds_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getWorldBounds"), GetWorldBounds_Tpl);
        v8::Local<v8::Signature> DefineTileSet_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> DefineTileSet_Tpl =
            v8::FunctionTemplate::New(DefineTileSet, v8::Handle<v8::Value>(), DefineTileSet_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("defineTileSet"), DefineTileSet_Tpl);
        v8::Local<v8::Signature> LoadMapData_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> LoadMapData_Tpl =
            v8::FunctionTemplate::New(LoadMapData, v8::Handle<v8::Value>(), LoadMapData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("loadMapData"), LoadMapData_Tpl);
        v8::Local<v8::Signature> GetMapData_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetMapData_Tpl =
            v8::FunctionTemplate::New(GetMapData, v8::Handle<v8::Value>(), GetMapData_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getMapData"), GetMapData_Tpl);
        v8::Local<v8::Signature> GetTileSetImage_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTileSetImage_Tpl =
            v8::FunctionTemplate::New(GetTileSetImage, v8::Handle<v8::Value>(), GetTileSetImage_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getTileSetImage"), GetTileSetImage_Tpl);
        v8::Local<v8::Signature> GetTileSize_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTileSize_Tpl =
            v8::FunctionTemplate::New(GetTileSize, v8::Handle<v8::Value>(), GetTileSize_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getTileSize"), GetTileSize_Tpl);
        v8::Local<v8::Signature> GetTileTypeAt_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTileTypeAt_Tpl =
            v8::FunctionTemplate::New(GetTileTypeAt, v8::Handle<v8::Value>(), GetTileTypeAt_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getTileTypeAt"), GetTileTypeAt_Tpl);
        v8::Local<v8::Signature> GetTileTypeAndFacingAt_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> GetTileTypeAndFacingAt_Tpl =
            v8::FunctionTemplate::New(GetTileTypeAndFacingAt, v8::Handle<v8::Value>(), GetTileTypeAndFacingAt_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("getTileTypeAndFacingAt"), GetTileTypeAndFacingAt_Tpl);
        v8::Local<v8::Signature> SetTileTypeAt_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> SetTileTypeAt_Tpl =
            v8::FunctionTemplate::New(SetTileTypeAt, v8::Handle<v8::Value>(), SetTileTypeAt_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("setTileTypeAt"), SetTileTypeAt_Tpl);
        v8::Local<v8::Signature> CheckCollision_Sig = v8::Signature::New(t);
        v8::Local<v8::FunctionTemplate> CheckCollision_Tpl =
            v8::FunctionTemplate::New(CheckCollision, v8::Handle<v8::Value>(), CheckCollision_Sig);
        t->PrototypeTemplate()->Set(v8::String::NewSymbol("checkCollision"), CheckCollision_Tpl);
        target->Set(v8::String::NewSymbol("TileLayer"), constructorTpl_->GetFunction());

    }

    v8::Handle<v8::Value> TileLayerWrap::AddHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "add a new handler for some event type, or for all events if no type specified. "
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to handle") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IEventHandlerWrap* obj__=jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IEventHandlerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IEventHandler""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IEventHandler""\n";
                }
            }
            else
            {
                IEventHandler* obj = dynamic_cast<IEventHandler*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IEventHandler"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->addHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::RemoveHandler(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IEventHandler] inHandler, [number int] inEventType = all_events)" " - " "remove a handler for some event type, or for all events (see note) if no type specified. "
                "If the handler is listed multiple times it will only remove it once.\n"
                "NOTE: inType == all_events doesn't work quite like you might expect. If "
                "you have registered a handler for multiple events, but not with all_events, "
                "doing removeHandler(handler, all_events) will do nothing. Basically, "
                "all_events is a special event type that matches all event types when "
                "considering whether to invoke a handler or not.\n"
                "It is safe to call remove handler from within an event handler's handleEvent() call."
                " \\param inHandler the object to handle events" " \\param inEventType the type of event to stop handling (see note)") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, inHandler, IEventHandler);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""inType"")");
        long inType = (args.Length()<2) ? pdg::all_events : args[2 -1]->Int32Value();;
        self->removeHandler(inHandler, inType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Clear(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "remove all handlers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clear();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::BlockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "temporarily ignore all events of a particular type. "
                "Events that are blocked are NOT cached for later, they are just dropped."
                " \\param inEventType the type of event to block") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->blockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::UnblockEvent(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] inEventType)" " - " "stop ignoring events of a particular type "
                " \\param inEventType the type of event to unblock") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""inEventType"")");
        long inEventType = args[1 -1]->Int32Value();
        self->unblockEvent(inEventType);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Point theLocation = self->getLocation();
        return scope.Close( v8_MakeJavascriptPoint(theLocation) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetLocation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "([object Point] inLocation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point theLocation = v8_ValueToPoint(args[1 -1]);

        self->setLocation(theLocation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpeed = self->getSpeed();
        return scope.Close( v8::Number::New(theSpeed) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetSpeed(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inSpeed)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpeed"")");
        double theSpeed = args[1 -1]->NumberValue();

        self->setSpeed(theSpeed);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theWidth = self->getWidth();
        return scope.Close( v8::Number::New(theWidth) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetWidth(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inWidth)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theWidth"")");
        double theWidth = args[1 -1]->NumberValue();

        self->setWidth(theWidth);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theHeight = self->getHeight();
        return scope.Close( v8::Number::New(theHeight) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetHeight(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inHeight)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theHeight"")");
        double theHeight = args[1 -1]->NumberValue();

        self->setHeight(theHeight);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theRotation = self->getRotation();
        return scope.Close( v8::Number::New(theRotation) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetRotation(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inRotation)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theRotation"")");
        double theRotation = args[1 -1]->NumberValue();

        self->setRotation(theRotation);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Offset theCenterOffset = self->getCenterOffset();
        return scope.Close( v8_MakeJavascriptOffset(theCenterOffset) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetCenterOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "([object Offset] inCenterOffset)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset theCenterOffset = v8_ValueToOffset(args[1 -1]);

        self->setCenterOffset(theCenterOffset);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpin = self->getSpin();
        return scope.Close( v8::Number::New(theSpin) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetSpin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inSpin)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpin"")");
        double theSpin = args[1 -1]->NumberValue();

        self->setSpin(theSpin);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMass = self->getMass();
        return scope.Close( v8::Number::New(theMass) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetMass(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inMass)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMass"")");
        double theMass = args[1 -1]->NumberValue();

        self->setMass(theMass);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theMoveFriction = self->getMoveFriction();
        return scope.Close( v8::Number::New(theMoveFriction) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetMoveFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inMoveFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theMoveFriction"")");
        double theMoveFriction = args[1 -1]->NumberValue();

        self->setMoveFriction(theMoveFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSpinFriction = self->getSpinFriction();
        return scope.Close( v8::Number::New(theSpinFriction) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetSpinFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inSpinFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSpinFriction"")");
        double theSpinFriction = args[1 -1]->NumberValue();

        self->setSpinFriction(theSpinFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        double theSizeFriction = self->getSizeFriction();
        return scope.Close( v8::Number::New(theSizeFriction) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetSizeFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("TileLayer" " function" "(number inSizeFriction)") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""theSizeFriction"")");
        double theSizeFriction = args[1 -1]->NumberValue();

        self->setSizeFriction(theSizeFriction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetBoundingBox(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::Rect r = self->getBoundingBox();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetRotatedBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg::RotatedRect r = self->getRotatedBounds();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> TileLayerWrap::Move(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] delta, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Offset delta;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            delta = v8_ValueToOffset(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration_2"")");
            long msDuration_2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            msDuration = msDuration_2;
            easing = easing_3;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaX"")");
            double deltaX = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaY"")");
            double deltaY = args[2 -1]->NumberValue();
            delta.x = deltaX;
            delta.y = deltaY;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration_3"")");
            long msDuration_3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            msDuration = msDuration_3;
            easing = easing_4;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->move(delta, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->move(delta, msDuration);
            }
        }
        else
        {
            self->move(delta);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::MoveTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] where, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Point where;
        int32 msDuration;
        int easing;
        if (v8_ValueIsPoint(args[0]))
        {
            where = v8_ValueToPoint(args[0]);
            if (args.Length() >= 2 && !args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""x"")");
            double x = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""y"")");
            double y = args[2 -1]->NumberValue();
            where.x = x;
            where.y = y;
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (msDuration || self->mDelayMs)
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->moveTo(where, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->moveTo(where, msDuration);
            }
        }
        else
        {
            self->moveTo(where);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetVelocityInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number speed, number direction)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""direction"")");
        double direction = args[2 -1]->NumberValue();
        self->setVelocityInRadians(speed, direction);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetMovementDirectionInRadians(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float dir = self->getMovementDirectionInRadians();
        return scope.Close( v8::Number::New(dir) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "({ ([object Vector] deltaPerSec) | (number deltaXPerSec, number deltaYPerSec) })" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        pdg::Vector deltaPerSec;
        if (v8_ValueIsVector(args[0]))
        {
            deltaPerSec = v8_ValueToVector(args[0]);
            self->setVelocity(deltaPerSec);
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXPerSec"")");
            double deltaXPerSec = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYPerSec"")");
            double deltaYPerSec = args[2 -1]->NumberValue();
            self->setVelocity(Vector(deltaXPerSec, deltaYPerSec));
        }
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetVelocity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "()") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);

        pdg::Vector theVelocity = self->getVelocity();
        return scope.Close( v8_MakeJavascriptVector(theVelocity) );
    }

    v8::Handle<v8::Value> TileLayerWrap::StopMoving(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopMoving();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Accelerate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaSpeed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaSpeed"")");
        double deltaSpeed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerate(deltaSpeed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerate(deltaSpeed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::AccelerateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number speed, [number int] msDuration = duration_Instantaneous, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""speed"")");
        double speed = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::linearTween : args[3 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->accelerateTo(speed, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->accelerateTo(speed, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number width, number height)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        self->setSize(width, height);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Grow(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number factor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""factor"")");
        double factor = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->grow(factor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->grow(factor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->grow(factor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Stretch(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthFactor, number heightFactor, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthFactor"")");
        double widthFactor = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightFactor"")");
        double heightFactor = args[2 -1]->NumberValue();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->stretch(widthFactor, heightFactor);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->stretch(widthFactor, heightFactor, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->stretch(widthFactor, heightFactor, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StartGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number amountPerSecond)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""amountPerSecond"")");
        double amountPerSecond = args[1 -1]->NumberValue();
        self->startGrowing(amountPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StopGrowing(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopGrowing();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StartStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number widthPerSecond, number heightPerSecond)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""widthPerSecond"")");
        double widthPerSecond = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""heightPerSecond"")");
        double heightPerSecond = args[2 -1]->NumberValue();
        self->startStretching(widthPerSecond, heightPerSecond);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StopStretching(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopStretching();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Resize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaWidth, number deltaHeight, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaWidth"")");
        double deltaWidth = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""deltaHeight"")");
        double deltaHeight = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resize(deltaWidth, deltaHeight, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resize(deltaWidth, deltaHeight, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::ResizeTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number width, number height, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        double width = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        double height = args[2 -1]->NumberValue();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""msDuration"")");
        long msDuration = args[3 -1]->Int32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""easing"")");
        long easing = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->resizeTo(width, height, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->resizeTo(width, height, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Rotate(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radians, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radians"")");
        double radians = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotate(radians);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotate(radians, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotate(radians, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::RotateTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number radiansRotation, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""radiansRotation"")");
        double radiansRotation = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (msDuration == 0)
        {
            self->rotateTo(radiansRotation);
        }
        else
        {
            if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
            {
                self->rotateTo(radiansRotation, msDuration, gEasingFunctions[easing]);
            }
            else
            {
                self->rotateTo(radiansRotation, msDuration);
            }
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StopSpinning(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopSpinning();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::ChangeCenter(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenter(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenter(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::ChangeCenterTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Offset] offset, [number int] msDuration = duration_Instantaneous, [number int] easing = easeInOutQuad)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        pdg::Offset offset;
        int32 msDuration;
        int easing;
        if (v8_ValueIsOffset(args[0]))
        {
            offset = v8_ValueToOffset(args[0]);
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""msDuration2"")");
            long msDuration2 = args[2 -1]->Int32Value();
            if (args.Length() >= 3 && !args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""easing_3"")");
            long easing_3 = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
            easing = easing_3;
            msDuration = msDuration2;
        }
        else
        {
            if (!args[1 -1]->IsNumber())
                return v8_ThrowArgTypeException(1, "a number (""deltaXOffset"")");
            double deltaXOffset = args[1 -1]->NumberValue();
            if (!args[2 -1]->IsNumber())
                return v8_ThrowArgTypeException(2, "a number (""deltaYOffset"")");
            double deltaYOffset = args[2 -1]->NumberValue();
            offset.x = deltaXOffset;
            offset.y = deltaYOffset;
            if (!args[3 -1]->IsNumber())
                return v8_ThrowArgTypeException(3, "a number (""msDuration3"")");
            long msDuration3 = args[3 -1]->Int32Value();
            if (args.Length() >= 4 && !args[4 -1]->IsNumber())
                return v8_ThrowArgTypeException(4, "a number (""easing_4"")");
            long easing_4 = (args.Length()<4) ? EasingFuncRef::easeInOutQuad : args[4 -1]->Int32Value();;
            easing = easing_4;
            msDuration = msDuration3;
        }
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->changeCenterTo(offset, msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->changeCenterTo(offset, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Wait(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "([number int] msDuration)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        self->wait(msDuration);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetFriction(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Animated]" " function" "(number frictionCoefficient)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""frictionCoefficient"")");
        double frictionCoefficient = args[1 -1]->NumberValue();
        self->setFriction(frictionCoefficient);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::ApplyForce(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Vector] force, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector force = v8_ValueToVector(args[1 -1]);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyForce(force, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::ApplyTorque(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number forceSpin, [number int] msDuration = duration_Instantaneous)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""forceSpin"")");
        double forceSpin = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = (args.Length()<2) ? Animated::duration_Instantaneous : args[2 -1]->Int32Value();;
        self->applyTorque(forceSpin, msDuration);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StopAllForces(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopAllForces();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::AddAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        self->mAnimatedScriptObj = v8::Persistent<v8::Object>::New(args.This());
        SCRIPT_DEBUG_ONLY( if (args[0].IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else if (!args[0]->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "args[0]" "|"<<*((void**)&(args[0]))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = args[0]->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                IAnimationHelperWrap* obj__=jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<IAnimationHelperWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - is a subclass of native ""IAnimationHelper""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|"<<*((void**)&(args[0]))<<"): " << objName << " - does not wrap ""IAnimationHelper""\n";
                }
            }
            else
            {
                IAnimationHelper* obj = dynamic_cast<IAnimationHelper*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""args[0]""|" << *((void**)&(args[0])) << "): " << objName<<" - wraps native ""IAnimationHelper"" ("<<(void*)obj<<")\n";
            }
        } );
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_OR_SUBCLASS_ARG(1, helper, IAnimationHelper);
        self->addAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::RemoveAnimationHelper(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object IAnimationHelper] helper)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, helper, IAnimationHelper);
        self->removeAnimationHelper(helper);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::ClearAnimationHelpers(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->clearAnimationHelpers();
        return scope.Close( v8::Undefined() );
    }

#ifndef PDG_NO_GUI

    v8::Handle<v8::Value> TileLayerWrap::GetSpritePort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Port]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Port* port = self->getSpritePort();
        if (!port) return scope.Close( v8::Null() );
        if (port->mPortScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = PortWrap::NewFromNative(port);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( port->mPortScriptObj );
        };
    }

    v8::Handle<v8::Value> TileLayerWrap::SetSpritePort(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Port] port)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, port, Port);
        self->setSpritePort(port);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetOrigin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Point] origin)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point origin = v8_ValueToPoint(args[1 -1]);
        self->setOrigin(origin);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetOrigin(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()" " - " "get the point in the layer that is drawn at 0,0 in the port") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Point p = self->getOrigin();
        return scope.Close( v8_MakeJavascriptPoint(p) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetAutoCenter(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean autoCenter = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""autoCenter"")");
        bool autoCenter = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setAutoCenter(autoCenter);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetFixedMoveAxis(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean fixedAxis = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""fixedAxis"")");
        bool fixedAxis = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setFixedMoveAxis(fixedAxis);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetZoom(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number zoomLevel)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        self->setZoom(zoomLevel);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetZoom(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "get the current zoom factor") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        float zoom = self->getZoom();
        return scope.Close( v8::Number::New(zoom) );
    }

    v8::Handle<v8::Value> TileLayerWrap::ZoomTo(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number zoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""zoomLevel"")");
        double zoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(args[5 -1]))
            return v8_ThrowArgTypeException(5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoomTo(zoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoomTo(zoomLevel, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Zoom(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number deltaZoomLevel, [number int] msDuration, [number int] easing = easeInOutQuad, [object Rect] keepInRect = Rect(0,0), [object Point] centerOn = Point(0,0) )" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""deltaZoomLevel"")");
        double deltaZoomLevel = args[1 -1]->NumberValue();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""msDuration"")");
        long msDuration = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""easing"")");
        long easing = (args.Length()<3) ? EasingFuncRef::easeInOutQuad : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !v8_ValueIsRect(args[4 -1]))
            return v8_ThrowArgTypeException(4, "Rect", *args[4 -1]);
        pdg::Rect keepInRect = (args.Length()<4) ? pdg::Rect(0,0) : v8_ValueToRect(args[4 -1]);
        if (args.Length() >= 5 && !v8_ValueIsPoint(args[5 -1]))
            return v8_ThrowArgTypeException(5, "Point", *args[5 -1]);
        pdg::Point centerOn = (args.Length()<5) ? pdg::Point(0,0) : v8_ValueToPoint(args[5 -1]);
        pdg::Point* centerOnPtr = (args.Length() >= 5) ? &centerOn : 0;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->zoom(deltaZoomLevel, msDuration, gEasingFunctions[easing], keepInRect, centerOnPtr);
        }
        else
        {
            self->zoom(deltaZoomLevel, msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::LayerToPortPoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "([object Point] p)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(args[1 -1]);
        Point out = self->layerToPort(p);
        return scope.Close( v8_MakeJavascriptPoint(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::LayerToPortOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "([object Offset] o)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(args[1 -1]);
        Offset out = self->layerToPort(o);
        return scope.Close( v8_MakeJavascriptOffset(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::LayerToPortVector(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "([object Vector] v)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(args[1 -1]);
        Vector out = self->layerToPort(v);
        return scope.Close( v8_MakeJavascriptVector(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::LayerToPortRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "([object Rect] r)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsRotatedRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(args[1 -1]);
        RotatedRect out = self->layerToPort(r);
        return scope.Close( v8_MakeJavascriptRect(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::LayerToPortQuad(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Quad]" " function" "([object Quad] q)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(args[1 -1]);
        Quad out = self->layerToPort(q);
        return scope.Close( v8_MakeJavascriptQuad(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::PortToLayerPoint(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "([object Point] p)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsPoint(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Point", *args[1 -1]);
        pdg::Point p = v8_ValueToPoint(args[1 -1]);
        Point out = self->portToLayer(p);
        return scope.Close( v8_MakeJavascriptPoint(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::PortToLayerOffset(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Offset]" " function" "([object Offset] o)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsOffset(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Offset", *args[1 -1]);
        pdg::Offset o = v8_ValueToOffset(args[1 -1]);
        Offset out = self->portToLayer(o);
        return scope.Close( v8_MakeJavascriptOffset(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::PortToLayerVector(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Vector]" " function" "([object Vector] v)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsVector(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Vector", *args[1 -1]);
        pdg::Vector v = v8_ValueToVector(args[1 -1]);
        Vector out = self->portToLayer(v);
        return scope.Close( v8_MakeJavascriptVector(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::PortToLayerRect(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "([object Rect] r)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsRotatedRect(args[1 -1]))
            return v8_ThrowArgTypeException(1, "RotatedRect", *args[1 -1]);
        pdg::RotatedRect r = v8_ValueToRotatedRect(args[1 -1]);
        RotatedRect out = self->portToLayer(r);
        return scope.Close( v8_MakeJavascriptRect(out) );
    }

    v8::Handle<v8::Value> TileLayerWrap::PortToLayerQuad(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Quad]" " function" "([object Quad] q)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!v8_ValueIsQuad(args[1 -1]))
            return v8_ThrowArgTypeException(1, "Quad", *args[1 -1]);
        pdg::Quad q = v8_ValueToQuad(args[1 -1]);
        Quad out = self->portToLayer(q);
        return scope.Close( v8_MakeJavascriptQuad(out) );
    }
#endif

    v8::Handle<v8::Value> TileLayerWrap::SetSerializationFlags(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object SpriteLayer]" " function" "([number uint] flags)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""flags"")");
        unsigned long flags = args[1 -1]->Uint32Value();
        self->setSerializationFlags(flags);
        return scope.Close( args.This() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StartAnimations(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->startAnimations();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::StopAnimations(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->stopAnimations();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Hide(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->hide();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::Show(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->show();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::IsHidden(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        bool hidden = self->isHidden();
        return scope.Close( v8::Boolean::New(hidden) );
    }

    v8::Handle<v8::Value> TileLayerWrap::FadeIn(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeIn(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeIn(msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::FadeOut(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] msDuration, [number int] easing = linearTween)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""msDuration"")");
        long msDuration = args[1 -1]->Int32Value();
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""easing"")");
        long easing = (args.Length()<2) ? EasingFuncRef::linearTween : args[2 -1]->Int32Value();;
        if (easing >= 0 && easing < NUM_EASING_FUNCTIONS)
        {
            self->fadeOut(msDuration, gEasingFunctions[easing]);
        }
        else
        {
            self->fadeOut(msDuration);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::MoveBehind(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] layer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveBehind(layer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::MoveInFrontOf(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] layer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, layer, SpriteLayer);
        self->moveInFrontOf(layer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::MoveToFront(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "move this layer in front of all other layers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->moveToFront();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::MoveToBack(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "move this layer behind all other layers") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->moveToBack();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::MoveWith(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("" " function" "([object SpriteLayer] layer, number moveRatio = 1.0, number zoomRatio = 1.0 )" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, layer, SpriteLayer);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""moveRatio"")");
        double moveRatio = (args.Length()<2) ? 1.0f : args[2 -1]->NumberValue();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""zoomRatio"")");
        double zoomRatio = (args.Length()<3) ? 1.0f : args[3 -1]->NumberValue();;
        self->moveWith(layer, moveRatio, zoomRatio);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::IsSpriteBehind(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([object Sprite] sprite, [object Sprite] otherSprite)" " - " "") );
        };
        if (args.Length() != 2)
            return v8_ThrowArgCountException(args.Length(), 2);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        REQUIRE_NATIVE_OBJECT_ARG(2, otherSprite, Sprite);
        bool behind = self->isSpriteBehind(sprite, otherSprite);
        return scope.Close( v8::Boolean::New(behind) );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetZOrder(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[number int]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        int zorder = self->getZOrder();
        return scope.Close( v8::Integer::New(zorder) );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetSpriteZOrder(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[number int]" " function" "([object Sprite] sprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        int zorder = self->getSpriteZOrder(sprite);
        return scope.Close( v8::Integer::New(zorder) );
    }

    v8::Handle<v8::Value> TileLayerWrap::FindSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([number int] id)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""id"")");
        long id = args[1 -1]->Int32Value();
        Sprite* sprite = self->findSprite(id);
        if (!sprite) return scope.Close( v8::Null() );
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(sprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( sprite->mSpriteScriptObj );
        };
    }

    v8::Handle<v8::Value> TileLayerWrap::GetNthSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "([number int] index)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""index"")");
        long index = args[1 -1]->Int32Value();
        Sprite* sprite = self->getNthSprite(index);
        if (!sprite) return scope.Close( v8::Null() );
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(sprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( sprite->mSpriteScriptObj );
        };
    }

    v8::Handle<v8::Value> TileLayerWrap::HasSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "([object Sprite] sprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, sprite, Sprite);
        bool found = self->hasSprite(sprite);
        return scope.Close( v8::Boolean::New(found) );
    }

    v8::Handle<v8::Value> TileLayerWrap::AddSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Sprite] newSprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, newSprite, Sprite);
        self->addSprite(newSprite);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::RemoveSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object Sprite] oldSprite)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, oldSprite, Sprite);
        self->removeSprite(oldSprite);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::RemoveAllSprites(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->removeAllSprites();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::EnableCollisions(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->enableCollisions();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::DisableCollisions(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        self->disableCollisions();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::EnableCollisionsWithLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->enableCollisionsWithLayer(otherLayer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::DisableCollisionsWithLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([object SpriteLayer] otherLayer)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        REQUIRE_NATIVE_OBJECT_ARG(1, otherLayer, SpriteLayer);
        self->disableCollisionsWithLayer(otherLayer);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::CreateSprite(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Sprite]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Sprite* sprite = self->createSprite();
        if (!sprite) return scope.Close( v8::Null() );
        if (sprite->mSpriteScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = SpriteWrap::NewFromNative(sprite);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( sprite->mSpriteScriptObj );
        };
    }

#ifdef PDG_USE_CHIPMUNK_PHYSICS

    v8::Handle<v8::Value> TileLayerWrap::SetKeepGravityDownward(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean keepItDownward = true)" " - " "") );
        };
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setKeepGravityDownward(keepItDownward);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetGravity(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number gravity, boolean keepItDownward = true)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""gravity"")");
        double gravity = args[1 -1]->NumberValue();
        if (args.Length() >= 2 && !args[2 -1]->IsBoolean())
            return v8_ThrowArgTypeException(2, "a boolean (""keepItDownward"")");
        bool keepItDownward = (args.Length()<2) ? true : args[2 -1]->BooleanValue();;
        self->setGravity(gravity, keepItDownward);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetDamping(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(number damping)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""damping"")");
        double damping = args[1 -1]->NumberValue();
        self->setDamping(damping);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetStaticLayer(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean isStatic = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""isStatic"")");
        bool isStatic = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setStaticLayer(isStatic);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetUseChipmunkPhysics(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(boolean useIt = true)" " - " "") );
        };
        if (args.Length() < 0)
            return v8_ThrowArgCountException(args.Length(), 0, true);
        if (args.Length() >= 1 && !args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""useIt"")");
        bool useIt = (args.Length()<1) ? true : args[1 -1]->BooleanValue();;
        self->setUseChipmunkPhysics(useIt);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetSpace(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object CpSpace]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        cpSpace* space = self->getSpace();
        if (!space) return scope.Close( v8::Null() );
        return scope.Close( cpSpaceWrap::NewFromNative(space) );;
    }
#endif

    v8::Handle<v8::Value> TileLayerWrap::SetWorldSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] width, [number int] height, boolean repeatingX = false, boolean repeatingY = false)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""width"")");
        long width = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""height"")");
        long height = args[2 -1]->Int32Value();
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            return v8_ThrowArgTypeException(3, "a boolean (""repeatingX"")");
        bool repeatingX = (args.Length()<3) ? false : args[3 -1]->BooleanValue();;
        if (args.Length() >= 4 && !args[4 -1]->IsBoolean())
            return v8_ThrowArgTypeException(4, "a boolean (""repeatingY"")");
        bool repeatingY = (args.Length()<4) ? false : args[4 -1]->BooleanValue();;
        self->setWorldSize(width, height, repeatingX, repeatingY);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetWorldSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Rect r = self->getWorldSize();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetWorldBounds(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Rect]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Rect r = self->getWorldBounds();
        return scope.Close( v8_MakeJavascriptRect(r) );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetTileTypeAt(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([number int] x, [number int] y)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""x"")");
        long x = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""y"")");
        long y = args[2 -1]->Int32Value();
        uint8 tileType;
        tileType = self->getTileTypeAt(x, y);
        return scope.Close( v8::Integer::NewFromUnsigned(tileType) );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetTileTypeAndFacingAt(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("object" " function" "([number int] x, [number int] y)" " - " "") );
        };
        if (args.Length() < 2)
            return v8_ThrowArgCountException(args.Length(), 2, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""x"")");
        long x = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""y"")");
        long y = args[2 -1]->Int32Value();
        uint8 tileType;
        TileLayer::TFacing facing;
        tileType = self->getTileTypeAt(x, y, &facing);
        if (self->mUseFacing || self->mUseFlipping)
        {
            if (self->mUseFlipping && (!self->mFlipHoriz || !self->mFlipVert))
            {
                tileType &= 0x7f;
            }
            else
            {
                tileType &= 0x3f;
            }
        }
        v8::Handle<v8::Object> tileInfo = v8_ObjectCreateEmpty(0);
        tileInfo->Set(v8::String::NewSymbol("tileType"), v8::Integer::NewFromUnsigned(tileType));
        tileInfo->Set(v8::String::NewSymbol("facing"), v8::Integer::NewFromUnsigned(facing));
        return scope.Close( tileInfo );
    }

    v8::Handle<v8::Value> TileLayerWrap::DefineTileSet(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] tileWidth, [number int] tileHeight, [object Image] tiles, boolean hasTransparency = true, boolean flipTiles = false)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""tileWidth"")");
        long tileWidth = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""tileHeight"")");
        long tileHeight = args[2 -1]->Int32Value();
        REQUIRE_NATIVE_OBJECT_ARG(3, tiles, Image);
        if (args.Length() >= 4 && !args[4 -1]->IsBoolean())
            return v8_ThrowArgTypeException(4, "a boolean (""hasTransparency"")");
        bool hasTransparency = (args.Length()<4) ? true : args[4 -1]->BooleanValue();;
        if (args.Length() >= 5 && !args[5 -1]->IsBoolean())
            return v8_ThrowArgTypeException(5, "a boolean (""flipTiles"")");
        bool flipTiles = (args.Length()<5) ? false : args[5 -1]->BooleanValue();;
        self->defineTileSet(tileWidth, tileHeight, tiles, hasTransparency, flipTiles);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::LoadMapData(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "({[string Binary]|[object MemBlock]} data, [number int] mapWidth = 0, [number int] mapHeight = 0, [number int] dstX, [number int] dstY)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""mapWidth"")");
        long mapWidth = (args.Length()<2) ? 0 : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""mapHeight"")");
        long mapHeight = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""dstX"")");
        long dstX = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        if (args.Length() >= 5 && !args[5 -1]->IsNumber())
            return v8_ThrowArgTypeException(5, "a number (""dstY"")");
        long dstY = (args.Length()<5) ? 0 : args[5 -1]->Int32Value();;
        if (mapWidth > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 2 (mapWidth) is larger than world width";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        if ((mapWidth + dstX) > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "mapWidth + dstX is larger than world width";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        if (mapHeight > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 3 (mapHeight) is larger than world height";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        if ((mapHeight + dstY) > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "mapHeight + dstY is larger than world height";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        if (!args[0]->IsString() && !((!args[0]->IsObject()) ? false :
            (jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args[0]->ToObject()) != 0) ? true :
            (args[0]->ToObject()->GetPrototype().IsEmpty()) ? false :
            (jswrap::ObjectWrap::Unwrap<MemBlockWrap>(args[0]->ToObject()->GetPrototype()->ToObject()) != 0)))
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (data) must be either a binary string or an object of type MemBlock";
            return v8::ThrowException( v8::Exception::TypeError( v8::String::New(excpt_.str().c_str())));
        }
        if (args[0]->IsString())
        {
            size_t bytes = 0;
            uint8* ptr = (uint8*) DecodeBinary(args[0], &bytes);
            if (bytes < ((size_t)mapWidth * (size_t)mapHeight))
            {
                std::ostringstream excpt_;
                excpt_ << "argument 1 (data) is insufficient, please check mapWidth and mapHeight against data size";
                return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
            }
            self->loadMapData(ptr, mapWidth, mapHeight, dstX, dstY);
            std::free(ptr);
        }
        else
        {
            REQUIRE_NATIVE_OBJECT_ARG(1, memBlock, MemBlock);
            if (memBlock->bytes < ((size_t)mapWidth * (size_t)mapHeight))
            {
                std::ostringstream excpt_;
                excpt_ << "argument 1 (data) is insufficient, please check mapWidth and mapHeight against data size";
                return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
            }
            self->loadMapData((uint8*)memBlock->ptr, mapWidth, mapHeight, dstX, dstY);
        }
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::GetMapData(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object MemBlock]" " function" "([number int] mapWidth = 0, [number int] mapHeight = 0, [number int] srcX, [number int] srcY)" " - " "") );
        };
        if (args.Length() >= 1 && !args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""mapWidth"")");
        long mapWidth = (args.Length()<1) ? self->mWorldWidth : args[1 -1]->Int32Value();;
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""mapHeight"")");
        long mapHeight = (args.Length()<2) ? self->mWorldHeight : args[2 -1]->Int32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""srcX"")");
        long srcX = (args.Length()<3) ? 0 : args[3 -1]->Int32Value();;
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""srcY"")");
        long srcY = (args.Length()<4) ? 0 : args[4 -1]->Int32Value();;
        if (mapWidth > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 1 (mapWidth) is larger than world width";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        if ((mapWidth + srcX) > self->mWorldWidth)
        {
            std::ostringstream excpt_;
            excpt_ << "mapWidth + srcX is larger than world width";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        if (mapHeight > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "argument 2 (mapHeight) is larger than world height";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        if ((mapHeight + srcY) > self->mWorldHeight)
        {
            std::ostringstream excpt_;
            excpt_ << "mapHeight + srcY is larger than world height";
            return v8::ThrowException( v8::Exception::RangeError( v8::String::New(excpt_.str().c_str())));
        }
        const uint8* dataPtr = self->getMapData(mapWidth, mapHeight, srcX, srcY);
        size_t bufferSize = mapWidth * mapHeight;
        uint8* ptr = (uint8*) std::malloc(bufferSize);
        std::memcpy(ptr, dataPtr, bufferSize);
        MemBlock* memBlock = new MemBlock((char*)ptr, bufferSize, true);
        if (!memBlock) return scope.Close( v8::Null() );
        if (memBlock->mMemBlockScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = MemBlockWrap::NewFromNative(memBlock);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( memBlock->mMemBlockScriptObj );
        };
    }

    v8::Handle<v8::Value> TileLayerWrap::GetTileSetImage(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Image]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Image* tiles = self->getTileSetImage();
        if (!tiles) return scope.Close( v8::Null() );
        if (tiles->mImageScriptObj.IsEmpty())
        {
            v8::Handle<v8::Value> obj__ = ImageWrap::NewFromNative(tiles);
            return scope.Close( obj__ );
        }
        else
        {
            return scope.Close( tiles->mImageScriptObj );
        };
    }

    v8::Handle<v8::Value> TileLayerWrap::GetTileSize(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("[object Point]" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        Point size = self->getTileSize();
        return scope.Close( v8_MakeJavascriptPoint(size) );
    }

    v8::Handle<v8::Value> TileLayerWrap::SetTileTypeAt(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number int] x, [number int] y, [number uint] t, [number uint] facing = facing_Ignore)" " - " "") );
        };
        if (args.Length() < 3)
            return v8_ThrowArgCountException(args.Length(), 3, true);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""x"")");
        long x = args[1 -1]->Int32Value();
        if (!args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""y"")");
        long y = args[2 -1]->Int32Value();
        if (!args[3 -1]->IsNumber())
            return v8_ThrowArgTypeException(3, "a number (""t"")");
        unsigned long t = args[3 -1]->Uint32Value();
        if (args.Length() >= 4 && !args[4 -1]->IsNumber())
            return v8_ThrowArgTypeException(4, "a number (""facing"")");
        unsigned long facing = (args.Length()<4) ? (uint32) TileLayer::facing_Ignore : args[4 -1]->Uint32Value();;
        self->setTileTypeAt(x, y, t, (TileLayer::TFacing) facing);
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> TileLayerWrap::CheckCollision(const v8::Arguments& args)
    {
        v8::HandleScope scope;
        TileLayerWrap* objWrapper = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(args.This());
        TileLayer* self = dynamic_cast<TileLayer*>(objWrapper->refPtr_);

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "([object Sprite] movingSprite, [number uint] alphaThreshold = 128, boolean shortCircuit = true)" " - " "") );
        };
        if (args.Length() < 1)
            return v8_ThrowArgCountException(args.Length(), 1, true);
        REQUIRE_NATIVE_OBJECT_ARG(1, movingSprite, Sprite);
        if (args.Length() >= 2 && !args[2 -1]->IsNumber())
            return v8_ThrowArgTypeException(2, "a number (""alphaThreshold"")");
        unsigned long alphaThreshold = (args.Length()<2) ? 128 : args[2 -1]->Uint32Value();;
        if (args.Length() >= 3 && !args[3 -1]->IsBoolean())
            return v8_ThrowArgTypeException(3, "a boolean (""shortCircuit"")");
        bool shortCircuit = (args.Length()<3) ? true : args[3 -1]->BooleanValue();;
        uint32 overlapPx = self->checkCollision(movingSprite, alphaThreshold, shortCircuit);
        return scope.Close( v8::Integer::NewFromUnsigned(overlapPx) );
    }

    void CleanupTileLayerScriptObject(v8::Handle<v8::Object> obj)
    {
        SCRIPT_DEBUG_ONLY( if (obj.IsEmpty())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NIL JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else if (!obj->IsObject())
        {
            std::cerr << __func__<<":"<< __LINE__ << " - NON JS Object (" "obj" "|"<<*((void**)&(obj))<<")\n";
        }
        else
        {
            v8::Handle<v8::Object> obj_ = obj->ToObject();
                v8::String::Utf8Value objNameStr(obj_->ToString());
                char* objName = *objNameStr;
                TileLayerWrap* obj__=jswrap::ObjectWrap::Unwrap<TileLayerWrap>(obj_);
                if (!obj__)
            {
                v8::Handle<v8::Value> protoVal_ = obj_->GetPrototype();
                    if (protoVal_->IsObject())
                {
                    obj_ = protoVal_->ToObject();
                        obj__ = jswrap::ObjectWrap::Unwrap<TileLayerWrap>(obj_);
                }
                if (obj__)
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - is a subclass of native ""TileLayer""\n";
                }
                else
                {
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|"<<*((void**)&(obj))<<"): " << objName << " - does not wrap ""TileLayer""\n";
                }
            }
            else
            {
                TileLayer* obj = dynamic_cast<TileLayer*>(obj__->getNativeObject());
                    std::cout << __func__<<":"<< __LINE__ << " - JS Object (""obj""|" << *((void**)&(obj)) << "): " << objName<<" - wraps native ""TileLayer"" ("<<(void*)obj<<")\n";
            }
        } );
        if (!obj.IsEmpty())
        {
            DEBUG_PRINT("Cleanup" "TileLayer" "ScriptObject for JSObj [%p][%s]" , *obj, typeid_name(*obj));
        }
    }

    TileLayer* New_TileLayer(const v8::Arguments& args)
    {
        if (s_TileLayer_InNewFromNative) return 0;
        return 0;
    }

    ScriptSerializable::ScriptSerializable()
    {
    }

    ScriptEventHandler::ScriptEventHandler()
    {
    }

    ScriptAnimationHelper::ScriptAnimationHelper()
    {
    }

    ScriptSpriteCollideHelper::ScriptSpriteCollideHelper()
    {
    }

#ifndef PDG_NO_GUI

    ScriptSpriteDrawHelper::ScriptSpriteDrawHelper()
    {
    }
#endif

    v8::Handle<v8::Value> Rand(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        return scope.Close( v8::Integer::NewFromUnsigned(OS::rand()) );
    }
    v8::Handle<v8::Value> GameCriticalRandom(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("number" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        return scope.Close( v8::Integer::NewFromUnsigned(OS::gameCriticalRandom()) );
    }
    v8::Handle<v8::Value> Srand(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "([number uint] seed)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsNumber())
            return v8_ThrowArgTypeException(1, "a number (""seed"")");
        unsigned long seed = args[1 -1]->Uint32Value();
        OS::srand( seed );
        return scope.Close( v8::Undefined() );
    }
    v8::Handle<v8::Value> SetSerializationDebugMode(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "(bool debugMode)" " - " "") );
        };
        if (args.Length() != 1)
            return v8_ThrowArgCountException(args.Length(), 1);
        if (!args[1 -1]->IsBoolean())
            return v8_ThrowArgTypeException(1, "a boolean (""debugMode"")");
        bool debugMode = args[1 -1]->BooleanValue();
        ISerializer::s_DebugMode = debugMode;
        return scope.Close( v8::Undefined() );
    }

    bool Initializer::allowHorizontalOrientation() throw() { return true; }
    bool Initializer::allowVerticalOrientation() throw() { return true; }
    const char* Initializer::getAppName(bool haveMainResourceFile) throw() { return "pdg"; }
    const char* Initializer::getMainResourceFileName() throw() {return NULL;}
    bool Initializer::installGlobalHandlers() throw() {return true;}
    bool Initializer::getGraphicsEnvironmentDimensions(Rect maxWindowDim, Rect maxFullScreenDim,
        long& ioWidth, long& ioHeight, uint8& ioDepth) throw()
    {
        ioWidth = 640;
        ioHeight = 480;
        ioDepth = 32;
        return false;
    }

    v8::Handle<v8::Value> Idle(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg_LibIdle();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> Run(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg_LibRun();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> Quit(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("undefined" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        pdg_LibQuit();
        return scope.Close( v8::Undefined() );
    }

    v8::Handle<v8::Value> IsQuitting(const v8::Arguments& args)
    {
        v8::HandleScope scope;

        if (args.Length() == 1 && args[0]->IsNull())
        {
            return scope.Close( v8::String::New("boolean" " function" "()" " - " "") );
        };
        if (args.Length() != 0)
            return v8_ThrowArgCountException(args.Length(), 0);
        bool isQuitting = pdg_LibIsQuitting();
        return scope.Close( v8::Boolean::New(isQuitting) );
    }

}
