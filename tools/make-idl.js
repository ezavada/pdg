// -----------------------------------------------
// main.js
//
// Written by Ed Zavada, 2012
// Copyright (c) 2012, Dream Rock Studios, LLC
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// -----------------------------------------------

var pdg = require('pdg');
var fs = require('fs');

var pdg_dir = process.env['PDG_ROOT'];
var verbose = (parseInt(process.env['VERBOSE']) == 1);
var out = pdg_dir+"/build/pdg-js.out";

fs.writeFileSync(out, "// this file was automatically generated by tools/main.js\n\n");
fs.appendFileSync(out, "START_NAMESPACE(pdg)\n\n");

function typeString(o) {
  if (typeof o != 'object')
    return typeof o;
  if (o === null)
      return "null";
  //object, array, function, date, regexp, string, number, boolean, error
  var internalClass = Object.prototype.toString.call(o); //.match(/\[object\s(\w+)\]/)[1];
  return internalClass; //.toLowerCase();
}

function getProperties(obj, isClassify, indent) {
   var propList = "";
   var functionList = "";
   if (!indent) {
      indent = "\t";
   }
   for (var propName in obj) {
      if (propName[0] != '_') {
		  if (typeof(obj[propName]) == "function") {
		  } else if (typeof(obj[propName]) != "undefined") {
			var val = ""+obj[propName];
			var type = typeString(obj[propName]);
			// unless this is an object created by classify, look for predefined numeric values
			// and call them constants
			 if (!isClassify && type == "number" && val.match(/[0-9]+/i) ) {
				propList += indent + "CONSTANT(" + propName + ", " + val +", number)\n";
			 } else if (!isClassify && type == "boolean" && propName.match(/_/) ) {
				propList += indent + "CONSTANT(" + propName + ", " + val +", boolean)\n";
			 } else {
				if (type == "[object Array]") {
					var arrayMemberType = typeString(obj[propName][0]);
					if (arrayMemberType != "null") {
						if (isClassify && arrayMemberType == "[object Object]") {
							// figure out what type the classify object really is
							var altType = ""+obj[propName][0];
							arrayMemberType = "[object "+altType.match(/[A-Z,a-z,0-9]+/)[0] +"]";
						}
						type = arrayMemberType + "[]";
					}
				} else if (isClassify && type == "[object Object]") {
					var altType = val.match(/[A-Z,a-z,0-9]+/)[0];
					type = "[object "+altType+"]";
				}
				propList += indent + "VARIABLE(" + propName + ", " + type + ")\n";
			 }
		  }
      }
   }
	return propList;
}

function getFunctionInfo(obj, propName) {
	var noInfo = 'undefined, (), ""';
	var crash = 'undefined, "FATAL ERROR", ""';
	if (verbose) console.log("  function "+propName);
	// these are all functions that caused problems when we tried to call them
	// need to investigate
//	if (propName == "gameCriticalRandom") return crash;
//	if (propName == "on") return crash;
//	if (propName == "onDonePlaying") return crash;
//	if (propName == "onLooping") return crash;
//	if (propName == "onFailedToPlay") return crash;
//	if (propName == "addAnimationHelper") return crash;
	// this is a javascript standard that always does the same thing
	if (propName == "toString") return 'string, (), "return string representation "';
	try {
		// calling with a single null param tells our methods to report their signature
		var result = obj[propName](null); 
		if (result.indexOf(") - ") < 0) {
			// make sure all results have the " - " to mark the brief description, even if
			// there isn't one
			result += ' - ';
		}
			// fix up the method documentation text
		while (result.indexOf("\n") >= 0) {
			result = result.replace("\n", " <br/><br/> ");
		}
		if (result.lastIndexOf("{") > 0) { // deliberately ignoring if 1st char is {
			var startBlock = result.lastIndexOf("{")+1;
			var endBlock = result.lastIndexOf("}");
			var variantBlock = result.substring(startBlock, endBlock);
			var variants = variantBlock.split('|');
			var nResult = result.substring(0, startBlock) + result.substring(endBlock, result.length);
			var resultList = new Array();
			for (var i in variants) {
				var tmp = nResult.replace("{}", variants[i]);
				tmp = tmp.replace("( (", "(").replace(") )", ")");
				tmp = tmp.replace(") - ", "), \"").replace(" function(", ", (") + '"';
				resultList.push(tmp);
			}
			result = resultList;
		} else {
			result = result.replace(") - ", "), \"").replace(" function(", ", (") + '"';
		}
		return result;
	}
	catch(e) {
		return 'undefined, "Exception: ' + e.message + '", ""';
	}
}

function getClassName(klass) {
	var name = klass.toString();
	name = name.replace('function ', '');
	name = name.replace('() { [native code] }', '');
	name = name.replace('[object ', '');
	name = name.replace(']', '');
	name = name.split("{", 1)[0];
	return name.trim();
}

function getSupers(parent, klass) {
   var supers = [];
   var superName;
   var obj;
   if (parent && typeof(parent[klass].superclass) != 'undefined') {
      if (typeof(parent[klass].superclass) == 'object') { 
   		 for (var idx in parent[klass].superclass) {
   		 	superName = getClassName(parent[klass].superclass[idx]);
   		 	supers.concat( getSupers(parent, superName) );
   		 	obj = new parent[klass].superclass[idx];
      		if (verbose) console.log(' :: '+superName);
   			supers.push(obj);
   		 }
   	  } else {
   	     superName = getClassName(parent[klass].superclass);
   		 supers.concat( getSupers(parent, superName) );
   	     obj = new parent[klass].superclass;
      	 if (verbose) console.log(' :: '+superName);
   	     supers.push(obj);
   	  }
   }
   return supers;
}

function isInherited(funcName, supers) {
   for (var i in supers) {
      var superman = supers[i];
      if (typeof(superman[funcName]) == 'function') {
//      	 if (verbose) console.log('     '+getClassName(superman)+'::'+funcName);
         return true;
      }
   }
   return false;
}

function getFunctions(parent, klass, obj, str) {
   if (!str) {
   	str = "FUNCTION";
   }
   var haveConstructor = false;
   var functionList = "";
   var supers = getSupers(parent, klass);
//   console.log(supers);
   for (var propName in obj) {
      if (typeof(obj[propName]) == "function") {
      	  // note special case for LogManager which has an initialize function that is not a constructor
      	 if ((klass != null) && (klass != "LogManager") && ((propName == "initialize") || (propName == "constructor"))) {
      	 	if (!haveConstructor) {
      	 		var result = getFunctionInfo(obj, "initialize");
      	 		if (result instanceof Array) {
					for (var i in result) {
      	 				functionList += "\t\tCONSTRUCTOR("+klass+", "+result[i]+")\n";
					}
      	 		} else {
      	 			functionList += "\t\tCONSTRUCTOR("+klass+", "+result+")\n";
      	 		}
      	 		haveConstructor = true;
      	 	}
      	 } else if (propName.substring(0, 1).match(/[a-z]/)) {
      	    if (!isInherited(propName, supers)) {
      	 	   var result = getFunctionInfo(obj, propName);
      	 	   if (result instanceof Array) {
      	 		  for (var i in result) {
         			functionList += "\t"+str+"("+propName+", "+ result[i] +")\n";
     	 		  }
         	   } else {
         		  functionList += "\t"+str+"("+propName+", "+ result +")\n";
         	   }
         	}
		 }
//         propList += "\tFUNCTION("+propName+", "+(obj[propName]+")\n");
      }
   }
	return functionList;
}

function getClassNameAndSuperclasses(obj, klass) {
	var superclass = obj[klass].superclass;
	if (superclass) {
		superclass = superclass.toString();
		while (superclass.indexOf("function ") >= 0) {
			superclass = superclass.replace("function ", "INTERFACE_NAME(");
			superclass = superclass.replace("() { [native code] }", ")");
			superclass = superclass.replace(",", " AND ");
		}
		if (superclass.indexOf("INTERFACE_NAME") < 0) {
			superclass = "INTERFACE_NAME("+superclass+")";
		}
		superclass = ', EXTENDS('+ superclass + ') ';
	} else {
		superclass = ', ';
	}
	return klass + superclass;
}

function getClassInfo(obj, klass) {
	var inst = new obj[klass];
	var isClassify = false;
	if (verbose) console.log("class "+klass);
	for (var propName in obj[klass]) {
	   if (typeof(obj[propName]) == "function") {
		  if (propName == "toString") {
		  	isClassify = true;
		  	break;
		  }
	   }
	}
	if (isClassify) {
		// classify defines member variables that look like constants to us
		return getProperties(inst, true, "\t\t") + getFunctions(obj, klass, inst, "\tMETHOD");
	} else {
		return getProperties(inst, false, "\t\t") + getFunctions(obj, klass, inst, "\tMETHOD");
	}
}

function getClasses(obj) {
   var classList = "";
   for (var propName in obj) {
      if (typeof(obj[propName]) == "function") {
		 if (propName.substring(0, 1).match(/[A-Z]/)) {
         	classList += "\n\tINTERFACE("+getClassNameAndSuperclasses(obj, propName)+")\n"
         	classList += getClassInfo(obj, propName);
         	classList += "\tEND\n";
		 }
//         propList += "\tFUNCTION("+propName+", "+(obj[propName]+")\n");
      }
   }
	return classList;
}

console.log('Regenerating interface file: '+out);
console.log('-- Reading globals...');

var propList = getProperties(pdg);
fs.appendFileSync(out, "// globals\n");
fs.appendFileSync(out, propList);

console.log('-- Reading global functions...');

var functionList = getFunctions(null, null, pdg);
fs.appendFileSync(out, "// functions\n");
fs.appendFileSync(out, functionList);

console.log('-- Reading classes...');

var classList = getClasses(pdg);
fs.appendFileSync(out, "// interfaces\n");
fs.appendFileSync(out, classList);

fs.appendFileSync(out, "END_NAMESPACE(pdg)\n\n");
